<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>exchangelib.credentials API documentation</title>
<meta name="description" content="Implements an Exchange user object and access types. Exchange provides two different ways of granting access for a
login to a specific account â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>exchangelib.credentials</code></h1>
</header>
<section id="section-intro">
<p>Implements an Exchange user object and access types. Exchange provides two different ways of granting access for a
login to a specific account. Impersonation is used mainly for service accounts that connect via EWS. Delegate is used
for ad-hoc access e.g. granted manually by the user.
See <a href="https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/impersonation-and-ews-in-exchange">https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/impersonation-and-ews-in-exchange</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Implements an Exchange user object and access types. Exchange provides two different ways of granting access for a
login to a specific account. Impersonation is used mainly for service accounts that connect via EWS. Delegate is used
for ad-hoc access e.g. granted manually by the user.
See https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/impersonation-and-ews-in-exchange
&#34;&#34;&#34;

import abc
import logging
from threading import RLock

import oauthlib.oauth2
from cached_property import threaded_cached_property

from .errors import InvalidTypeError

log = logging.getLogger(__name__)

IMPERSONATION = &#34;impersonation&#34;
DELEGATE = &#34;delegate&#34;
ACCESS_TYPES = (IMPERSONATION, DELEGATE)


class BaseCredentials(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Base class for credential storage.&#34;&#34;&#34;

    def __eq__(self, other):
        return all(getattr(self, k) == getattr(other, k) for k in self.__dict__)

    def __hash__(self):
        return hash(tuple((getattr(self, k) for k in self.__dict__)))


class Credentials(BaseCredentials):
    r&#34;&#34;&#34;Keeps login info the way Exchange likes it.

    Usernames for authentication are of one of these forms:
    * PrimarySMTPAddress
    * WINDOMAIN\username
    * User Principal Name (UPN)
      password: Clear-text password
    &#34;&#34;&#34;

    EMAIL = &#34;email&#34;
    DOMAIN = &#34;domain&#34;
    UPN = &#34;upn&#34;

    def __init__(self, username, password):
        super().__init__()
        if username.count(&#34;@&#34;) == 1:
            self.type = self.EMAIL
        elif username.count(&#34;\\&#34;) == 1:
            self.type = self.DOMAIN
        else:
            self.type = self.UPN
        self.username = username
        self.password = password

    def __repr__(self):
        return self.__class__.__name__ + repr((self.username, &#34;********&#34;))

    def __str__(self):
        return self.username


class BaseOAuth2Credentials(BaseCredentials):
    &#34;&#34;&#34;Base class for all classes that implement OAuth 2.0 authentication&#34;&#34;&#34;

    def __init__(self, client_id, client_secret, tenant_id=None, identity=None, access_token=None):
        &#34;&#34;&#34;

        :param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
        :param client_secret: Secret associated with the OAuth application
        :param tenant_id: Microsoft tenant ID of the account to access
        :param identity: An Identity object representing the account that these credentials are connected to.
        :param access_token: Previously-obtained access token, as a dict or an oauthlib.oauth2.OAuth2Token
        &#34;&#34;&#34;
        super().__init__()
        self.client_id = client_id
        self.client_secret = client_secret
        self.tenant_id = tenant_id
        self.identity = identity
        self.access_token = access_token

        self._lock = RLock()

    @property
    def lock(self):
        return self._lock

    @property
    def access_token(self):
        return self._access_token

    @access_token.setter
    def access_token(self, access_token):
        if access_token is not None and not isinstance(access_token, dict):
            raise InvalidTypeError(&#34;access_token&#34;, access_token, oauthlib.oauth2.OAuth2Token)
        self._access_token = access_token

    def refresh(self, session):
        &#34;&#34;&#34;Obtain a new set of valid credentials. This is intended to support OAuth token refreshing, which can
        happen in long-running applications or those that cache access tokens and so might start with a token close to
        expiration.

        :param session: requests session asking for refreshed credentials
        :return:
        &#34;&#34;&#34;
        # Creating a new session gets a new access token, so there&#39;s no work here to refresh the credentials.

    def on_token_auto_refreshed(self, access_token):
        &#34;&#34;&#34;Set the access_token. Called after the access token is refreshed (requests-oauthlib can automatically
        refresh tokens if given an OAuth client ID and secret, so this is how our copy of the token stays up-to-date).
        Applications that cache access tokens can override this to store the new token - just remember to call the
        super() method.

        :param access_token: New token obtained by refreshing
        &#34;&#34;&#34;
        # Ensure we don&#39;t update the object in the middle of a new session being created, which could cause a race.
        with self.lock:
            log.debug(&#34;%s auth token for %s&#34;, &#34;Refreshing&#34; if self.access_token else &#34;Setting&#34;, self.client_id)
            self.access_token = access_token

    def sig(self):
        # Like hash(self), but pulls in the access token. Protocol.refresh_credentials() uses this to find out
        # if the access_token needs to be refreshed.
        res = []
        for k in self.__dict__:
            if k in (&#34;_lock&#34;, &#34;identity&#34;):
                continue
            if k == &#34;_access_token&#34;:
                res.append(self.access_token[&#34;access_token&#34;] if self.access_token else None)
                continue
            res.append(getattr(self, k))
        return hash(tuple(res))

    @property
    def token_url(self):
        &#34;&#34;&#34;The URL to request tokens from&#34;&#34;&#34;
        # We may not know (or need) the Microsoft tenant ID. If not, use common/ to let Microsoft select the appropriate
        # tenant for the provided authorization code or refresh token.
        return f&#34;https://login.microsoftonline.com/{self.tenant_id or &#39;common&#39;}/oauth2/v2.0/token&#34;  # nosec

    @property
    def scope(self):
        &#34;&#34;&#34;The scope we ask for the token to have&#34;&#34;&#34;
        return [&#34;https://outlook.office365.com/.default&#34;]

    def session_params(self):
        &#34;&#34;&#34;Extra parameters to use when creating the session&#34;&#34;&#34;
        res = {&#34;token&#34;: self.access_token}  # Token may be None
        if self.client_id and self.client_secret:
            # If we&#39;re given a client ID and secret, we have enough to refresh access tokens ourselves. In other
            # cases the session will raise TokenExpiredError, and we&#39;ll need to ask the calling application to
            # refresh the token (that covers cases where the caller doesn&#39;t have access to the client secret but
            # is working with a service that can provide it refreshed tokens on a limited basis).
            res.update(
                {
                    &#34;auto_refresh_kwargs&#34;: {
                        &#34;client_id&#34;: self.client_id,
                        &#34;client_secret&#34;: self.client_secret,
                    },
                    &#34;auto_refresh_url&#34;: self.token_url,
                    &#34;token_updater&#34;: self.on_token_auto_refreshed,
                }
            )
        return res

    def token_params(self):
        &#34;&#34;&#34;Extra parameters when requesting the token&#34;&#34;&#34;
        return {&#34;include_client_id&#34;: True}

    @threaded_cached_property
    @abc.abstractmethod
    def client(self):
        &#34;&#34;&#34;The client implementation to use for this credential class&#34;&#34;&#34;

    def __eq__(self, other):
        return all(getattr(self, k) == getattr(other, k) for k in self.__dict__ if k != &#34;_lock&#34;)

    def __hash__(self):
        # &#39;access_token&#39; may be refreshed once in a while. This should not affect the hash signature.
        # &#39;identity&#39; is just informational and should also not affect the hash signature.
        return hash(tuple(getattr(self, k) for k in self.__dict__ if k not in (&#34;_lock&#34;, &#34;identity&#34;, &#34;_access_token&#34;)))

    def __str__(self):
        return self.client_id

    def __repr__(self):
        return self.__class__.__name__ + repr((self.client_id, &#34;********&#34;))

    def __getstate__(self):
        # The lock cannot be pickled
        state = self.__dict__.copy()
        del state[&#34;_lock&#34;]
        return state

    def __setstate__(self, state):
        # Restore the lock
        self.__dict__.update(state)
        self._lock = RLock()


class OAuth2Credentials(BaseOAuth2Credentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 client credentials authentication, as well as a base for other OAuth 2.0 grant types.

    This is primarily useful for in-house applications accessing data from a single Microsoft account. For applications
    that will access multiple tenants&#39; data, the client credentials flow does not give the application enough
    information to restrict end users&#39; access to the appropriate account. Use OAuth2AuthorizationCodeCredentials and
    the associated auth code grant type for multi-tenant applications.
    &#34;&#34;&#34;

    @threaded_cached_property
    def client(self):
        return oauthlib.oauth2.BackendApplicationClient(client_id=self.client_id)


class OAuth2LegacyCredentials(OAuth2Credentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 authentication using delegated permissions and application permissions.

    This requires the app to acquire username and password from the user and pass that when requesting authentication
    tokens for the given user. This allows the app to act as the signed-in user.
    &#34;&#34;&#34;

    def __init__(self, username, password, **kwargs):
        &#34;&#34;&#34;
        :param username: The username of the user to act as
        :param password: The password of the user to act as
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.username = username
        self.password = password

    def token_params(self):
        res = super().token_params()
        res.update(
            {
                &#34;username&#34;: self.username,
                &#34;password&#34;: self.password,
            }
        )
        return res

    @threaded_cached_property
    def client(self):
        return oauthlib.oauth2.LegacyApplicationClient(client_id=self.client_id)

    @property
    def scope(self):
        return [&#34;https://outlook.office365.com/EWS.AccessAsUser.All&#34;]


class OAuth2AuthorizationCodeCredentials(BaseOAuth2Credentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 authentication using the authorization code grant type. This can be used in one of
    several ways:
    * Given an authorization code, client ID, and client secret, fetch a token ourselves and refresh it as needed if
      supplied with a refresh token.
    * Given an existing access token, client ID, and client secret, use the access token until it expires and then
      refresh it as needed.
    * Given only an existing access token, use it until it expires. This can be used to let the calling application
      refresh tokens itself by subclassing and implementing refresh().

    Unlike the base (client credentials) grant, authorization code credentials don&#39;t require a Microsoft tenant ID
    because each access token (and the authorization code used to get the access token) is restricted to a single
    tenant.
    &#34;&#34;&#34;

    def __init__(self, authorization_code=None, **kwargs):
        &#34;&#34;&#34;

        :param authorization_code: Code obtained when authorizing the application to access an account. In combination
          with client_id and client_secret, will be used to obtain an access token.
        &#34;&#34;&#34;
        for attr in (&#34;client_id&#34;, &#34;client_secret&#34;):
            # Allow omitting these kwargs
            kwargs[attr] = kwargs.pop(attr, None)
        super().__init__(**kwargs)
        self.authorization_code = authorization_code

    @property
    def scope(self):
        res = super().scope
        res.append(&#34;offline_access&#34;)
        return res

    def token_params(self):
        res = super().token_params()
        res[&#34;code&#34;] = self.authorization_code  # Auth code may be None
        self.authorization_code = None  # We can only use the code once
        return res

    @threaded_cached_property
    def client(self):
        return oauthlib.oauth2.WebApplicationClient(client_id=self.client_id)

    def __repr__(self):
        return self.__class__.__name__ + repr(
            (self.client_id, &#34;[client_secret]&#34;, &#34;[authorization_code]&#34;, &#34;[access_token]&#34;)
        )

    def __str__(self):
        client_id = self.client_id
        credential = (
            &#34;[access_token]&#34;
            if self.access_token is not None
            else (&#34;[authorization_code]&#34; if self.authorization_code is not None else None)
        )
        description = &#34; &#34;.join(filter(None, [client_id, credential]))
        return description or &#34;[underspecified credentials]&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exchangelib.credentials.BaseCredentials"><code class="flex name class">
<span>class <span class="ident">BaseCredentials</span></span>
</code></dt>
<dd>
<div class="desc"><p>Base class for credential storage.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseCredentials(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Base class for credential storage.&#34;&#34;&#34;

    def __eq__(self, other):
        return all(getattr(self, k) == getattr(other, k) for k in self.__dict__)

    def __hash__(self):
        return hash(tuple((getattr(self, k) for k in self.__dict__)))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.BaseOAuth2Credentials" href="#exchangelib.credentials.BaseOAuth2Credentials">BaseOAuth2Credentials</a></li>
<li><a title="exchangelib.credentials.Credentials" href="#exchangelib.credentials.Credentials">Credentials</a></li>
</ul>
</dd>
<dt id="exchangelib.credentials.BaseOAuth2Credentials"><code class="flex name class">
<span>class <span class="ident">BaseOAuth2Credentials</span></span>
<span>(</span><span>client_id, client_secret, tenant_id=None, identity=None, access_token=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all classes that implement OAuth 2.0 authentication</p>
<p>:param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
:param client_secret: Secret associated with the OAuth application
:param tenant_id: Microsoft tenant ID of the account to access
:param identity: An Identity object representing the account that these credentials are connected to.
:param access_token: Previously-obtained access token, as a dict or an oauthlib.oauth2.OAuth2Token</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseOAuth2Credentials(BaseCredentials):
    &#34;&#34;&#34;Base class for all classes that implement OAuth 2.0 authentication&#34;&#34;&#34;

    def __init__(self, client_id, client_secret, tenant_id=None, identity=None, access_token=None):
        &#34;&#34;&#34;

        :param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
        :param client_secret: Secret associated with the OAuth application
        :param tenant_id: Microsoft tenant ID of the account to access
        :param identity: An Identity object representing the account that these credentials are connected to.
        :param access_token: Previously-obtained access token, as a dict or an oauthlib.oauth2.OAuth2Token
        &#34;&#34;&#34;
        super().__init__()
        self.client_id = client_id
        self.client_secret = client_secret
        self.tenant_id = tenant_id
        self.identity = identity
        self.access_token = access_token

        self._lock = RLock()

    @property
    def lock(self):
        return self._lock

    @property
    def access_token(self):
        return self._access_token

    @access_token.setter
    def access_token(self, access_token):
        if access_token is not None and not isinstance(access_token, dict):
            raise InvalidTypeError(&#34;access_token&#34;, access_token, oauthlib.oauth2.OAuth2Token)
        self._access_token = access_token

    def refresh(self, session):
        &#34;&#34;&#34;Obtain a new set of valid credentials. This is intended to support OAuth token refreshing, which can
        happen in long-running applications or those that cache access tokens and so might start with a token close to
        expiration.

        :param session: requests session asking for refreshed credentials
        :return:
        &#34;&#34;&#34;
        # Creating a new session gets a new access token, so there&#39;s no work here to refresh the credentials.

    def on_token_auto_refreshed(self, access_token):
        &#34;&#34;&#34;Set the access_token. Called after the access token is refreshed (requests-oauthlib can automatically
        refresh tokens if given an OAuth client ID and secret, so this is how our copy of the token stays up-to-date).
        Applications that cache access tokens can override this to store the new token - just remember to call the
        super() method.

        :param access_token: New token obtained by refreshing
        &#34;&#34;&#34;
        # Ensure we don&#39;t update the object in the middle of a new session being created, which could cause a race.
        with self.lock:
            log.debug(&#34;%s auth token for %s&#34;, &#34;Refreshing&#34; if self.access_token else &#34;Setting&#34;, self.client_id)
            self.access_token = access_token

    def sig(self):
        # Like hash(self), but pulls in the access token. Protocol.refresh_credentials() uses this to find out
        # if the access_token needs to be refreshed.
        res = []
        for k in self.__dict__:
            if k in (&#34;_lock&#34;, &#34;identity&#34;):
                continue
            if k == &#34;_access_token&#34;:
                res.append(self.access_token[&#34;access_token&#34;] if self.access_token else None)
                continue
            res.append(getattr(self, k))
        return hash(tuple(res))

    @property
    def token_url(self):
        &#34;&#34;&#34;The URL to request tokens from&#34;&#34;&#34;
        # We may not know (or need) the Microsoft tenant ID. If not, use common/ to let Microsoft select the appropriate
        # tenant for the provided authorization code or refresh token.
        return f&#34;https://login.microsoftonline.com/{self.tenant_id or &#39;common&#39;}/oauth2/v2.0/token&#34;  # nosec

    @property
    def scope(self):
        &#34;&#34;&#34;The scope we ask for the token to have&#34;&#34;&#34;
        return [&#34;https://outlook.office365.com/.default&#34;]

    def session_params(self):
        &#34;&#34;&#34;Extra parameters to use when creating the session&#34;&#34;&#34;
        res = {&#34;token&#34;: self.access_token}  # Token may be None
        if self.client_id and self.client_secret:
            # If we&#39;re given a client ID and secret, we have enough to refresh access tokens ourselves. In other
            # cases the session will raise TokenExpiredError, and we&#39;ll need to ask the calling application to
            # refresh the token (that covers cases where the caller doesn&#39;t have access to the client secret but
            # is working with a service that can provide it refreshed tokens on a limited basis).
            res.update(
                {
                    &#34;auto_refresh_kwargs&#34;: {
                        &#34;client_id&#34;: self.client_id,
                        &#34;client_secret&#34;: self.client_secret,
                    },
                    &#34;auto_refresh_url&#34;: self.token_url,
                    &#34;token_updater&#34;: self.on_token_auto_refreshed,
                }
            )
        return res

    def token_params(self):
        &#34;&#34;&#34;Extra parameters when requesting the token&#34;&#34;&#34;
        return {&#34;include_client_id&#34;: True}

    @threaded_cached_property
    @abc.abstractmethod
    def client(self):
        &#34;&#34;&#34;The client implementation to use for this credential class&#34;&#34;&#34;

    def __eq__(self, other):
        return all(getattr(self, k) == getattr(other, k) for k in self.__dict__ if k != &#34;_lock&#34;)

    def __hash__(self):
        # &#39;access_token&#39; may be refreshed once in a while. This should not affect the hash signature.
        # &#39;identity&#39; is just informational and should also not affect the hash signature.
        return hash(tuple(getattr(self, k) for k in self.__dict__ if k not in (&#34;_lock&#34;, &#34;identity&#34;, &#34;_access_token&#34;)))

    def __str__(self):
        return self.client_id

    def __repr__(self):
        return self.__class__.__name__ + repr((self.client_id, &#34;********&#34;))

    def __getstate__(self):
        # The lock cannot be pickled
        state = self.__dict__.copy()
        del state[&#34;_lock&#34;]
        return state

    def __setstate__(self, state):
        # Restore the lock
        self.__dict__.update(state)
        self._lock = RLock()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.BaseCredentials" href="#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.OAuth2AuthorizationCodeCredentials" href="#exchangelib.credentials.OAuth2AuthorizationCodeCredentials">OAuth2AuthorizationCodeCredentials</a></li>
<li><a title="exchangelib.credentials.OAuth2Credentials" href="#exchangelib.credentials.OAuth2Credentials">OAuth2Credentials</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.credentials.BaseOAuth2Credentials.access_token"><code class="name">var <span class="ident">access_token</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def access_token(self):
    return self._access_token</code></pre>
</details>
</dd>
<dt id="exchangelib.credentials.BaseOAuth2Credentials.client"><code class="name">var <span class="ident">client</span></code></dt>
<dd>
<div class="desc"><p>The client implementation to use for this credential class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.credentials.BaseOAuth2Credentials.lock"><code class="name">var <span class="ident">lock</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def lock(self):
    return self._lock</code></pre>
</details>
</dd>
<dt id="exchangelib.credentials.BaseOAuth2Credentials.scope"><code class="name">var <span class="ident">scope</span></code></dt>
<dd>
<div class="desc"><p>The scope we ask for the token to have</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def scope(self):
    &#34;&#34;&#34;The scope we ask for the token to have&#34;&#34;&#34;
    return [&#34;https://outlook.office365.com/.default&#34;]</code></pre>
</details>
</dd>
<dt id="exchangelib.credentials.BaseOAuth2Credentials.token_url"><code class="name">var <span class="ident">token_url</span></code></dt>
<dd>
<div class="desc"><p>The URL to request tokens from</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def token_url(self):
    &#34;&#34;&#34;The URL to request tokens from&#34;&#34;&#34;
    # We may not know (or need) the Microsoft tenant ID. If not, use common/ to let Microsoft select the appropriate
    # tenant for the provided authorization code or refresh token.
    return f&#34;https://login.microsoftonline.com/{self.tenant_id or &#39;common&#39;}/oauth2/v2.0/token&#34;  # nosec</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.credentials.BaseOAuth2Credentials.on_token_auto_refreshed"><code class="name flex">
<span>def <span class="ident">on_token_auto_refreshed</span></span>(<span>self, access_token)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the access_token. Called after the access token is refreshed (requests-oauthlib can automatically
refresh tokens if given an OAuth client ID and secret, so this is how our copy of the token stays up-to-date).
Applications that cache access tokens can override this to store the new token - just remember to call the
super() method.</p>
<p>:param access_token: New token obtained by refreshing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_token_auto_refreshed(self, access_token):
    &#34;&#34;&#34;Set the access_token. Called after the access token is refreshed (requests-oauthlib can automatically
    refresh tokens if given an OAuth client ID and secret, so this is how our copy of the token stays up-to-date).
    Applications that cache access tokens can override this to store the new token - just remember to call the
    super() method.

    :param access_token: New token obtained by refreshing
    &#34;&#34;&#34;
    # Ensure we don&#39;t update the object in the middle of a new session being created, which could cause a race.
    with self.lock:
        log.debug(&#34;%s auth token for %s&#34;, &#34;Refreshing&#34; if self.access_token else &#34;Setting&#34;, self.client_id)
        self.access_token = access_token</code></pre>
</details>
</dd>
<dt id="exchangelib.credentials.BaseOAuth2Credentials.refresh"><code class="name flex">
<span>def <span class="ident">refresh</span></span>(<span>self, session)</span>
</code></dt>
<dd>
<div class="desc"><p>Obtain a new set of valid credentials. This is intended to support OAuth token refreshing, which can
happen in long-running applications or those that cache access tokens and so might start with a token close to
expiration.</p>
<p>:param session: requests session asking for refreshed credentials
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh(self, session):
    &#34;&#34;&#34;Obtain a new set of valid credentials. This is intended to support OAuth token refreshing, which can
    happen in long-running applications or those that cache access tokens and so might start with a token close to
    expiration.

    :param session: requests session asking for refreshed credentials
    :return:
    &#34;&#34;&#34;
    # Creating a new session gets a new access token, so there&#39;s no work here to refresh the credentials.</code></pre>
</details>
</dd>
<dt id="exchangelib.credentials.BaseOAuth2Credentials.session_params"><code class="name flex">
<span>def <span class="ident">session_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extra parameters to use when creating the session</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def session_params(self):
    &#34;&#34;&#34;Extra parameters to use when creating the session&#34;&#34;&#34;
    res = {&#34;token&#34;: self.access_token}  # Token may be None
    if self.client_id and self.client_secret:
        # If we&#39;re given a client ID and secret, we have enough to refresh access tokens ourselves. In other
        # cases the session will raise TokenExpiredError, and we&#39;ll need to ask the calling application to
        # refresh the token (that covers cases where the caller doesn&#39;t have access to the client secret but
        # is working with a service that can provide it refreshed tokens on a limited basis).
        res.update(
            {
                &#34;auto_refresh_kwargs&#34;: {
                    &#34;client_id&#34;: self.client_id,
                    &#34;client_secret&#34;: self.client_secret,
                },
                &#34;auto_refresh_url&#34;: self.token_url,
                &#34;token_updater&#34;: self.on_token_auto_refreshed,
            }
        )
    return res</code></pre>
</details>
</dd>
<dt id="exchangelib.credentials.BaseOAuth2Credentials.sig"><code class="name flex">
<span>def <span class="ident">sig</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sig(self):
    # Like hash(self), but pulls in the access token. Protocol.refresh_credentials() uses this to find out
    # if the access_token needs to be refreshed.
    res = []
    for k in self.__dict__:
        if k in (&#34;_lock&#34;, &#34;identity&#34;):
            continue
        if k == &#34;_access_token&#34;:
            res.append(self.access_token[&#34;access_token&#34;] if self.access_token else None)
            continue
        res.append(getattr(self, k))
    return hash(tuple(res))</code></pre>
</details>
</dd>
<dt id="exchangelib.credentials.BaseOAuth2Credentials.token_params"><code class="name flex">
<span>def <span class="ident">token_params</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extra parameters when requesting the token</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def token_params(self):
    &#34;&#34;&#34;Extra parameters when requesting the token&#34;&#34;&#34;
    return {&#34;include_client_id&#34;: True}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.credentials.Credentials"><code class="flex name class">
<span>class <span class="ident">Credentials</span></span>
<span>(</span><span>username, password)</span>
</code></dt>
<dd>
<div class="desc"><p>Keeps login info the way Exchange likes it.</p>
<p>Usernames for authentication are of one of these forms:
* PrimarySMTPAddress
* WINDOMAIN\username
* User Principal Name (UPN)
password: Clear-text password</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Credentials(BaseCredentials):
    r&#34;&#34;&#34;Keeps login info the way Exchange likes it.

    Usernames for authentication are of one of these forms:
    * PrimarySMTPAddress
    * WINDOMAIN\username
    * User Principal Name (UPN)
      password: Clear-text password
    &#34;&#34;&#34;

    EMAIL = &#34;email&#34;
    DOMAIN = &#34;domain&#34;
    UPN = &#34;upn&#34;

    def __init__(self, username, password):
        super().__init__()
        if username.count(&#34;@&#34;) == 1:
            self.type = self.EMAIL
        elif username.count(&#34;\\&#34;) == 1:
            self.type = self.DOMAIN
        else:
            self.type = self.UPN
        self.username = username
        self.password = password

    def __repr__(self):
        return self.__class__.__name__ + repr((self.username, &#34;********&#34;))

    def __str__(self):
        return self.username</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.BaseCredentials" href="#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.credentials.Credentials.DOMAIN"><code class="name">var <span class="ident">DOMAIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.credentials.Credentials.EMAIL"><code class="name">var <span class="ident">EMAIL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.credentials.Credentials.UPN"><code class="name">var <span class="ident">UPN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="exchangelib.credentials.OAuth2AuthorizationCodeCredentials"><code class="flex name class">
<span>class <span class="ident">OAuth2AuthorizationCodeCredentials</span></span>
<span>(</span><span>authorization_code=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Login info for OAuth 2.0 authentication using the authorization code grant type. This can be used in one of
several ways:
* Given an authorization code, client ID, and client secret, fetch a token ourselves and refresh it as needed if
supplied with a refresh token.
* Given an existing access token, client ID, and client secret, use the access token until it expires and then
refresh it as needed.
* Given only an existing access token, use it until it expires. This can be used to let the calling application
refresh tokens itself by subclassing and implementing refresh().</p>
<p>Unlike the base (client credentials) grant, authorization code credentials don't require a Microsoft tenant ID
because each access token (and the authorization code used to get the access token) is restricted to a single
tenant.</p>
<p>:param authorization_code: Code obtained when authorizing the application to access an account. In combination
with client_id and client_secret, will be used to obtain an access token.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OAuth2AuthorizationCodeCredentials(BaseOAuth2Credentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 authentication using the authorization code grant type. This can be used in one of
    several ways:
    * Given an authorization code, client ID, and client secret, fetch a token ourselves and refresh it as needed if
      supplied with a refresh token.
    * Given an existing access token, client ID, and client secret, use the access token until it expires and then
      refresh it as needed.
    * Given only an existing access token, use it until it expires. This can be used to let the calling application
      refresh tokens itself by subclassing and implementing refresh().

    Unlike the base (client credentials) grant, authorization code credentials don&#39;t require a Microsoft tenant ID
    because each access token (and the authorization code used to get the access token) is restricted to a single
    tenant.
    &#34;&#34;&#34;

    def __init__(self, authorization_code=None, **kwargs):
        &#34;&#34;&#34;

        :param authorization_code: Code obtained when authorizing the application to access an account. In combination
          with client_id and client_secret, will be used to obtain an access token.
        &#34;&#34;&#34;
        for attr in (&#34;client_id&#34;, &#34;client_secret&#34;):
            # Allow omitting these kwargs
            kwargs[attr] = kwargs.pop(attr, None)
        super().__init__(**kwargs)
        self.authorization_code = authorization_code

    @property
    def scope(self):
        res = super().scope
        res.append(&#34;offline_access&#34;)
        return res

    def token_params(self):
        res = super().token_params()
        res[&#34;code&#34;] = self.authorization_code  # Auth code may be None
        self.authorization_code = None  # We can only use the code once
        return res

    @threaded_cached_property
    def client(self):
        return oauthlib.oauth2.WebApplicationClient(client_id=self.client_id)

    def __repr__(self):
        return self.__class__.__name__ + repr(
            (self.client_id, &#34;[client_secret]&#34;, &#34;[authorization_code]&#34;, &#34;[access_token]&#34;)
        )

    def __str__(self):
        client_id = self.client_id
        credential = (
            &#34;[access_token]&#34;
            if self.access_token is not None
            else (&#34;[authorization_code]&#34; if self.authorization_code is not None else None)
        )
        description = &#34; &#34;.join(filter(None, [client_id, credential]))
        return description or &#34;[underspecified credentials]&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.BaseOAuth2Credentials" href="#exchangelib.credentials.BaseOAuth2Credentials">BaseOAuth2Credentials</a></li>
<li><a title="exchangelib.credentials.BaseCredentials" href="#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.credentials.BaseOAuth2Credentials" href="#exchangelib.credentials.BaseOAuth2Credentials">BaseOAuth2Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.client" href="#exchangelib.credentials.BaseOAuth2Credentials.client">client</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.on_token_auto_refreshed" href="#exchangelib.credentials.BaseOAuth2Credentials.on_token_auto_refreshed">on_token_auto_refreshed</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.refresh" href="#exchangelib.credentials.BaseOAuth2Credentials.refresh">refresh</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.scope" href="#exchangelib.credentials.BaseOAuth2Credentials.scope">scope</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.session_params" href="#exchangelib.credentials.BaseOAuth2Credentials.session_params">session_params</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.token_params" href="#exchangelib.credentials.BaseOAuth2Credentials.token_params">token_params</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.token_url" href="#exchangelib.credentials.BaseOAuth2Credentials.token_url">token_url</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.credentials.OAuth2Credentials"><code class="flex name class">
<span>class <span class="ident">OAuth2Credentials</span></span>
<span>(</span><span>client_id, client_secret, tenant_id=None, identity=None, access_token=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Login info for OAuth 2.0 client credentials authentication, as well as a base for other OAuth 2.0 grant types.</p>
<p>This is primarily useful for in-house applications accessing data from a single Microsoft account. For applications
that will access multiple tenants' data, the client credentials flow does not give the application enough
information to restrict end users' access to the appropriate account. Use OAuth2AuthorizationCodeCredentials and
the associated auth code grant type for multi-tenant applications.</p>
<p>:param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
:param client_secret: Secret associated with the OAuth application
:param tenant_id: Microsoft tenant ID of the account to access
:param identity: An Identity object representing the account that these credentials are connected to.
:param access_token: Previously-obtained access token, as a dict or an oauthlib.oauth2.OAuth2Token</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OAuth2Credentials(BaseOAuth2Credentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 client credentials authentication, as well as a base for other OAuth 2.0 grant types.

    This is primarily useful for in-house applications accessing data from a single Microsoft account. For applications
    that will access multiple tenants&#39; data, the client credentials flow does not give the application enough
    information to restrict end users&#39; access to the appropriate account. Use OAuth2AuthorizationCodeCredentials and
    the associated auth code grant type for multi-tenant applications.
    &#34;&#34;&#34;

    @threaded_cached_property
    def client(self):
        return oauthlib.oauth2.BackendApplicationClient(client_id=self.client_id)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.BaseOAuth2Credentials" href="#exchangelib.credentials.BaseOAuth2Credentials">BaseOAuth2Credentials</a></li>
<li><a title="exchangelib.credentials.BaseCredentials" href="#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.OAuth2LegacyCredentials" href="#exchangelib.credentials.OAuth2LegacyCredentials">OAuth2LegacyCredentials</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.credentials.BaseOAuth2Credentials" href="#exchangelib.credentials.BaseOAuth2Credentials">BaseOAuth2Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.client" href="#exchangelib.credentials.BaseOAuth2Credentials.client">client</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.on_token_auto_refreshed" href="#exchangelib.credentials.BaseOAuth2Credentials.on_token_auto_refreshed">on_token_auto_refreshed</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.refresh" href="#exchangelib.credentials.BaseOAuth2Credentials.refresh">refresh</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.scope" href="#exchangelib.credentials.BaseOAuth2Credentials.scope">scope</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.session_params" href="#exchangelib.credentials.BaseOAuth2Credentials.session_params">session_params</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.token_params" href="#exchangelib.credentials.BaseOAuth2Credentials.token_params">token_params</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.token_url" href="#exchangelib.credentials.BaseOAuth2Credentials.token_url">token_url</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.credentials.OAuth2LegacyCredentials"><code class="flex name class">
<span>class <span class="ident">OAuth2LegacyCredentials</span></span>
<span>(</span><span>username, password, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Login info for OAuth 2.0 authentication using delegated permissions and application permissions.</p>
<p>This requires the app to acquire username and password from the user and pass that when requesting authentication
tokens for the given user. This allows the app to act as the signed-in user.</p>
<p>:param username: The username of the user to act as
:param password: The password of the user to act as</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OAuth2LegacyCredentials(OAuth2Credentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 authentication using delegated permissions and application permissions.

    This requires the app to acquire username and password from the user and pass that when requesting authentication
    tokens for the given user. This allows the app to act as the signed-in user.
    &#34;&#34;&#34;

    def __init__(self, username, password, **kwargs):
        &#34;&#34;&#34;
        :param username: The username of the user to act as
        :param password: The password of the user to act as
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.username = username
        self.password = password

    def token_params(self):
        res = super().token_params()
        res.update(
            {
                &#34;username&#34;: self.username,
                &#34;password&#34;: self.password,
            }
        )
        return res

    @threaded_cached_property
    def client(self):
        return oauthlib.oauth2.LegacyApplicationClient(client_id=self.client_id)

    @property
    def scope(self):
        return [&#34;https://outlook.office365.com/EWS.AccessAsUser.All&#34;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.OAuth2Credentials" href="#exchangelib.credentials.OAuth2Credentials">OAuth2Credentials</a></li>
<li><a title="exchangelib.credentials.BaseOAuth2Credentials" href="#exchangelib.credentials.BaseOAuth2Credentials">BaseOAuth2Credentials</a></li>
<li><a title="exchangelib.credentials.BaseCredentials" href="#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.credentials.OAuth2Credentials" href="#exchangelib.credentials.OAuth2Credentials">OAuth2Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.OAuth2Credentials.token_params" href="#exchangelib.credentials.BaseOAuth2Credentials.token_params">token_params</a></code></li>
</ul>
</li>
<li><code><b><a title="exchangelib.credentials.OAuth2Credentials" href="#exchangelib.credentials.OAuth2Credentials">OAuth2Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.OAuth2Credentials.on_token_auto_refreshed" href="#exchangelib.credentials.BaseOAuth2Credentials.on_token_auto_refreshed">on_token_auto_refreshed</a></code></li>
<li><code><a title="exchangelib.credentials.OAuth2Credentials.refresh" href="#exchangelib.credentials.BaseOAuth2Credentials.refresh">refresh</a></code></li>
<li><code><a title="exchangelib.credentials.OAuth2Credentials.scope" href="#exchangelib.credentials.BaseOAuth2Credentials.scope">scope</a></code></li>
<li><code><a title="exchangelib.credentials.OAuth2Credentials.session_params" href="#exchangelib.credentials.BaseOAuth2Credentials.session_params">session_params</a></code></li>
<li><code><a title="exchangelib.credentials.OAuth2Credentials.token_url" href="#exchangelib.credentials.BaseOAuth2Credentials.token_url">token_url</a></code></li>
</ul>
</li>
<li><code><b><a title="exchangelib.credentials.BaseOAuth2Credentials" href="#exchangelib.credentials.BaseOAuth2Credentials">BaseOAuth2Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.client" href="#exchangelib.credentials.BaseOAuth2Credentials.client">client</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="exchangelib" href="index.html">exchangelib</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exchangelib.credentials.BaseCredentials" href="#exchangelib.credentials.BaseCredentials">BaseCredentials</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.credentials.BaseOAuth2Credentials" href="#exchangelib.credentials.BaseOAuth2Credentials">BaseOAuth2Credentials</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.access_token" href="#exchangelib.credentials.BaseOAuth2Credentials.access_token">access_token</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.client" href="#exchangelib.credentials.BaseOAuth2Credentials.client">client</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.lock" href="#exchangelib.credentials.BaseOAuth2Credentials.lock">lock</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.on_token_auto_refreshed" href="#exchangelib.credentials.BaseOAuth2Credentials.on_token_auto_refreshed">on_token_auto_refreshed</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.refresh" href="#exchangelib.credentials.BaseOAuth2Credentials.refresh">refresh</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.scope" href="#exchangelib.credentials.BaseOAuth2Credentials.scope">scope</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.session_params" href="#exchangelib.credentials.BaseOAuth2Credentials.session_params">session_params</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.sig" href="#exchangelib.credentials.BaseOAuth2Credentials.sig">sig</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.token_params" href="#exchangelib.credentials.BaseOAuth2Credentials.token_params">token_params</a></code></li>
<li><code><a title="exchangelib.credentials.BaseOAuth2Credentials.token_url" href="#exchangelib.credentials.BaseOAuth2Credentials.token_url">token_url</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.credentials.Credentials" href="#exchangelib.credentials.Credentials">Credentials</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.credentials.Credentials.DOMAIN" href="#exchangelib.credentials.Credentials.DOMAIN">DOMAIN</a></code></li>
<li><code><a title="exchangelib.credentials.Credentials.EMAIL" href="#exchangelib.credentials.Credentials.EMAIL">EMAIL</a></code></li>
<li><code><a title="exchangelib.credentials.Credentials.UPN" href="#exchangelib.credentials.Credentials.UPN">UPN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.credentials.OAuth2AuthorizationCodeCredentials" href="#exchangelib.credentials.OAuth2AuthorizationCodeCredentials">OAuth2AuthorizationCodeCredentials</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.credentials.OAuth2Credentials" href="#exchangelib.credentials.OAuth2Credentials">OAuth2Credentials</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.credentials.OAuth2LegacyCredentials" href="#exchangelib.credentials.OAuth2LegacyCredentials">OAuth2LegacyCredentials</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
