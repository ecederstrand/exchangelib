<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>exchangelib API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>exchangelib</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys

from .account import Account, Identity
from .attachments import FileAttachment, ItemAttachment
from .autodiscover import discover
from .configuration import Configuration
from .credentials import DELEGATE, IMPERSONATION, Credentials, OAuth2Credentials, \
    OAuth2AuthorizationCodeCredentials
from .ewsdatetime import EWSDate, EWSDateTime, EWSTimeZone, UTC, UTC_NOW
from .extended_properties import ExtendedProperty
from .folders import Folder, RootOfHierarchy, FolderCollection, SHALLOW, DEEP
from .items import AcceptItem, TentativelyAcceptItem, DeclineItem, CalendarItem, CancelCalendarItem, Contact, \
    DistributionList, Message, PostItem, Task, ForwardItem, ReplyToItem, ReplyAllToItem
from .properties import Body, HTMLBody, ItemId, Mailbox, Attendee, Room, RoomList, UID, DLMailbox
from .protocol import FaultTolerance, FailFast, BaseProtocol, NoVerifyHTTPAdapter, TLSClientAuth
from .restriction import Q
from .settings import OofSettings
from .transport import BASIC, DIGEST, NTLM, GSSAPI, SSPI, OAUTH2, CBA
from .version import Build, Version

__version__ = &#39;4.6.0&#39;

__all__ = [
    &#39;__version__&#39;,
    &#39;Account&#39;, &#39;Identity&#39;,
    &#39;FileAttachment&#39;, &#39;ItemAttachment&#39;,
    &#39;discover&#39;,
    &#39;Configuration&#39;,
    &#39;DELEGATE&#39;, &#39;IMPERSONATION&#39;, &#39;Credentials&#39;, &#39;OAuth2AuthorizationCodeCredentials&#39;, &#39;OAuth2Credentials&#39;,
    &#39;EWSDate&#39;, &#39;EWSDateTime&#39;, &#39;EWSTimeZone&#39;, &#39;UTC&#39;, &#39;UTC_NOW&#39;,
    &#39;ExtendedProperty&#39;,
    &#39;Folder&#39;, &#39;RootOfHierarchy&#39;, &#39;FolderCollection&#39;, &#39;SHALLOW&#39;, &#39;DEEP&#39;,
    &#39;AcceptItem&#39;, &#39;TentativelyAcceptItem&#39;, &#39;DeclineItem&#39;, &#39;CalendarItem&#39;, &#39;CancelCalendarItem&#39;, &#39;Contact&#39;,
    &#39;DistributionList&#39;, &#39;Message&#39;, &#39;PostItem&#39;, &#39;Task&#39;, &#39;ForwardItem&#39;, &#39;ReplyToItem&#39;, &#39;ReplyAllToItem&#39;,
    &#39;ItemId&#39;, &#39;Mailbox&#39;, &#39;DLMailbox&#39;, &#39;Attendee&#39;, &#39;Room&#39;, &#39;RoomList&#39;, &#39;Body&#39;, &#39;HTMLBody&#39;, &#39;UID&#39;,
    &#39;FailFast&#39;, &#39;FaultTolerance&#39;, &#39;BaseProtocol&#39;, &#39;NoVerifyHTTPAdapter&#39;, &#39;TLSClientAuth&#39;,
    &#39;OofSettings&#39;,
    &#39;Q&#39;,
    &#39;BASIC&#39;, &#39;DIGEST&#39;, &#39;NTLM&#39;, &#39;GSSAPI&#39;, &#39;SSPI&#39;, &#39;OAUTH2&#39;, &#39;CBA&#39;,
    &#39;Build&#39;, &#39;Version&#39;,
]

# Set a default user agent, e.g. &#34;exchangelib/3.1.1 (python-requests/2.22.0)&#34;
import requests.utils
BaseProtocol.USERAGENT = &#34;%s/%s (%s)&#34; % (__name__, __version__, requests.utils.default_user_agent())

# Support fromisoformat() in Python &lt; 3.7
if sys.version_info[:2] &lt; (3, 7):
    from backports.datetime_fromisoformat import MonkeyPatch
    MonkeyPatch.patch_fromisoformat()


def close_connections():
    from .autodiscover import close_connections as close_autodiscover_connections
    from .protocol import close_connections as close_protocol_connections
    close_autodiscover_connections()
    close_protocol_connections()</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="exchangelib.account" href="account.html">exchangelib.account</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.attachments" href="attachments.html">exchangelib.attachments</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.autodiscover" href="autodiscover/index.html">exchangelib.autodiscover</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.configuration" href="configuration.html">exchangelib.configuration</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.credentials" href="credentials.html">exchangelib.credentials</a></code></dt>
<dd>
<div class="desc"><p>Implements an Exchange user object and access types. Exchange provides two different ways of granting access for a
login to a specific account â€¦</p></div>
</dd>
<dt><code class="name"><a title="exchangelib.errors" href="errors.html">exchangelib.errors</a></code></dt>
<dd>
<div class="desc"><p>Stores errors specific to this package, and mirrors all the possible errors that EWS can return.</p></div>
</dd>
<dt><code class="name"><a title="exchangelib.ewsdatetime" href="ewsdatetime.html">exchangelib.ewsdatetime</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.extended_properties" href="extended_properties.html">exchangelib.extended_properties</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.fields" href="fields.html">exchangelib.fields</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.folders" href="folders/index.html">exchangelib.folders</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.indexed_properties" href="indexed_properties.html">exchangelib.indexed_properties</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.items" href="items/index.html">exchangelib.items</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.properties" href="properties.html">exchangelib.properties</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.protocol" href="protocol.html">exchangelib.protocol</a></code></dt>
<dd>
<div class="desc"><p>A protocol is an endpoint for EWS service connections. It contains all necessary information to make HTTPS connections â€¦</p></div>
</dd>
<dt><code class="name"><a title="exchangelib.queryset" href="queryset.html">exchangelib.queryset</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.recurrence" href="recurrence.html">exchangelib.recurrence</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.restriction" href="restriction.html">exchangelib.restriction</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.services" href="services/index.html">exchangelib.services</a></code></dt>
<dd>
<div class="desc"><p>Implement a selection of EWS services (operations) â€¦</p></div>
</dd>
<dt><code class="name"><a title="exchangelib.settings" href="settings.html">exchangelib.settings</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.transport" href="transport.html">exchangelib.transport</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.util" href="util.html">exchangelib.util</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.version" href="version.html">exchangelib.version</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="exchangelib.winzone" href="winzone.html">exchangelib.winzone</a></code></dt>
<dd>
<div class="desc"><p>A dict to translate from IANA location name to Windows timezone name. Translations taken from
â€¦</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="exchangelib.UTC_NOW"><code class="name flex">
<span>def <span class="ident">UTC_NOW</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">UTC_NOW = lambda: EWSDateTime.now(tz=UTC)  # noqa: E731</code></pre>
</details>
</dd>
<dt id="exchangelib.discover"><code class="name flex">
<span>def <span class="ident">discover</span></span>(<span>email, credentials=None, auth_type=None, retry_policy=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def discover(email, credentials=None, auth_type=None, retry_policy=None):
    return Autodiscovery(
        email=email, credentials=credentials, auth_type=auth_type, retry_policy=retry_policy
    ).discover()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exchangelib.AcceptItem"><code class="flex name class">
<span>class <span class="ident">AcceptItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/acceptitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/acceptitem</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AcceptItem(BaseMeetingReplyItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/acceptitem&#34;&#34;&#34;

    ELEMENT_NAME = &#39;AcceptItem&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem" href="items/calendar_item.html#exchangelib.items.calendar_item.BaseMeetingReplyItem">BaseMeetingReplyItem</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.AcceptItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem" href="items/calendar_item.html#exchangelib.items.calendar_item.BaseMeetingReplyItem">BaseMeetingReplyItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Account"><code class="flex name class">
<span>class <span class="ident">Account</span></span>
<span>(</span><span>primary_smtp_address, fullname=None, access_type=None, autodiscover=False, credentials=None, config=None, locale=None, default_timezone=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Models an Exchange server user account.</p>
<p>:param primary_smtp_address: The primary email address associated with the account on the Exchange server
:param fullname: The full name of the account. Optional. (Default value = None)
:param access_type: The access type granted to 'credentials' for this account. Valid options are 'delegate'
and 'impersonation'. 'delegate' is default if 'credentials' is set. Otherwise, 'impersonation' is default.
:param autodiscover: Whether to look up the EWS endpoint automatically using the autodiscover protocol.
(Default value = False)
:param credentials: A Credentials object containing valid credentials for this account. (Default value = None)
:param config: A Configuration object containing EWS endpoint information. Required if autodiscover is disabled
(Default value = None)
:param locale: The locale of the user, e.g. 'en_US'. Defaults to the locale of the host, if available.
:param default_timezone: EWS may return some datetime values without timezone information. In this case, we will
assume values to be in the provided timezone. Defaults to the timezone of the host.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Account:
    &#34;&#34;&#34;Models an Exchange server user account.&#34;&#34;&#34;

    def __init__(self, primary_smtp_address, fullname=None, access_type=None, autodiscover=False, credentials=None,
                 config=None, locale=None, default_timezone=None):
        &#34;&#34;&#34;

        :param primary_smtp_address: The primary email address associated with the account on the Exchange server
        :param fullname: The full name of the account. Optional. (Default value = None)
        :param access_type: The access type granted to &#39;credentials&#39; for this account. Valid options are &#39;delegate&#39;
            and &#39;impersonation&#39;. &#39;delegate&#39; is default if &#39;credentials&#39; is set. Otherwise, &#39;impersonation&#39; is default.
        :param autodiscover: Whether to look up the EWS endpoint automatically using the autodiscover protocol.
            (Default value = False)
        :param credentials: A Credentials object containing valid credentials for this account. (Default value = None)
        :param config: A Configuration object containing EWS endpoint information. Required if autodiscover is disabled
            (Default value = None)
        :param locale: The locale of the user, e.g. &#39;en_US&#39;. Defaults to the locale of the host, if available.
        :param default_timezone: EWS may return some datetime values without timezone information. In this case, we will
            assume values to be in the provided timezone. Defaults to the timezone of the host.
        :return:
        &#34;&#34;&#34;
        if &#39;@&#39; not in primary_smtp_address:
            raise ValueError(&#34;primary_smtp_address %r is not an email address&#34; % primary_smtp_address)
        self.fullname = fullname
        # Assume delegate access if individual credentials are provided. Else, assume service user with impersonation
        self.access_type = access_type or (DELEGATE if credentials else IMPERSONATION)
        if self.access_type not in ACCESS_TYPES:
            raise ValueError(&#34;&#39;access_type&#39; %r must be one of %s&#34; % (self.access_type, ACCESS_TYPES))
        try:
            self.locale = locale or getlocale()[0] or None  # get_locale() might not be able to determine the locale
        except ValueError as e:
            # getlocale() may throw ValueError if it fails to parse the system locale
            log.warning(&#39;Failed to get locale (%s)&#39;, e)
            self.locale = None
        if not isinstance(self.locale, (type(None), str)):
            raise ValueError(&#34;Expected &#39;locale&#39; to be a string, got %r&#34; % self.locale)
        if default_timezone:
            try:
                self.default_timezone = EWSTimeZone.from_timezone(default_timezone)
            except TypeError:
                raise ValueError(&#34;Expected &#39;default_timezone&#39; to be an EWSTimeZone, got %r&#34; % default_timezone)
        else:
            try:
                self.default_timezone = EWSTimeZone.localzone()
            except (ValueError, UnknownTimeZone) as e:
                # There is no translation from local timezone name to Windows timezone name, or e failed to find the
                # local timezone.
                log.warning(&#39;%s. Fallback to UTC&#39;, e.args[0])
                self.default_timezone = UTC
        if not isinstance(config, (Configuration, type(None))):
            raise ValueError(&#34;Expected &#39;config&#39; to be a Configuration, got %r&#34; % config)
        if autodiscover:
            if config:
                retry_policy, auth_type = config.retry_policy, config.auth_type
                if not credentials:
                    credentials = config.credentials
            else:
                retry_policy, auth_type = None, None
            self.ad_response, self.protocol = discover(
                email=primary_smtp_address, credentials=credentials, auth_type=auth_type, retry_policy=retry_policy
            )
            primary_smtp_address = self.ad_response.autodiscover_smtp_address
        else:
            if not config:
                raise AttributeError(&#39;non-autodiscover requires a config&#39;)
            self.ad_response = None
            self.protocol = Protocol(config=config)

        # Other ways of identifying the account can be added later
        self.identity = Identity(primary_smtp_address=primary_smtp_address)

        # We may need to override the default server version on a per-account basis because Microsoft may report one
        # server version up-front but delegate account requests to an older backend server.
        self.version = self.protocol.version
        log.debug(&#39;Added account: %s&#39;, self)

    @property
    def primary_smtp_address(self):
        return self.identity.primary_smtp_address

    @threaded_cached_property
    def admin_audit_logs(self):
        return self.root.get_default_folder(AdminAuditLogs)

    @threaded_cached_property
    def archive_deleted_items(self):
        return self.archive_root.get_default_folder(ArchiveDeletedItems)

    @threaded_cached_property
    def archive_inbox(self):
        return self.archive_root.get_default_folder(ArchiveInbox)

    @threaded_cached_property
    def archive_msg_folder_root(self):
        return self.archive_root.get_default_folder(ArchiveMsgFolderRoot)

    @threaded_cached_property
    def archive_recoverable_items_deletions(self):
        return self.archive_root.get_default_folder(ArchiveRecoverableItemsDeletions)

    @threaded_cached_property
    def archive_recoverable_items_purges(self):
        return self.archive_root.get_default_folder(ArchiveRecoverableItemsPurges)

    @threaded_cached_property
    def archive_recoverable_items_root(self):
        return self.archive_root.get_default_folder(ArchiveRecoverableItemsRoot)

    @threaded_cached_property
    def archive_recoverable_items_versions(self):
        return self.archive_root.get_default_folder(ArchiveRecoverableItemsVersions)

    @threaded_cached_property
    def archive_root(self):
        return ArchiveRoot.get_distinguished(account=self)

    @threaded_cached_property
    def calendar(self):
        # If the account contains a shared calendar from a different user, that calendar will be in the folder list.
        # Attempt not to return one of those. An account may not always have a calendar called &#34;Calendar&#34;, but a
        # Calendar folder with a localized name instead. Return that, if it&#39;s available, but always prefer any
        # distinguished folder returned by the server.
        return self.root.get_default_folder(Calendar)

    @threaded_cached_property
    def conflicts(self):
        return self.root.get_default_folder(Conflicts)

    @threaded_cached_property
    def contacts(self):
        return self.root.get_default_folder(Contacts)

    @threaded_cached_property
    def conversation_history(self):
        return self.root.get_default_folder(ConversationHistory)

    @threaded_cached_property
    def directory(self):
        return self.root.get_default_folder(Directory)

    @threaded_cached_property
    def drafts(self):
        return self.root.get_default_folder(Drafts)

    @threaded_cached_property
    def favorites(self):
        return self.root.get_default_folder(Favorites)

    @threaded_cached_property
    def im_contact_list(self):
        return self.root.get_default_folder(IMContactList)

    @threaded_cached_property
    def inbox(self):
        return self.root.get_default_folder(Inbox)

    @threaded_cached_property
    def journal(self):
        return self.root.get_default_folder(Journal)

    @threaded_cached_property
    def junk(self):
        return self.root.get_default_folder(JunkEmail)

    @threaded_cached_property
    def local_failures(self):
        return self.root.get_default_folder(LocalFailures)

    @threaded_cached_property
    def msg_folder_root(self):
        return self.root.get_default_folder(MsgFolderRoot)

    @threaded_cached_property
    def my_contacts(self):
        return self.root.get_default_folder(MyContacts)

    @threaded_cached_property
    def notes(self):
        return self.root.get_default_folder(Notes)

    @threaded_cached_property
    def outbox(self):
        return self.root.get_default_folder(Outbox)

    @threaded_cached_property
    def people_connect(self):
        return self.root.get_default_folder(PeopleConnect)

    @threaded_cached_property
    def public_folders_root(self):
        return PublicFoldersRoot.get_distinguished(account=self)

    @threaded_cached_property
    def quick_contacts(self):
        return self.root.get_default_folder(QuickContacts)

    @threaded_cached_property
    def recipient_cache(self):
        return self.root.get_default_folder(RecipientCache)

    @threaded_cached_property
    def recoverable_items_deletions(self):
        return self.root.get_default_folder(RecoverableItemsDeletions)

    @threaded_cached_property
    def recoverable_items_purges(self):
        return self.root.get_default_folder(RecoverableItemsPurges)

    @threaded_cached_property
    def recoverable_items_root(self):
        return self.root.get_default_folder(RecoverableItemsRoot)

    @threaded_cached_property
    def recoverable_items_versions(self):
        return self.root.get_default_folder(RecoverableItemsVersions)

    @threaded_cached_property
    def root(self):
        return Root.get_distinguished(account=self)

    @threaded_cached_property
    def search_folders(self):
        return self.root.get_default_folder(SearchFolders)

    @threaded_cached_property
    def sent(self):
        return self.root.get_default_folder(SentItems)

    @threaded_cached_property
    def server_failures(self):
        return self.root.get_default_folder(ServerFailures)

    @threaded_cached_property
    def sync_issues(self):
        return self.root.get_default_folder(SyncIssues)

    @threaded_cached_property
    def tasks(self):
        return self.root.get_default_folder(Tasks)

    @threaded_cached_property
    def todo_search(self):
        return self.root.get_default_folder(ToDoSearch)

    @threaded_cached_property
    def trash(self):
        return self.root.get_default_folder(DeletedItems)

    @threaded_cached_property
    def voice_mail(self):
        return self.root.get_default_folder(VoiceMail)

    @property
    def domain(self):
        return get_domain(self.primary_smtp_address)

    @property
    def oof_settings(self):
        # We don&#39;t want to cache this property because then we can&#39;t easily get updates. &#39;threaded_cached_property&#39;
        # supports the &#39;del self.oof_settings&#39; syntax to invalidate the cache, but does not support custom setter
        # methods. Having a non-cached service call here goes against the assumption that properties are cheap, but the
        # alternative is to create get_oof_settings() and set_oof_settings(), and that&#39;s just too Java-ish for my taste.
        return GetUserOofSettings(account=self).get(
            mailbox=Mailbox(email_address=self.primary_smtp_address),
        )

    @oof_settings.setter
    def oof_settings(self, value):
        SetUserOofSettings(account=self).get(
            oof_settings=value,
            mailbox=Mailbox(email_address=self.primary_smtp_address),
        )

    def _consume_item_service(self, service_cls, items, chunk_size, kwargs):
        if isinstance(items, QuerySet):
            # We just want an iterator over the results
            items = iter(items)
        is_empty, items = peek(items)
        if is_empty:
            # We accept generators, so it&#39;s not always convenient for caller to know up-front if &#39;ids&#39; is empty. Allow
            # empty &#39;ids&#39; and return early.
            return
        kwargs[&#39;items&#39;] = items
        yield from service_cls(account=self, chunk_size=chunk_size).call(**kwargs)

    def export(self, items, chunk_size=None):
        &#34;&#34;&#34;Return export strings of the given items.

        :param items: An iterable containing the Items we want to export
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: A list of strings, the exported representation of the object
        &#34;&#34;&#34;
        return list(
            self._consume_item_service(service_cls=ExportItems, items=items, chunk_size=chunk_size, kwargs={})
        )

    def upload(self, data, chunk_size=None):
        &#34;&#34;&#34;Upload objects retrieved from an export to the given folders.

        :param data: An iterable of tuples containing the folder we want to upload the data to and the string outputs of
            exports. If you want to update items instead of create, the data must be a tuple of
            (ItemId, is_associated, data) values.
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: A list of tuples with the new ids and changekeys

          Example:
          account.upload([
              (account.inbox, &#34;AABBCC...&#34;),
              (account.inbox, (ItemId(&#39;AA&#39;, &#39;BB&#39;), False, &#34;XXYYZZ...&#34;)),
              (account.inbox, ((&#39;CC&#39;, &#39;DD&#39;), None, &#34;XXYYZZ...&#34;)),
              (account.calendar, &#34;ABCXYZ...&#34;),
          ])
          -&gt; [(&#34;idA&#34;, &#34;changekey&#34;), (&#34;idB&#34;, &#34;changekey&#34;), (&#34;idC&#34;, &#34;changekey&#34;)]
        &#34;&#34;&#34;
        items = ((f, (None, False, d) if isinstance(d, str) else d) for f, d in data)
        return list(
            self._consume_item_service(service_cls=UploadItems, items=items, chunk_size=chunk_size, kwargs={})
        )

    def bulk_create(self, folder, items, message_disposition=SAVE_ONLY, send_meeting_invitations=SEND_TO_NONE,
                    chunk_size=None):
        &#34;&#34;&#34;Create new items in &#39;folder&#39;.

        :param folder: the folder to create the items in
        :param items: an iterable of Item objects
        :param message_disposition: only applicable to Message items. Possible values are specified in
            MESSAGE_DISPOSITION_CHOICES (Default value = SAVE_ONLY)
        :param send_meeting_invitations: only applicable to CalendarItem items. Possible values are specified in
            SEND_MEETING_INVITATIONS_CHOICES (Default value = SEND_TO_NONE)
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: a list of either BulkCreateResult or exception instances in the same order as the input. The returned
          BulkCreateResult objects are normal Item objects except they only contain the &#39;id&#39; and &#39;changekey&#39;
          of the created item, and the &#39;id&#39; of any attachments that were also created.
        &#34;&#34;&#34;
        if isinstance(items, QuerySet):
            # bulk_create() on a queryset does not make sense because it returns items that have already been created
            raise ValueError(&#39;Cannot bulk create items from a QuerySet&#39;)
        log.debug(
            &#39;Adding items for %s (folder %s, message_disposition: %s, send_meeting_invitations: %s)&#39;,
            self,
            folder,
            message_disposition,
            send_meeting_invitations,
        )
        return list(self._consume_item_service(service_cls=CreateItem, items=items, chunk_size=chunk_size, kwargs=dict(
            folder=folder,
            message_disposition=message_disposition,
            send_meeting_invitations=send_meeting_invitations,
        )))

    def bulk_update(self, items, conflict_resolution=AUTO_RESOLVE, message_disposition=SAVE_ONLY,
                    send_meeting_invitations_or_cancellations=SEND_TO_NONE, suppress_read_receipts=True,
                    chunk_size=None):
        &#34;&#34;&#34;Bulk update existing items.

        :param items: a list of (Item, fieldnames) tuples, where &#39;Item&#39; is an Item object, and &#39;fieldnames&#39; is a list
            containing the attributes on this Item object that we want to be updated.
        :param conflict_resolution: Possible values are specified in CONFLICT_RESOLUTION_CHOICES
            (Default value = AUTO_RESOLVE)
        :param message_disposition: only applicable to Message items. Possible values are specified in
            MESSAGE_DISPOSITION_CHOICES (Default value = SAVE_ONLY)
        :param send_meeting_invitations_or_cancellations: only applicable to CalendarItem items. Possible values are
            specified in SEND_MEETING_INVITATIONS_AND_CANCELLATIONS_CHOICES (Default value = SEND_TO_NONE)
        :param suppress_read_receipts: nly supported from Exchange 2013. True or False (Default value = True)
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: a list of either (id, changekey) tuples or exception instances, in the same order as the input
        &#34;&#34;&#34;
        # bulk_update() on a queryset does not make sense because there would be no opportunity to alter the items. In
        # fact, it could be dangerous if the queryset contains an &#39;.only()&#39;. This would wipe out certain fields
        # entirely.
        if isinstance(items, QuerySet):
            raise ValueError(&#39;Cannot bulk update on a queryset&#39;)
        log.debug(
            &#39;Updating items for %s (conflict_resolution %s, message_disposition: %s, send_meeting_invitations: %s)&#39;,
            self,
            conflict_resolution,
            message_disposition,
            send_meeting_invitations_or_cancellations,
        )
        return list(self._consume_item_service(service_cls=UpdateItem, items=items, chunk_size=chunk_size, kwargs=dict(
            conflict_resolution=conflict_resolution,
            message_disposition=message_disposition,
            send_meeting_invitations_or_cancellations=send_meeting_invitations_or_cancellations,
            suppress_read_receipts=suppress_read_receipts,
        )))

    def bulk_delete(self, ids, delete_type=HARD_DELETE, send_meeting_cancellations=SEND_TO_NONE,
                    affected_task_occurrences=ALL_OCCURRENCIES, suppress_read_receipts=True, chunk_size=None):
        &#34;&#34;&#34;Bulk delete items.

        :param ids: an iterable of either (id, changekey) tuples or Item objects.
        :param delete_type: the type of delete to perform. Possible values are specified in DELETE_TYPE_CHOICES
            (Default value = HARD_DELETE)
        :param send_meeting_cancellations: only applicable to CalendarItem. Possible values are specified in
            SEND_MEETING_CANCELLATIONS_CHOICES. (Default value = SEND_TO_NONE)
        :param affected_task_occurrences: only applicable for recurring Task items. Possible values are specified in
            AFFECTED_TASK_OCCURRENCES_CHOICES. (Default value = ALL_OCCURRENCIES)
        :param suppress_read_receipts: only supported from Exchange 2013. True or False. (Default value = True)
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: a list of either True or exception instances, in the same order as the input
        &#34;&#34;&#34;
        log.debug(
            &#39;Deleting items for %s (delete_type: %s, send_meeting_invitations: %s, affected_task_occurences: %s)&#39;,
            self,
            delete_type,
            send_meeting_cancellations,
            affected_task_occurrences,
        )
        return list(
            self._consume_item_service(service_cls=DeleteItem, items=ids, chunk_size=chunk_size, kwargs=dict(
                delete_type=delete_type,
                send_meeting_cancellations=send_meeting_cancellations,
                affected_task_occurrences=affected_task_occurrences,
                suppress_read_receipts=suppress_read_receipts,
            ))
        )

    def bulk_send(self, ids, save_copy=True, copy_to_folder=None, chunk_size=None):
        &#34;&#34;&#34;Send existing draft messages. If requested, save a copy in &#39;copy_to_folder&#39;.

        :param ids: an iterable of either (id, changekey) tuples or Item objects.
        :param save_copy: If true, saves a copy of the message (Default value = True)
        :param copy_to_folder: If requested, save a copy of the message in this folder. Default is the Sent folder
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: Status for each send operation, in the same order as the input
        &#34;&#34;&#34;
        if copy_to_folder and not save_copy:
            raise AttributeError(&#34;&#39;save_copy&#39; must be True when &#39;copy_to_folder&#39; is set&#34;)
        if save_copy and not copy_to_folder:
            copy_to_folder = self.sent  # &#39;Sent&#39; is default EWS behaviour
        return list(
            self._consume_item_service(service_cls=SendItem, items=ids, chunk_size=chunk_size, kwargs=dict(
                saved_item_folder=copy_to_folder,
            ))
        )

    def bulk_copy(self, ids, to_folder, chunk_size=None):
        &#34;&#34;&#34;Copy items to another folder.

        :param ids: an iterable of either (id, changekey) tuples or Item objects.
        :param to_folder: The destination folder of the copy operation
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: Status for each send operation, in the same order as the input
        &#34;&#34;&#34;
        return list(self._consume_item_service(service_cls=CopyItem, items=ids, chunk_size=chunk_size, kwargs=dict(
            to_folder=to_folder,
        )))

    def bulk_move(self, ids, to_folder, chunk_size=None):
        &#34;&#34;&#34;Move items to another folder.

        :param ids: an iterable of either (id, changekey) tuples or Item objects.
        :param to_folder: The destination folder of the copy operation
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: The new IDs of the moved items, in the same order as the input. If &#39;to_folder&#39; is a public folder or a
          folder in a different mailbox, an empty list is returned.
        &#34;&#34;&#34;
        return list(self._consume_item_service(service_cls=MoveItem, items=ids, chunk_size=chunk_size, kwargs=dict(
            to_folder=to_folder,
        )))

    def bulk_archive(self, ids, to_folder, chunk_size=None):
        &#34;&#34;&#34;Archive items to a folder in the archive mailbox. An archive mailbox must be enabled in order for this
        to work.

        :param ids: an iterable of either (id, changekey) tuples or Item objects.
        :param to_folder: The destination folder of the archive operation
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: A list containing True or an exception instance in stable order of the requested items
        &#34;&#34;&#34;
        return list(self._consume_item_service(service_cls=ArchiveItem, items=ids, chunk_size=chunk_size, kwargs=dict(
                to_folder=to_folder,
            ))
        )

    def bulk_mark_as_junk(self, ids, is_junk, move_item, chunk_size=None):
        &#34;&#34;&#34;Mark or un-mark message items as junk email and add or remove the sender from the blocked sender list.

        :param ids: an iterable of either (id, changekey) tuples or Item objects.
        :param is_junk: Whether the messages are junk or not
        :param move_item: Whether to move the messages to the junk folder or not
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: A list containing the new IDs of the moved items, if items were moved, or True, or an exception
          instance, in stable order of the requested items.
        &#34;&#34;&#34;
        return list(self._consume_item_service(service_cls=MarkAsJunk, items=ids, chunk_size=chunk_size, kwargs=dict(
            is_junk=is_junk,
            move_item=move_item,
        )))

    def fetch(self, ids, folder=None, only_fields=None, chunk_size=None):
        &#34;&#34;&#34;Fetch items by ID.

        :param ids: an iterable of either (id, changekey) tuples or Item objects.
        :param folder: used for validating &#39;only_fields&#39; (Default value = None)
        :param only_fields: A list of string or FieldPath items specifying the fields to fetch. Default to all fields
        :param chunk_size: The number of items to send to the server in a single request (Default value = None)

        :return: A generator of Item objects, in the same order as the input
        &#34;&#34;&#34;
        validation_folder = folder or Folder(root=self.root)  # Default to a folder type that supports all item types
        # &#39;ids&#39; could be an unevaluated QuerySet, e.g. if we ended up here via `fetch(ids=some_folder.filter(...))`. In
        # that case, we want to use its iterator. Otherwise, peek() will start a count() which is wasteful because we
        # need the item IDs immediately afterwards. iterator() will only do the bare minimum.
        if only_fields is None:
            # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
            additional_fields = {
                FieldPath(field=f) for f in validation_folder.allowed_item_fields(version=self.version)
            }
        else:
            for field in only_fields:
                validation_folder.validate_item_field(field=field, version=self.version)
            # Remove ItemId and ChangeKey. We get them unconditionally
            additional_fields = {f for f in validation_folder.normalize_fields(fields=only_fields)
                                 if not f.field.is_attribute}
        # Always use IdOnly here, because AllProperties doesn&#39;t actually get *all* properties
        yield from self._consume_item_service(service_cls=GetItem, items=ids, chunk_size=chunk_size, kwargs=dict(
                additional_fields=additional_fields,
                shape=ID_ONLY,
        ))

    def fetch_personas(self, ids):
        &#34;&#34;&#34;Fetch personas by ID.

        :param ids: an iterable of either (id, changekey) tuples or Persona objects.
        :return: A generator of Persona objects, in the same order as the input
        &#34;&#34;&#34;
        if isinstance(ids, QuerySet):
            # We just want an iterator over the results
            ids = iter(ids)
        is_empty, ids = peek(ids)
        if is_empty:
            # We accept generators, so it&#39;s not always convenient for caller to know up-front if &#39;ids&#39; is empty. Allow
            # empty &#39;ids&#39; and return early.
            return
        # GetPersona only accepts one persona ID per request. Crazy.
        svc = GetPersona(account=self)
        for i in ids:
            yield svc.call(persona=i)

    @property
    def mail_tips(self):
        &#34;&#34;&#34;See self.oof_settings about caching considerations.&#34;&#34;&#34;
        # mail_tips_requested must be one of properties.MAIL_TIPS_TYPES
        return GetMailTips(protocol=self.protocol).get(
            sending_as=SendingAs(email_address=self.primary_smtp_address),
            recipients=[Mailbox(email_address=self.primary_smtp_address)],
            mail_tips_requested=&#39;All&#39;,
        )

    @property
    def delegates(self):
        &#34;&#34;&#34;Return a list of DelegateUser objects representing the delegates that are set on this account.&#34;&#34;&#34;
        delegates = []
        for d in GetDelegate(account=self).call(user_ids=None, include_permissions=True):
            if isinstance(d, Exception):
                raise d
            delegates.append(d)
        return delegates

    def __str__(self):
        txt = &#39;%s&#39; % self.primary_smtp_address
        if self.fullname:
            txt += &#39; (%s)&#39; % self.fullname
        return txt</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Account.admin_audit_logs"><code class="name">var <span class="ident">admin_audit_logs</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_deleted_items"><code class="name">var <span class="ident">archive_deleted_items</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_inbox"><code class="name">var <span class="ident">archive_inbox</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_msg_folder_root"><code class="name">var <span class="ident">archive_msg_folder_root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_recoverable_items_deletions"><code class="name">var <span class="ident">archive_recoverable_items_deletions</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_recoverable_items_purges"><code class="name">var <span class="ident">archive_recoverable_items_purges</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_recoverable_items_root"><code class="name">var <span class="ident">archive_recoverable_items_root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_recoverable_items_versions"><code class="name">var <span class="ident">archive_recoverable_items_versions</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.archive_root"><code class="name">var <span class="ident">archive_root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.calendar"><code class="name">var <span class="ident">calendar</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.conflicts"><code class="name">var <span class="ident">conflicts</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.contacts"><code class="name">var <span class="ident">contacts</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.conversation_history"><code class="name">var <span class="ident">conversation_history</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.delegates"><code class="name">var <span class="ident">delegates</span></code></dt>
<dd>
<div class="desc"><p>Return a list of DelegateUser objects representing the delegates that are set on this account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def delegates(self):
    &#34;&#34;&#34;Return a list of DelegateUser objects representing the delegates that are set on this account.&#34;&#34;&#34;
    delegates = []
    for d in GetDelegate(account=self).call(user_ids=None, include_permissions=True):
        if isinstance(d, Exception):
            raise d
        delegates.append(d)
    return delegates</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.directory"><code class="name">var <span class="ident">directory</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.domain"><code class="name">var <span class="ident">domain</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def domain(self):
    return get_domain(self.primary_smtp_address)</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.drafts"><code class="name">var <span class="ident">drafts</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.favorites"><code class="name">var <span class="ident">favorites</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.im_contact_list"><code class="name">var <span class="ident">im_contact_list</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.inbox"><code class="name">var <span class="ident">inbox</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.journal"><code class="name">var <span class="ident">journal</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.junk"><code class="name">var <span class="ident">junk</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.local_failures"><code class="name">var <span class="ident">local_failures</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.mail_tips"><code class="name">var <span class="ident">mail_tips</span></code></dt>
<dd>
<div class="desc"><p>See self.oof_settings about caching considerations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mail_tips(self):
    &#34;&#34;&#34;See self.oof_settings about caching considerations.&#34;&#34;&#34;
    # mail_tips_requested must be one of properties.MAIL_TIPS_TYPES
    return GetMailTips(protocol=self.protocol).get(
        sending_as=SendingAs(email_address=self.primary_smtp_address),
        recipients=[Mailbox(email_address=self.primary_smtp_address)],
        mail_tips_requested=&#39;All&#39;,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.msg_folder_root"><code class="name">var <span class="ident">msg_folder_root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.my_contacts"><code class="name">var <span class="ident">my_contacts</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.notes"><code class="name">var <span class="ident">notes</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.oof_settings"><code class="name">var <span class="ident">oof_settings</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def oof_settings(self):
    # We don&#39;t want to cache this property because then we can&#39;t easily get updates. &#39;threaded_cached_property&#39;
    # supports the &#39;del self.oof_settings&#39; syntax to invalidate the cache, but does not support custom setter
    # methods. Having a non-cached service call here goes against the assumption that properties are cheap, but the
    # alternative is to create get_oof_settings() and set_oof_settings(), and that&#39;s just too Java-ish for my taste.
    return GetUserOofSettings(account=self).get(
        mailbox=Mailbox(email_address=self.primary_smtp_address),
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.outbox"><code class="name">var <span class="ident">outbox</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.people_connect"><code class="name">var <span class="ident">people_connect</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.primary_smtp_address"><code class="name">var <span class="ident">primary_smtp_address</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def primary_smtp_address(self):
    return self.identity.primary_smtp_address</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.public_folders_root"><code class="name">var <span class="ident">public_folders_root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.quick_contacts"><code class="name">var <span class="ident">quick_contacts</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.recipient_cache"><code class="name">var <span class="ident">recipient_cache</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.recoverable_items_deletions"><code class="name">var <span class="ident">recoverable_items_deletions</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.recoverable_items_purges"><code class="name">var <span class="ident">recoverable_items_purges</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.recoverable_items_root"><code class="name">var <span class="ident">recoverable_items_root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.recoverable_items_versions"><code class="name">var <span class="ident">recoverable_items_versions</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.root"><code class="name">var <span class="ident">root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.search_folders"><code class="name">var <span class="ident">search_folders</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.sent"><code class="name">var <span class="ident">sent</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.server_failures"><code class="name">var <span class="ident">server_failures</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.sync_issues"><code class="name">var <span class="ident">sync_issues</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.tasks"><code class="name">var <span class="ident">tasks</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.todo_search"><code class="name">var <span class="ident">todo_search</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.trash"><code class="name">var <span class="ident">trash</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.voice_mail"><code class="name">var <span class="ident">voice_mail</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Account.bulk_archive"><code class="name flex">
<span>def <span class="ident">bulk_archive</span></span>(<span>self, ids, to_folder, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Archive items to a folder in the archive mailbox. An archive mailbox must be enabled in order for this
to work.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Item objects.
:param to_folder: The destination folder of the archive operation
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: A list containing True or an exception instance in stable order of the requested items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_archive(self, ids, to_folder, chunk_size=None):
    &#34;&#34;&#34;Archive items to a folder in the archive mailbox. An archive mailbox must be enabled in order for this
    to work.

    :param ids: an iterable of either (id, changekey) tuples or Item objects.
    :param to_folder: The destination folder of the archive operation
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: A list containing True or an exception instance in stable order of the requested items
    &#34;&#34;&#34;
    return list(self._consume_item_service(service_cls=ArchiveItem, items=ids, chunk_size=chunk_size, kwargs=dict(
            to_folder=to_folder,
        ))
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.bulk_copy"><code class="name flex">
<span>def <span class="ident">bulk_copy</span></span>(<span>self, ids, to_folder, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy items to another folder.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Item objects.
:param to_folder: The destination folder of the copy operation
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: Status for each send operation, in the same order as the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_copy(self, ids, to_folder, chunk_size=None):
    &#34;&#34;&#34;Copy items to another folder.

    :param ids: an iterable of either (id, changekey) tuples or Item objects.
    :param to_folder: The destination folder of the copy operation
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: Status for each send operation, in the same order as the input
    &#34;&#34;&#34;
    return list(self._consume_item_service(service_cls=CopyItem, items=ids, chunk_size=chunk_size, kwargs=dict(
        to_folder=to_folder,
    )))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.bulk_create"><code class="name flex">
<span>def <span class="ident">bulk_create</span></span>(<span>self, folder, items, message_disposition='SaveOnly', send_meeting_invitations='SendToNone', chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Create new items in 'folder'.</p>
<p>:param folder: the folder to create the items in
:param items: an iterable of Item objects
:param message_disposition: only applicable to Message items. Possible values are specified in
MESSAGE_DISPOSITION_CHOICES (Default value = SAVE_ONLY)
:param send_meeting_invitations: only applicable to CalendarItem items. Possible values are specified in
SEND_MEETING_INVITATIONS_CHOICES (Default value = SEND_TO_NONE)
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: a list of either BulkCreateResult or exception instances in the same order as the input. The returned
BulkCreateResult objects are normal Item objects except they only contain the 'id' and 'changekey'
of the created item, and the 'id' of any attachments that were also created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_create(self, folder, items, message_disposition=SAVE_ONLY, send_meeting_invitations=SEND_TO_NONE,
                chunk_size=None):
    &#34;&#34;&#34;Create new items in &#39;folder&#39;.

    :param folder: the folder to create the items in
    :param items: an iterable of Item objects
    :param message_disposition: only applicable to Message items. Possible values are specified in
        MESSAGE_DISPOSITION_CHOICES (Default value = SAVE_ONLY)
    :param send_meeting_invitations: only applicable to CalendarItem items. Possible values are specified in
        SEND_MEETING_INVITATIONS_CHOICES (Default value = SEND_TO_NONE)
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: a list of either BulkCreateResult or exception instances in the same order as the input. The returned
      BulkCreateResult objects are normal Item objects except they only contain the &#39;id&#39; and &#39;changekey&#39;
      of the created item, and the &#39;id&#39; of any attachments that were also created.
    &#34;&#34;&#34;
    if isinstance(items, QuerySet):
        # bulk_create() on a queryset does not make sense because it returns items that have already been created
        raise ValueError(&#39;Cannot bulk create items from a QuerySet&#39;)
    log.debug(
        &#39;Adding items for %s (folder %s, message_disposition: %s, send_meeting_invitations: %s)&#39;,
        self,
        folder,
        message_disposition,
        send_meeting_invitations,
    )
    return list(self._consume_item_service(service_cls=CreateItem, items=items, chunk_size=chunk_size, kwargs=dict(
        folder=folder,
        message_disposition=message_disposition,
        send_meeting_invitations=send_meeting_invitations,
    )))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.bulk_delete"><code class="name flex">
<span>def <span class="ident">bulk_delete</span></span>(<span>self, ids, delete_type='HardDelete', send_meeting_cancellations='SendToNone', affected_task_occurrences='AllOccurrences', suppress_read_receipts=True, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Bulk delete items.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Item objects.
:param delete_type: the type of delete to perform. Possible values are specified in DELETE_TYPE_CHOICES
(Default value = HARD_DELETE)
:param send_meeting_cancellations: only applicable to CalendarItem. Possible values are specified in
SEND_MEETING_CANCELLATIONS_CHOICES. (Default value = SEND_TO_NONE)
:param affected_task_occurrences: only applicable for recurring Task items. Possible values are specified in
AFFECTED_TASK_OCCURRENCES_CHOICES. (Default value = ALL_OCCURRENCIES)
:param suppress_read_receipts: only supported from Exchange 2013. True or False. (Default value = True)
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: a list of either True or exception instances, in the same order as the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_delete(self, ids, delete_type=HARD_DELETE, send_meeting_cancellations=SEND_TO_NONE,
                affected_task_occurrences=ALL_OCCURRENCIES, suppress_read_receipts=True, chunk_size=None):
    &#34;&#34;&#34;Bulk delete items.

    :param ids: an iterable of either (id, changekey) tuples or Item objects.
    :param delete_type: the type of delete to perform. Possible values are specified in DELETE_TYPE_CHOICES
        (Default value = HARD_DELETE)
    :param send_meeting_cancellations: only applicable to CalendarItem. Possible values are specified in
        SEND_MEETING_CANCELLATIONS_CHOICES. (Default value = SEND_TO_NONE)
    :param affected_task_occurrences: only applicable for recurring Task items. Possible values are specified in
        AFFECTED_TASK_OCCURRENCES_CHOICES. (Default value = ALL_OCCURRENCIES)
    :param suppress_read_receipts: only supported from Exchange 2013. True or False. (Default value = True)
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: a list of either True or exception instances, in the same order as the input
    &#34;&#34;&#34;
    log.debug(
        &#39;Deleting items for %s (delete_type: %s, send_meeting_invitations: %s, affected_task_occurences: %s)&#39;,
        self,
        delete_type,
        send_meeting_cancellations,
        affected_task_occurrences,
    )
    return list(
        self._consume_item_service(service_cls=DeleteItem, items=ids, chunk_size=chunk_size, kwargs=dict(
            delete_type=delete_type,
            send_meeting_cancellations=send_meeting_cancellations,
            affected_task_occurrences=affected_task_occurrences,
            suppress_read_receipts=suppress_read_receipts,
        ))
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.bulk_mark_as_junk"><code class="name flex">
<span>def <span class="ident">bulk_mark_as_junk</span></span>(<span>self, ids, is_junk, move_item, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Mark or un-mark message items as junk email and add or remove the sender from the blocked sender list.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Item objects.
:param is_junk: Whether the messages are junk or not
:param move_item: Whether to move the messages to the junk folder or not
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: A list containing the new IDs of the moved items, if items were moved, or True, or an exception
instance, in stable order of the requested items.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_mark_as_junk(self, ids, is_junk, move_item, chunk_size=None):
    &#34;&#34;&#34;Mark or un-mark message items as junk email and add or remove the sender from the blocked sender list.

    :param ids: an iterable of either (id, changekey) tuples or Item objects.
    :param is_junk: Whether the messages are junk or not
    :param move_item: Whether to move the messages to the junk folder or not
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: A list containing the new IDs of the moved items, if items were moved, or True, or an exception
      instance, in stable order of the requested items.
    &#34;&#34;&#34;
    return list(self._consume_item_service(service_cls=MarkAsJunk, items=ids, chunk_size=chunk_size, kwargs=dict(
        is_junk=is_junk,
        move_item=move_item,
    )))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.bulk_move"><code class="name flex">
<span>def <span class="ident">bulk_move</span></span>(<span>self, ids, to_folder, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Move items to another folder.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Item objects.
:param to_folder: The destination folder of the copy operation
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: The new IDs of the moved items, in the same order as the input. If 'to_folder' is a public folder or a
folder in a different mailbox, an empty list is returned.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_move(self, ids, to_folder, chunk_size=None):
    &#34;&#34;&#34;Move items to another folder.

    :param ids: an iterable of either (id, changekey) tuples or Item objects.
    :param to_folder: The destination folder of the copy operation
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: The new IDs of the moved items, in the same order as the input. If &#39;to_folder&#39; is a public folder or a
      folder in a different mailbox, an empty list is returned.
    &#34;&#34;&#34;
    return list(self._consume_item_service(service_cls=MoveItem, items=ids, chunk_size=chunk_size, kwargs=dict(
        to_folder=to_folder,
    )))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.bulk_send"><code class="name flex">
<span>def <span class="ident">bulk_send</span></span>(<span>self, ids, save_copy=True, copy_to_folder=None, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Send existing draft messages. If requested, save a copy in 'copy_to_folder'.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Item objects.
:param save_copy: If true, saves a copy of the message (Default value = True)
:param copy_to_folder: If requested, save a copy of the message in this folder. Default is the Sent folder
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: Status for each send operation, in the same order as the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_send(self, ids, save_copy=True, copy_to_folder=None, chunk_size=None):
    &#34;&#34;&#34;Send existing draft messages. If requested, save a copy in &#39;copy_to_folder&#39;.

    :param ids: an iterable of either (id, changekey) tuples or Item objects.
    :param save_copy: If true, saves a copy of the message (Default value = True)
    :param copy_to_folder: If requested, save a copy of the message in this folder. Default is the Sent folder
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: Status for each send operation, in the same order as the input
    &#34;&#34;&#34;
    if copy_to_folder and not save_copy:
        raise AttributeError(&#34;&#39;save_copy&#39; must be True when &#39;copy_to_folder&#39; is set&#34;)
    if save_copy and not copy_to_folder:
        copy_to_folder = self.sent  # &#39;Sent&#39; is default EWS behaviour
    return list(
        self._consume_item_service(service_cls=SendItem, items=ids, chunk_size=chunk_size, kwargs=dict(
            saved_item_folder=copy_to_folder,
        ))
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.bulk_update"><code class="name flex">
<span>def <span class="ident">bulk_update</span></span>(<span>self, items, conflict_resolution='AutoResolve', message_disposition='SaveOnly', send_meeting_invitations_or_cancellations='SendToNone', suppress_read_receipts=True, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Bulk update existing items.</p>
<p>:param items: a list of (Item, fieldnames) tuples, where 'Item' is an Item object, and 'fieldnames' is a list
containing the attributes on this Item object that we want to be updated.
:param conflict_resolution: Possible values are specified in CONFLICT_RESOLUTION_CHOICES
(Default value = AUTO_RESOLVE)
:param message_disposition: only applicable to Message items. Possible values are specified in
MESSAGE_DISPOSITION_CHOICES (Default value = SAVE_ONLY)
:param send_meeting_invitations_or_cancellations: only applicable to CalendarItem items. Possible values are
specified in SEND_MEETING_INVITATIONS_AND_CANCELLATIONS_CHOICES (Default value = SEND_TO_NONE)
:param suppress_read_receipts: nly supported from Exchange 2013. True or False (Default value = True)
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: a list of either (id, changekey) tuples or exception instances, in the same order as the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bulk_update(self, items, conflict_resolution=AUTO_RESOLVE, message_disposition=SAVE_ONLY,
                send_meeting_invitations_or_cancellations=SEND_TO_NONE, suppress_read_receipts=True,
                chunk_size=None):
    &#34;&#34;&#34;Bulk update existing items.

    :param items: a list of (Item, fieldnames) tuples, where &#39;Item&#39; is an Item object, and &#39;fieldnames&#39; is a list
        containing the attributes on this Item object that we want to be updated.
    :param conflict_resolution: Possible values are specified in CONFLICT_RESOLUTION_CHOICES
        (Default value = AUTO_RESOLVE)
    :param message_disposition: only applicable to Message items. Possible values are specified in
        MESSAGE_DISPOSITION_CHOICES (Default value = SAVE_ONLY)
    :param send_meeting_invitations_or_cancellations: only applicable to CalendarItem items. Possible values are
        specified in SEND_MEETING_INVITATIONS_AND_CANCELLATIONS_CHOICES (Default value = SEND_TO_NONE)
    :param suppress_read_receipts: nly supported from Exchange 2013. True or False (Default value = True)
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: a list of either (id, changekey) tuples or exception instances, in the same order as the input
    &#34;&#34;&#34;
    # bulk_update() on a queryset does not make sense because there would be no opportunity to alter the items. In
    # fact, it could be dangerous if the queryset contains an &#39;.only()&#39;. This would wipe out certain fields
    # entirely.
    if isinstance(items, QuerySet):
        raise ValueError(&#39;Cannot bulk update on a queryset&#39;)
    log.debug(
        &#39;Updating items for %s (conflict_resolution %s, message_disposition: %s, send_meeting_invitations: %s)&#39;,
        self,
        conflict_resolution,
        message_disposition,
        send_meeting_invitations_or_cancellations,
    )
    return list(self._consume_item_service(service_cls=UpdateItem, items=items, chunk_size=chunk_size, kwargs=dict(
        conflict_resolution=conflict_resolution,
        message_disposition=message_disposition,
        send_meeting_invitations_or_cancellations=send_meeting_invitations_or_cancellations,
        suppress_read_receipts=suppress_read_receipts,
    )))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.export"><code class="name flex">
<span>def <span class="ident">export</span></span>(<span>self, items, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return export strings of the given items.</p>
<p>:param items: An iterable containing the Items we want to export
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: A list of strings, the exported representation of the object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export(self, items, chunk_size=None):
    &#34;&#34;&#34;Return export strings of the given items.

    :param items: An iterable containing the Items we want to export
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: A list of strings, the exported representation of the object
    &#34;&#34;&#34;
    return list(
        self._consume_item_service(service_cls=ExportItems, items=items, chunk_size=chunk_size, kwargs={})
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.fetch"><code class="name flex">
<span>def <span class="ident">fetch</span></span>(<span>self, ids, folder=None, only_fields=None, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch items by ID.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Item objects.
:param folder: used for validating 'only_fields' (Default value = None)
:param only_fields: A list of string or FieldPath items specifying the fields to fetch. Default to all fields
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: A generator of Item objects, in the same order as the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch(self, ids, folder=None, only_fields=None, chunk_size=None):
    &#34;&#34;&#34;Fetch items by ID.

    :param ids: an iterable of either (id, changekey) tuples or Item objects.
    :param folder: used for validating &#39;only_fields&#39; (Default value = None)
    :param only_fields: A list of string or FieldPath items specifying the fields to fetch. Default to all fields
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: A generator of Item objects, in the same order as the input
    &#34;&#34;&#34;
    validation_folder = folder or Folder(root=self.root)  # Default to a folder type that supports all item types
    # &#39;ids&#39; could be an unevaluated QuerySet, e.g. if we ended up here via `fetch(ids=some_folder.filter(...))`. In
    # that case, we want to use its iterator. Otherwise, peek() will start a count() which is wasteful because we
    # need the item IDs immediately afterwards. iterator() will only do the bare minimum.
    if only_fields is None:
        # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
        additional_fields = {
            FieldPath(field=f) for f in validation_folder.allowed_item_fields(version=self.version)
        }
    else:
        for field in only_fields:
            validation_folder.validate_item_field(field=field, version=self.version)
        # Remove ItemId and ChangeKey. We get them unconditionally
        additional_fields = {f for f in validation_folder.normalize_fields(fields=only_fields)
                             if not f.field.is_attribute}
    # Always use IdOnly here, because AllProperties doesn&#39;t actually get *all* properties
    yield from self._consume_item_service(service_cls=GetItem, items=ids, chunk_size=chunk_size, kwargs=dict(
            additional_fields=additional_fields,
            shape=ID_ONLY,
    ))</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.fetch_personas"><code class="name flex">
<span>def <span class="ident">fetch_personas</span></span>(<span>self, ids)</span>
</code></dt>
<dd>
<div class="desc"><p>Fetch personas by ID.</p>
<p>:param ids: an iterable of either (id, changekey) tuples or Persona objects.
:return: A generator of Persona objects, in the same order as the input</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fetch_personas(self, ids):
    &#34;&#34;&#34;Fetch personas by ID.

    :param ids: an iterable of either (id, changekey) tuples or Persona objects.
    :return: A generator of Persona objects, in the same order as the input
    &#34;&#34;&#34;
    if isinstance(ids, QuerySet):
        # We just want an iterator over the results
        ids = iter(ids)
    is_empty, ids = peek(ids)
    if is_empty:
        # We accept generators, so it&#39;s not always convenient for caller to know up-front if &#39;ids&#39; is empty. Allow
        # empty &#39;ids&#39; and return early.
        return
    # GetPersona only accepts one persona ID per request. Crazy.
    svc = GetPersona(account=self)
    for i in ids:
        yield svc.call(persona=i)</code></pre>
</details>
</dd>
<dt id="exchangelib.Account.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>self, data, chunk_size=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Upload objects retrieved from an export to the given folders.</p>
<p>:param data: An iterable of tuples containing the folder we want to upload the data to and the string outputs of
exports. If you want to update items instead of create, the data must be a tuple of
(ItemId, is_associated, data) values.
:param chunk_size: The number of items to send to the server in a single request (Default value = None)</p>
<p>:return: A list of tuples with the new ids and changekeys</p>
<p>Example:
account.upload([
(account.inbox, "AABBCC&hellip;"),
(account.inbox, (ItemId('AA', 'BB'), False, "XXYYZZ&hellip;")),
(account.inbox, (('CC', 'DD'), None, "XXYYZZ&hellip;")),
(account.calendar, "ABCXYZ&hellip;"),
])
-&gt; [("idA", "changekey"), ("idB", "changekey"), ("idC", "changekey")]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def upload(self, data, chunk_size=None):
    &#34;&#34;&#34;Upload objects retrieved from an export to the given folders.

    :param data: An iterable of tuples containing the folder we want to upload the data to and the string outputs of
        exports. If you want to update items instead of create, the data must be a tuple of
        (ItemId, is_associated, data) values.
    :param chunk_size: The number of items to send to the server in a single request (Default value = None)

    :return: A list of tuples with the new ids and changekeys

      Example:
      account.upload([
          (account.inbox, &#34;AABBCC...&#34;),
          (account.inbox, (ItemId(&#39;AA&#39;, &#39;BB&#39;), False, &#34;XXYYZZ...&#34;)),
          (account.inbox, ((&#39;CC&#39;, &#39;DD&#39;), None, &#34;XXYYZZ...&#34;)),
          (account.calendar, &#34;ABCXYZ...&#34;),
      ])
      -&gt; [(&#34;idA&#34;, &#34;changekey&#34;), (&#34;idB&#34;, &#34;changekey&#34;), (&#34;idC&#34;, &#34;changekey&#34;)]
    &#34;&#34;&#34;
    items = ((f, (None, False, d) if isinstance(d, str) else d) for f, d in data)
    return list(
        self._consume_item_service(service_cls=UploadItems, items=items, chunk_size=chunk_size, kwargs={})
    )</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.Attendee"><code class="flex name class">
<span>class <span class="ident">Attendee</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/attendee">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/attendee</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Attendee(EWSElement):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/attendee&#34;&#34;&#34;

    ELEMENT_NAME = &#39;Attendee&#39;
    RESPONSE_TYPES = {&#39;Unknown&#39;, &#39;Organizer&#39;, &#39;Tentative&#39;, &#39;Accept&#39;, &#39;Decline&#39;, &#39;NoResponseReceived&#39;}

    mailbox = MailboxField(is_required=True)
    response_type = ChoiceField(field_uri=&#39;ResponseType&#39;, choices={Choice(c) for c in RESPONSE_TYPES},
                                default=&#39;Unknown&#39;)
    last_response_time = DateTimeField(field_uri=&#39;LastResponseTime&#39;)

    def __hash__(self):
        return hash(self.mailbox)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Attendee.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Attendee.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Attendee.RESPONSE_TYPES"><code class="name">var <span class="ident">RESPONSE_TYPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Attendee.last_response_time"><code class="name">var <span class="ident">last_response_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Attendee.mailbox"><code class="name">var <span class="ident">mailbox</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Attendee.response_type"><code class="name">var <span class="ident">response_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.EWSElement.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.BaseProtocol"><code class="flex name class">
<span>class <span class="ident">BaseProtocol</span></span>
<span>(</span><span>config)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for Protocol which implements the bare essentials.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseProtocol:
    &#34;&#34;&#34;Base class for Protocol which implements the bare essentials.&#34;&#34;&#34;

    # The maximum number of sessions (== TCP connections, see below) we will open to this service endpoint. Keep this
    # low unless you have an agreement with the Exchange admin on the receiving end to hammer the server and
    # rate-limiting policies have been disabled for the connecting user. Changing this setting only makes sense if
    # you are using a thread pool to run multiple concurrent workers in this process.
    SESSION_POOLSIZE = 1
    # We want only 1 TCP connection per Session object. We may have lots of different credentials hitting the server and
    # each credential needs its own session (NTLM auth will only send credentials once and then secure the connection,
    # so a connection can only handle requests for one credential). Having multiple connections per Session could
    # quickly exhaust the maximum number of concurrent connections the Exchange server allows from one client.
    CONNECTIONS_PER_SESSION = 1
    # The number of times a session may be reused before creating a new session object. &#39;None&#39; means &#34;infinite&#34;.
    # Discarding sessions after a certain number of usages may limit memory leaks in the Session object.
    MAX_SESSION_USAGE_COUNT = None
    # Timeout for HTTP requests
    TIMEOUT = 120

    # The adapter class to use for HTTP requests. Override this if you need e.g. proxy support or specific TLS versions
    HTTP_ADAPTER_CLS = requests.adapters.HTTPAdapter

    # The User-Agent header to use for HTTP requests. Override this to set an app-specific one
    USERAGENT = None

    def __init__(self, config):
        from .configuration import Configuration
        if not isinstance(config, Configuration):
            raise ValueError(&#34;&#39;config&#39; %r must be a Configuration instance&#34; % config)
        if not config.service_endpoint:
            raise AttributeError(&#34;&#39;config.service_endpoint&#39; must be set&#34;)
        self.config = config
        self._session_pool_size = 0
        self._session_pool_maxsize = config.max_connections or self.SESSION_POOLSIZE

        # Try to behave nicely with the remote server. We want to keep the connection open between requests.
        # We also want to re-use sessions, to avoid the NTLM auth handshake on every request. We must know the
        # authentication method to create sessions.
        self._session_pool = LifoQueue()
        self._session_pool_lock = Lock()

    @property
    def service_endpoint(self):
        return self.config.service_endpoint

    @property
    def auth_type(self):
        return self.config.auth_type

    @property
    def credentials(self):
        return self.config.credentials

    @credentials.setter
    def credentials(self, value):
        # We are updating credentials, but that doesn&#39;t automatically propagate to the session objects. The simplest
        # solution is to just kill the sessions in the pool.
        with self._session_pool_lock:
            self.config._credentials = value
            self.close()

    @property
    def retry_policy(self):
        return self.config.retry_policy

    @property
    def server(self):
        return self.config.server

    def __getstate__(self):
        # The session pool and lock cannot be pickled
        state = self.__dict__.copy()
        del state[&#39;_session_pool&#39;]
        del state[&#39;_session_pool_lock&#39;]
        return state

    def __setstate__(self, state):
        # Restore the session pool and lock
        self.__dict__.update(state)
        self._session_pool = LifoQueue()
        self._session_pool_lock = Lock()

    def __del__(self):
        # pylint: disable=bare-except
        try:
            self.close()
        except Exception:  # nosec
            # __del__ should never fail
            pass

    def close(self):
        log.debug(&#39;Server %s: Closing sessions&#39;, self.server)
        while True:
            try:
                session = self._session_pool.get(block=False)
                self.close_session(session)
                self._session_pool_size -= 1
            except Empty:
                break

    @classmethod
    def get_adapter(cls):
        # We want just one connection per session. No retries, since we wrap all requests in our own retry handler
        return cls.HTTP_ADAPTER_CLS(
            pool_block=True,
            pool_connections=cls.CONNECTIONS_PER_SESSION,
            pool_maxsize=cls.CONNECTIONS_PER_SESSION,
            max_retries=0,
        )

    @property
    def session_pool_size(self):
        return self._session_pool_size

    def increase_poolsize(self):
        &#34;&#34;&#34;Increases the session pool size. We increase by one session per call.&#34;&#34;&#34;
        # Create a single session and insert it into the pool. We need to protect this with a lock while we are changing
        # the pool size variable, to avoid race conditions. We must not exceed the pool size limit.
        if self._session_pool_size == self._session_pool_maxsize:
            raise SessionPoolMaxSizeReached(&#39;Session pool size cannot be increased further&#39;)
        with self._session_pool_lock:
            if self._session_pool_size &gt;= self._session_pool_maxsize:
                log.debug(&#39;Session pool size was increased in another thread&#39;)
                return
            log.debug(&#39;Server %s: Increasing session pool size from %s to %s&#39;, self.server, self._session_pool_size,
                      self._session_pool_size + 1)
            self._session_pool.put(self.create_session(), block=False)
            self._session_pool_size += 1

    def decrease_poolsize(self):
        &#34;&#34;&#34;Decreases the session pool size in response to error messages from the server requesting to rate-limit
        requests. We decrease by one session per call.
        &#34;&#34;&#34;
        # Take a single session from the pool and discard it. We need to protect this with a lock while we are changing
        # the pool size variable, to avoid race conditions. We must keep at least one session in the pool.
        if self._session_pool_size &lt;= 1:
            raise SessionPoolMinSizeReached(&#39;Session pool size cannot be decreased further&#39;)
        with self._session_pool_lock:
            if self._session_pool_size &lt;= 1:
                log.debug(&#39;Session pool size was decreased in another thread&#39;)
                return
            log.warning(&#39;Server %s: Decreasing session pool size from %s to %s&#39;, self.server, self._session_pool_size,
                        self._session_pool_size - 1)
            session = self.get_session()
            self.close_session(session)
            self._session_pool_size -= 1

    def get_session(self):
        # Try to get a session from the queue. If the queue is empty, try to add one more session to the queue. If the
        # queue is already at its max, wait until a session becomes available.
        _timeout = 60  # Rate-limit messages about session starvation
        try:
            session = self._session_pool.get(block=False)
            log.debug(&#39;Server %s: Got session immediately&#39;, self.server)
        except Empty:
            try:
                self.increase_poolsize()
            except SessionPoolMaxSizeReached:
                pass
            while True:
                try:
                    log.debug(&#39;Server %s: Waiting for session&#39;, self.server)
                    session = self._session_pool.get(timeout=_timeout)
                    break
                except Empty:
                    # This is normal when we have many worker threads starving for available sessions
                    log.debug(&#39;Server %s: No sessions available for %s seconds&#39;, self.server, _timeout)
        log.debug(&#39;Server %s: Got session %s&#39;, self.server, session.session_id)
        session.usage_count += 1
        return session

    def release_session(self, session):
        # This should never fail, as we don&#39;t have more sessions than the queue contains
        log.debug(&#39;Server %s: Releasing session %s&#39;, self.server, session.session_id)
        if self.MAX_SESSION_USAGE_COUNT and session.usage_count &gt; self.MAX_SESSION_USAGE_COUNT:
            log.debug(&#39;Server %s: session %s usage exceeded limit. Discarding&#39;, self.server, session.session_id)
            session = self.renew_session(session)
        try:
            self._session_pool.put(session, block=False)
        except Full:
            log.debug(&#39;Server %s: Session pool was already full %s&#39;, self.server, session.session_id)

    @staticmethod
    def close_session(session):
        session.close()
        del session

    def retire_session(self, session):
        # The session is useless. Close it completely and place a fresh session in the pool
        log.debug(&#39;Server %s: Retiring session %s&#39;, self.server, session.session_id)
        self.close_session(session)
        self.release_session(self.create_session())

    def renew_session(self, session):
        # The session is useless. Close it completely and place a fresh session in the pool
        log.debug(&#39;Server %s: Renewing session %s&#39;, self.server, session.session_id)
        self.close_session(session)
        return self.create_session()

    def refresh_credentials(self, session):
        # Credentials need to be refreshed, probably due to an OAuth
        # access token expiring. If we&#39;ve gotten here, it&#39;s because the
        # application didn&#39;t provide an OAuth client secret, so we can&#39;t
        # handle token refreshing for it.
        with self.credentials.lock:
            if self.credentials.sig() == session.credentials_sig:
                # Credentials have not been refreshed by another thread:
                # they&#39;re the same as the session was created with. If
                # this isn&#39;t the case, we can just go ahead with a new
                # session using the already-updated credentials.
                self.credentials.refresh(session=session)
        return self.renew_session(session)

    def create_session(self):
        if self.auth_type is None:
            raise ValueError(&#39;Cannot create session without knowing the auth type&#39;)
        if self.credentials is None:
            if self.auth_type in CREDENTIALS_REQUIRED:
                raise ValueError(&#39;Auth type %r requires credentials&#39; % self.auth_type)
            session = self.raw_session(self.service_endpoint)
            session.auth = get_auth_instance(auth_type=self.auth_type)
        else:
            with self.credentials.lock:
                if isinstance(self.credentials, OAuth2Credentials):
                    session = self.create_oauth2_session()
                    # Keep track of the credentials used to create this session. If
                    # and when we need to renew credentials (for example, refreshing
                    # an OAuth access token), this lets us easily determine whether
                    # the credentials have already been refreshed in another thread
                    # by the time this session tries.
                    session.credentials_sig = self.credentials.sig()
                else:
                    if self.auth_type == NTLM and self.credentials.type == self.credentials.EMAIL:
                        username = &#39;\\&#39; + self.credentials.username
                    else:
                        username = self.credentials.username
                    session = self.raw_session(self.service_endpoint)
                    session.auth = get_auth_instance(auth_type=self.auth_type, username=username,
                                                     password=self.credentials.password)

        # Add some extra info
        session.session_id = sum(map(ord, str(os.urandom(100))))  # Used for debugging messages in services
        session.usage_count = 0
        session.protocol = self
        log.debug(&#39;Server %s: Created session %s&#39;, self.server, session.session_id)
        return session

    def create_oauth2_session(self):
        if self.auth_type != OAUTH2:
            raise ValueError(
                &#39;Auth type must be %r for credentials type %s&#39; % (OAUTH2, self.credentials.__class__.__name__)
            )

        has_token = False
        scope = [&#39;https://outlook.office365.com/.default&#39;]
        session_params = {}
        token_params = {}

        if isinstance(self.credentials, OAuth2AuthorizationCodeCredentials):
            # Ask for a refresh token
            scope.append(&#39;offline_access&#39;)

            # We don&#39;t know (or need) the Microsoft tenant ID. Use
            # common/ to let Microsoft select the appropriate tenant
            # for the provided authorization code or refresh token.
            #
            # Suppress looks-like-password warning from Bandit.
            token_url = &#39;https://login.microsoftonline.com/common/oauth2/v2.0/token&#39;  # nosec

            client_params = {}
            has_token = self.credentials.access_token is not None
            if has_token:
                session_params[&#39;token&#39;] = self.credentials.access_token
            elif self.credentials.authorization_code is not None:
                token_params[&#39;code&#39;] = self.credentials.authorization_code
                self.credentials.authorization_code = None

            if self.credentials.client_id is not None and self.credentials.client_secret is not None:
                # If we&#39;re given a client ID and secret, we have enough
                # to refresh access tokens ourselves. In other cases the
                # session will raise TokenExpiredError and we&#39;ll need to
                # ask the calling application to refresh the token (that
                # covers cases where the caller doesn&#39;t have access to
                # the client secret but is working with a service that
                # can provide it refreshed tokens on a limited basis).
                session_params.update({
                    &#39;auto_refresh_kwargs&#39;: {
                        &#39;client_id&#39;: self.credentials.client_id,
                        &#39;client_secret&#39;: self.credentials.client_secret,
                    },
                    &#39;auto_refresh_url&#39;: token_url,
                    &#39;token_updater&#39;: self.credentials.on_token_auto_refreshed,
                })
            client = WebApplicationClient(self.credentials.client_id, **client_params)
        else:
            token_url = &#39;https://login.microsoftonline.com/%s/oauth2/v2.0/token&#39; % self.credentials.tenant_id
            client = BackendApplicationClient(client_id=self.credentials.client_id)

        session = self.raw_session(self.service_endpoint, oauth2_client=client, oauth2_session_params=session_params)
        if not has_token:
            # Fetch the token explicitly -- it doesn&#39;t occur implicitly
            token = session.fetch_token(token_url=token_url, client_id=self.credentials.client_id,
                                        client_secret=self.credentials.client_secret, scope=scope,
                                        timeout=self.TIMEOUT, **token_params)
            # Allow the credentials object to update its copy of the new
            # token, and give the application an opportunity to cache it
            self.credentials.on_token_auto_refreshed(token)
        session.auth = get_auth_instance(auth_type=OAUTH2, client=client)

        return session

    @classmethod
    def raw_session(cls, prefix, oauth2_client=None, oauth2_session_params=None):
        if oauth2_client:
            session = OAuth2Session(client=oauth2_client, **(oauth2_session_params or {}))
        else:
            session = requests.sessions.Session()
        session.headers.update(DEFAULT_HEADERS)
        session.headers[&#39;User-Agent&#39;] = cls.USERAGENT
        session.mount(prefix, adapter=cls.get_adapter())
        return session

    def __repr__(self):
        return self.__class__.__name__ + repr((self.service_endpoint, self.credentials, self.auth_type))</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.autodiscover.protocol.AutodiscoverProtocol" href="autodiscover/protocol.html#exchangelib.autodiscover.protocol.AutodiscoverProtocol">AutodiscoverProtocol</a></li>
<li><a title="exchangelib.protocol.Protocol" href="protocol.html#exchangelib.protocol.Protocol">Protocol</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.BaseProtocol.CONNECTIONS_PER_SESSION"><code class="name">var <span class="ident">CONNECTIONS_PER_SESSION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.BaseProtocol.HTTP_ADAPTER_CLS"><code class="name">var <span class="ident">HTTP_ADAPTER_CLS</span></code></dt>
<dd>
<div class="desc"><p>The built-in HTTP Adapter for urllib3.</p>
<p>Provides a general-case interface for Requests sessions to contact HTTP and
HTTPS urls by implementing the Transport Adapter interface. This class will
usually be created by the :class:<code>Session &lt;Session&gt;</code> class under the
covers.</p>
<p>:param pool_connections: The number of urllib3 connection pools to cache.
:param pool_maxsize: The maximum number of connections to save in the pool.
:param max_retries: The maximum number of retries each connection
should attempt. Note, this applies only to failed DNS lookups, socket
connections and connection timeouts, never to requests where data has
made it to the server. By default, Requests does not retry failed
connections. If you need granular control over the conditions under
which we retry a request, import urllib3's <code>Retry</code> class and pass
that instead.
:param pool_block: Whether the connection pool should block for connections.</p>
<p>Usage::</p>
<blockquote>
<blockquote>
<blockquote>
<p>import requests
s = requests.Session()
a = requests.adapters.HTTPAdapter(max_retries=3)
s.mount('http://', a)</p>
</blockquote>
</blockquote>
</blockquote></div>
</dd>
<dt id="exchangelib.BaseProtocol.MAX_SESSION_USAGE_COUNT"><code class="name">var <span class="ident">MAX_SESSION_USAGE_COUNT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.BaseProtocol.SESSION_POOLSIZE"><code class="name">var <span class="ident">SESSION_POOLSIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.BaseProtocol.TIMEOUT"><code class="name">var <span class="ident">TIMEOUT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.BaseProtocol.USERAGENT"><code class="name">var <span class="ident">USERAGENT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.BaseProtocol.close_session"><code class="name flex">
<span>def <span class="ident">close_session</span></span>(<span>session)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def close_session(session):
    session.close()
    del session</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.get_adapter"><code class="name flex">
<span>def <span class="ident">get_adapter</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_adapter(cls):
    # We want just one connection per session. No retries, since we wrap all requests in our own retry handler
    return cls.HTTP_ADAPTER_CLS(
        pool_block=True,
        pool_connections=cls.CONNECTIONS_PER_SESSION,
        pool_maxsize=cls.CONNECTIONS_PER_SESSION,
        max_retries=0,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.raw_session"><code class="name flex">
<span>def <span class="ident">raw_session</span></span>(<span>prefix, oauth2_client=None, oauth2_session_params=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def raw_session(cls, prefix, oauth2_client=None, oauth2_session_params=None):
    if oauth2_client:
        session = OAuth2Session(client=oauth2_client, **(oauth2_session_params or {}))
    else:
        session = requests.sessions.Session()
    session.headers.update(DEFAULT_HEADERS)
    session.headers[&#39;User-Agent&#39;] = cls.USERAGENT
    session.mount(prefix, adapter=cls.get_adapter())
    return session</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.BaseProtocol.auth_type"><code class="name">var <span class="ident">auth_type</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def auth_type(self):
    return self.config.auth_type</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.credentials"><code class="name">var <span class="ident">credentials</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def credentials(self):
    return self.config.credentials</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.retry_policy"><code class="name">var <span class="ident">retry_policy</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def retry_policy(self):
    return self.config.retry_policy</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.server"><code class="name">var <span class="ident">server</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def server(self):
    return self.config.server</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.service_endpoint"><code class="name">var <span class="ident">service_endpoint</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def service_endpoint(self):
    return self.config.service_endpoint</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.session_pool_size"><code class="name">var <span class="ident">session_pool_size</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def session_pool_size(self):
    return self._session_pool_size</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.BaseProtocol.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self):
    log.debug(&#39;Server %s: Closing sessions&#39;, self.server)
    while True:
        try:
            session = self._session_pool.get(block=False)
            self.close_session(session)
            self._session_pool_size -= 1
        except Empty:
            break</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.create_oauth2_session"><code class="name flex">
<span>def <span class="ident">create_oauth2_session</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_oauth2_session(self):
    if self.auth_type != OAUTH2:
        raise ValueError(
            &#39;Auth type must be %r for credentials type %s&#39; % (OAUTH2, self.credentials.__class__.__name__)
        )

    has_token = False
    scope = [&#39;https://outlook.office365.com/.default&#39;]
    session_params = {}
    token_params = {}

    if isinstance(self.credentials, OAuth2AuthorizationCodeCredentials):
        # Ask for a refresh token
        scope.append(&#39;offline_access&#39;)

        # We don&#39;t know (or need) the Microsoft tenant ID. Use
        # common/ to let Microsoft select the appropriate tenant
        # for the provided authorization code or refresh token.
        #
        # Suppress looks-like-password warning from Bandit.
        token_url = &#39;https://login.microsoftonline.com/common/oauth2/v2.0/token&#39;  # nosec

        client_params = {}
        has_token = self.credentials.access_token is not None
        if has_token:
            session_params[&#39;token&#39;] = self.credentials.access_token
        elif self.credentials.authorization_code is not None:
            token_params[&#39;code&#39;] = self.credentials.authorization_code
            self.credentials.authorization_code = None

        if self.credentials.client_id is not None and self.credentials.client_secret is not None:
            # If we&#39;re given a client ID and secret, we have enough
            # to refresh access tokens ourselves. In other cases the
            # session will raise TokenExpiredError and we&#39;ll need to
            # ask the calling application to refresh the token (that
            # covers cases where the caller doesn&#39;t have access to
            # the client secret but is working with a service that
            # can provide it refreshed tokens on a limited basis).
            session_params.update({
                &#39;auto_refresh_kwargs&#39;: {
                    &#39;client_id&#39;: self.credentials.client_id,
                    &#39;client_secret&#39;: self.credentials.client_secret,
                },
                &#39;auto_refresh_url&#39;: token_url,
                &#39;token_updater&#39;: self.credentials.on_token_auto_refreshed,
            })
        client = WebApplicationClient(self.credentials.client_id, **client_params)
    else:
        token_url = &#39;https://login.microsoftonline.com/%s/oauth2/v2.0/token&#39; % self.credentials.tenant_id
        client = BackendApplicationClient(client_id=self.credentials.client_id)

    session = self.raw_session(self.service_endpoint, oauth2_client=client, oauth2_session_params=session_params)
    if not has_token:
        # Fetch the token explicitly -- it doesn&#39;t occur implicitly
        token = session.fetch_token(token_url=token_url, client_id=self.credentials.client_id,
                                    client_secret=self.credentials.client_secret, scope=scope,
                                    timeout=self.TIMEOUT, **token_params)
        # Allow the credentials object to update its copy of the new
        # token, and give the application an opportunity to cache it
        self.credentials.on_token_auto_refreshed(token)
    session.auth = get_auth_instance(auth_type=OAUTH2, client=client)

    return session</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.create_session"><code class="name flex">
<span>def <span class="ident">create_session</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_session(self):
    if self.auth_type is None:
        raise ValueError(&#39;Cannot create session without knowing the auth type&#39;)
    if self.credentials is None:
        if self.auth_type in CREDENTIALS_REQUIRED:
            raise ValueError(&#39;Auth type %r requires credentials&#39; % self.auth_type)
        session = self.raw_session(self.service_endpoint)
        session.auth = get_auth_instance(auth_type=self.auth_type)
    else:
        with self.credentials.lock:
            if isinstance(self.credentials, OAuth2Credentials):
                session = self.create_oauth2_session()
                # Keep track of the credentials used to create this session. If
                # and when we need to renew credentials (for example, refreshing
                # an OAuth access token), this lets us easily determine whether
                # the credentials have already been refreshed in another thread
                # by the time this session tries.
                session.credentials_sig = self.credentials.sig()
            else:
                if self.auth_type == NTLM and self.credentials.type == self.credentials.EMAIL:
                    username = &#39;\\&#39; + self.credentials.username
                else:
                    username = self.credentials.username
                session = self.raw_session(self.service_endpoint)
                session.auth = get_auth_instance(auth_type=self.auth_type, username=username,
                                                 password=self.credentials.password)

    # Add some extra info
    session.session_id = sum(map(ord, str(os.urandom(100))))  # Used for debugging messages in services
    session.usage_count = 0
    session.protocol = self
    log.debug(&#39;Server %s: Created session %s&#39;, self.server, session.session_id)
    return session</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.decrease_poolsize"><code class="name flex">
<span>def <span class="ident">decrease_poolsize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decreases the session pool size in response to error messages from the server requesting to rate-limit
requests. We decrease by one session per call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decrease_poolsize(self):
    &#34;&#34;&#34;Decreases the session pool size in response to error messages from the server requesting to rate-limit
    requests. We decrease by one session per call.
    &#34;&#34;&#34;
    # Take a single session from the pool and discard it. We need to protect this with a lock while we are changing
    # the pool size variable, to avoid race conditions. We must keep at least one session in the pool.
    if self._session_pool_size &lt;= 1:
        raise SessionPoolMinSizeReached(&#39;Session pool size cannot be decreased further&#39;)
    with self._session_pool_lock:
        if self._session_pool_size &lt;= 1:
            log.debug(&#39;Session pool size was decreased in another thread&#39;)
            return
        log.warning(&#39;Server %s: Decreasing session pool size from %s to %s&#39;, self.server, self._session_pool_size,
                    self._session_pool_size - 1)
        session = self.get_session()
        self.close_session(session)
        self._session_pool_size -= 1</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.get_session"><code class="name flex">
<span>def <span class="ident">get_session</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_session(self):
    # Try to get a session from the queue. If the queue is empty, try to add one more session to the queue. If the
    # queue is already at its max, wait until a session becomes available.
    _timeout = 60  # Rate-limit messages about session starvation
    try:
        session = self._session_pool.get(block=False)
        log.debug(&#39;Server %s: Got session immediately&#39;, self.server)
    except Empty:
        try:
            self.increase_poolsize()
        except SessionPoolMaxSizeReached:
            pass
        while True:
            try:
                log.debug(&#39;Server %s: Waiting for session&#39;, self.server)
                session = self._session_pool.get(timeout=_timeout)
                break
            except Empty:
                # This is normal when we have many worker threads starving for available sessions
                log.debug(&#39;Server %s: No sessions available for %s seconds&#39;, self.server, _timeout)
    log.debug(&#39;Server %s: Got session %s&#39;, self.server, session.session_id)
    session.usage_count += 1
    return session</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.increase_poolsize"><code class="name flex">
<span>def <span class="ident">increase_poolsize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Increases the session pool size. We increase by one session per call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def increase_poolsize(self):
    &#34;&#34;&#34;Increases the session pool size. We increase by one session per call.&#34;&#34;&#34;
    # Create a single session and insert it into the pool. We need to protect this with a lock while we are changing
    # the pool size variable, to avoid race conditions. We must not exceed the pool size limit.
    if self._session_pool_size == self._session_pool_maxsize:
        raise SessionPoolMaxSizeReached(&#39;Session pool size cannot be increased further&#39;)
    with self._session_pool_lock:
        if self._session_pool_size &gt;= self._session_pool_maxsize:
            log.debug(&#39;Session pool size was increased in another thread&#39;)
            return
        log.debug(&#39;Server %s: Increasing session pool size from %s to %s&#39;, self.server, self._session_pool_size,
                  self._session_pool_size + 1)
        self._session_pool.put(self.create_session(), block=False)
        self._session_pool_size += 1</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.refresh_credentials"><code class="name flex">
<span>def <span class="ident">refresh_credentials</span></span>(<span>self, session)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refresh_credentials(self, session):
    # Credentials need to be refreshed, probably due to an OAuth
    # access token expiring. If we&#39;ve gotten here, it&#39;s because the
    # application didn&#39;t provide an OAuth client secret, so we can&#39;t
    # handle token refreshing for it.
    with self.credentials.lock:
        if self.credentials.sig() == session.credentials_sig:
            # Credentials have not been refreshed by another thread:
            # they&#39;re the same as the session was created with. If
            # this isn&#39;t the case, we can just go ahead with a new
            # session using the already-updated credentials.
            self.credentials.refresh(session=session)
    return self.renew_session(session)</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.release_session"><code class="name flex">
<span>def <span class="ident">release_session</span></span>(<span>self, session)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def release_session(self, session):
    # This should never fail, as we don&#39;t have more sessions than the queue contains
    log.debug(&#39;Server %s: Releasing session %s&#39;, self.server, session.session_id)
    if self.MAX_SESSION_USAGE_COUNT and session.usage_count &gt; self.MAX_SESSION_USAGE_COUNT:
        log.debug(&#39;Server %s: session %s usage exceeded limit. Discarding&#39;, self.server, session.session_id)
        session = self.renew_session(session)
    try:
        self._session_pool.put(session, block=False)
    except Full:
        log.debug(&#39;Server %s: Session pool was already full %s&#39;, self.server, session.session_id)</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.renew_session"><code class="name flex">
<span>def <span class="ident">renew_session</span></span>(<span>self, session)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def renew_session(self, session):
    # The session is useless. Close it completely and place a fresh session in the pool
    log.debug(&#39;Server %s: Renewing session %s&#39;, self.server, session.session_id)
    self.close_session(session)
    return self.create_session()</code></pre>
</details>
</dd>
<dt id="exchangelib.BaseProtocol.retire_session"><code class="name flex">
<span>def <span class="ident">retire_session</span></span>(<span>self, session)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def retire_session(self, session):
    # The session is useless. Close it completely and place a fresh session in the pool
    log.debug(&#39;Server %s: Retiring session %s&#39;, self.server, session.session_id)
    self.close_session(session)
    self.release_session(self.create_session())</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.Body"><code class="flex name class">
<span>class <span class="ident">Body</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper to mark the 'body' field as a complex attribute.</p>
<p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/body">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/body</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Body(str):
    &#34;&#34;&#34;Helper to mark the &#39;body&#39; field as a complex attribute.

    MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/body
    &#34;&#34;&#34;

    body_type = &#39;Text&#39;

    def __add__(self, other):
        # Make sure Body(&#39;&#39;) + &#39;foo&#39; returns a Body type
        return self.__class__(super().__add__(other))

    def __mod__(self, other):
        # Make sure Body(&#39;%s&#39;) % &#39;foo&#39; returns a Body type
        return self.__class__(super().__mod__(other))

    def format(self, *args, **kwargs):
        # Make sure Body(&#39;{}&#39;).format(&#39;foo&#39;) returns a Body type
        return self.__class__(super().format(*args, **kwargs))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.str</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.HTMLBody" href="properties.html#exchangelib.properties.HTMLBody">HTMLBody</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Body.body_type"><code class="name">var <span class="ident">body_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Body.format"><code class="name flex">
<span>def <span class="ident">format</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>S.format(<em>args, </em>*kwargs) -&gt; str</p>
<p>Return a formatted version of S, using substitutions from args and kwargs.
The substitutions are identified by braces ('{' and '}').</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format(self, *args, **kwargs):
    # Make sure Body(&#39;{}&#39;).format(&#39;foo&#39;) returns a Body type
    return self.__class__(super().format(*args, **kwargs))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.Build"><code class="flex name class">
<span>class <span class="ident">Build</span></span>
<span>(</span><span>major_version, minor_version, major_build=0, minor_build=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds methods for working with build numbers.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Build:
    &#34;&#34;&#34;Holds methods for working with build numbers.&#34;&#34;&#34;

    # List of build numbers here: https://docs.microsoft.com/en-us/exchange/new-features/build-numbers-and-release-dates
    API_VERSION_MAP = {
        8: {
            0: &#39;Exchange2007&#39;,
            1: &#39;Exchange2007_SP1&#39;,
            2: &#39;Exchange2007_SP1&#39;,
            3: &#39;Exchange2007_SP1&#39;,
        },
        14: {
            0: &#39;Exchange2010&#39;,
            1: &#39;Exchange2010_SP1&#39;,
            2: &#39;Exchange2010_SP2&#39;,
            3: &#39;Exchange2010_SP2&#39;,
        },
        15: {
            0: &#39;Exchange2013&#39;,  # Minor builds starting from 847 are Exchange2013_SP1, see api_version()
            1: &#39;Exchange2016&#39;,
            2: &#39;Exchange2019&#39;,
            20: &#39;Exchange2016&#39;,  # This is Office365. See issue #221
        },
    }

    __slots__ = &#39;major_version&#39;, &#39;minor_version&#39;, &#39;major_build&#39;, &#39;minor_build&#39;

    def __init__(self, major_version, minor_version, major_build=0, minor_build=0):
        if not isinstance(major_version, int):
            raise ValueError(&#34;&#39;major_version&#39; must be an integer&#34;)
        if not isinstance(minor_version, int):
            raise ValueError(&#34;&#39;minor_version&#39; must be an integer&#34;)
        if not isinstance(major_build, int):
            raise ValueError(&#34;&#39;major_build&#39; must be an integer&#34;)
        if not isinstance(minor_build, int):
            raise ValueError(&#34;&#39;minor_build&#39; must be an integer&#34;)
        self.major_version = major_version
        self.minor_version = minor_version
        self.major_build = major_build
        self.minor_build = minor_build
        if major_version &lt; 8:
            raise ValueError(&#34;Exchange major versions below 8 don&#39;t support EWS (%s)&#34; % self)

    @classmethod
    def from_xml(cls, elem):
        xml_elems_map = {
            &#39;major_version&#39;: &#39;MajorVersion&#39;,
            &#39;minor_version&#39;: &#39;MinorVersion&#39;,
            &#39;major_build&#39;: &#39;MajorBuildNumber&#39;,
            &#39;minor_build&#39;: &#39;MinorBuildNumber&#39;,
        }
        kwargs = {}
        for k, xml_elem in xml_elems_map.items():
            v = elem.get(xml_elem)
            if v is None:
                raise ValueError()
            kwargs[k] = int(v)  # Also raises ValueError
        return cls(**kwargs)

    @classmethod
    def from_hex_string(cls, s):
        &#34;&#34;&#34;Parse a server version string as returned in an autodiscover response. The process is described here:
        https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/serverversion-pox#example

        The string is a hex string that, converted to a 32-bit binary, encodes the server version. The rules are:
            * The first 4 bits contain the version number structure version. Can be ignored
            * The next 6 bits contain the major version number
            * The next 6 bits contain the minor version number
            * The next bit contains a flag. Can be ignored
            * The next 15 bits contain the major build number

        :param s:
        &#34;&#34;&#34;
        bin_s = &#39;{:032b}&#39;.format(int(s, 16))  # Convert string to 32-bit binary string
        major_version = int(bin_s[4:10], 2)
        minor_version = int(bin_s[10:16], 2)
        build_number = int(bin_s[17:32], 2)
        return cls(major_version=major_version, minor_version=minor_version, major_build=build_number)

    def api_version(self):
        if EXCHANGE_2013_SP1 &lt;= self &lt; EXCHANGE_2016:
            return &#39;Exchange2013_SP1&#39;
        try:
            return self.API_VERSION_MAP[self.major_version][self.minor_version]
        except KeyError:
            raise ValueError(&#39;API version for build %s is unknown&#39; % self)

    def fullname(self):
        return VERSIONS[self.api_version()][1]

    def __cmp__(self, other):
        # __cmp__ is not a magic method in Python3. We&#39;ll just use it here to implement comparison operators
        c = (self.major_version &gt; other.major_version) - (self.major_version &lt; other.major_version)
        if c != 0:
            return c
        c = (self.minor_version &gt; other.minor_version) - (self.minor_version &lt; other.minor_version)
        if c != 0:
            return c
        c = (self.major_build &gt; other.major_build) - (self.major_build &lt; other.major_build)
        if c != 0:
            return c
        return (self.minor_build &gt; other.minor_build) - (self.minor_build &lt; other.minor_build)

    def __eq__(self, other):
        return self.__cmp__(other) == 0

    def __hash__(self):
        return hash(repr(self))

    def __ne__(self, other):
        return self.__cmp__(other) != 0

    def __lt__(self, other):
        return self.__cmp__(other) &lt; 0

    def __le__(self, other):
        return self.__cmp__(other) &lt;= 0

    def __gt__(self, other):
        return self.__cmp__(other) &gt; 0

    def __ge__(self, other):
        return self.__cmp__(other) &gt;= 0

    def __str__(self):
        return &#39;%s.%s.%s.%s&#39; % (self.major_version, self.minor_version, self.major_build, self.minor_build)

    def __repr__(self):
        return self.__class__.__name__ \
               + repr((self.major_version, self.minor_version, self.major_build, self.minor_build))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Build.API_VERSION_MAP"><code class="name">var <span class="ident">API_VERSION_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.Build.from_hex_string"><code class="name flex">
<span>def <span class="ident">from_hex_string</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a server version string as returned in an autodiscover response. The process is described here:
<a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/serverversion-pox#example">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/serverversion-pox#example</a></p>
<p>The string is a hex string that, converted to a 32-bit binary, encodes the server version. The rules are:
* The first 4 bits contain the version number structure version. Can be ignored
* The next 6 bits contain the major version number
* The next 6 bits contain the minor version number
* The next bit contains a flag. Can be ignored
* The next 15 bits contain the major build number</p>
<p>:param s:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_hex_string(cls, s):
    &#34;&#34;&#34;Parse a server version string as returned in an autodiscover response. The process is described here:
    https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/serverversion-pox#example

    The string is a hex string that, converted to a 32-bit binary, encodes the server version. The rules are:
        * The first 4 bits contain the version number structure version. Can be ignored
        * The next 6 bits contain the major version number
        * The next 6 bits contain the minor version number
        * The next bit contains a flag. Can be ignored
        * The next 15 bits contain the major build number

    :param s:
    &#34;&#34;&#34;
    bin_s = &#39;{:032b}&#39;.format(int(s, 16))  # Convert string to 32-bit binary string
    major_version = int(bin_s[4:10], 2)
    minor_version = int(bin_s[10:16], 2)
    build_number = int(bin_s[17:32], 2)
    return cls(major_version=major_version, minor_version=minor_version, major_build=build_number)</code></pre>
</details>
</dd>
<dt id="exchangelib.Build.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem):
    xml_elems_map = {
        &#39;major_version&#39;: &#39;MajorVersion&#39;,
        &#39;minor_version&#39;: &#39;MinorVersion&#39;,
        &#39;major_build&#39;: &#39;MajorBuildNumber&#39;,
        &#39;minor_build&#39;: &#39;MinorBuildNumber&#39;,
    }
    kwargs = {}
    for k, xml_elem in xml_elems_map.items():
        v = elem.get(xml_elem)
        if v is None:
            raise ValueError()
        kwargs[k] = int(v)  # Also raises ValueError
    return cls(**kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Build.major_build"><code class="name">var <span class="ident">major_build</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Build.major_version"><code class="name">var <span class="ident">major_version</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Build.minor_build"><code class="name">var <span class="ident">minor_build</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Build.minor_version"><code class="name">var <span class="ident">minor_version</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Build.api_version"><code class="name flex">
<span>def <span class="ident">api_version</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def api_version(self):
    if EXCHANGE_2013_SP1 &lt;= self &lt; EXCHANGE_2016:
        return &#39;Exchange2013_SP1&#39;
    try:
        return self.API_VERSION_MAP[self.major_version][self.minor_version]
    except KeyError:
        raise ValueError(&#39;API version for build %s is unknown&#39; % self)</code></pre>
</details>
</dd>
<dt id="exchangelib.Build.fullname"><code class="name flex">
<span>def <span class="ident">fullname</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fullname(self):
    return VERSIONS[self.api_version()][1]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.CalendarItem"><code class="flex name class">
<span>class <span class="ident">CalendarItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/calendaritem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/calendaritem</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CalendarItem(Item, AcceptDeclineMixIn):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/calendaritem&#34;&#34;&#34;

    ELEMENT_NAME = &#39;CalendarItem&#39;

    uid = TextField(field_uri=&#39;calendar:UID&#39;, is_required_after_save=True, is_searchable=False)
    recurrence_id = DateTimeField(field_uri=&#39;calendar:RecurrenceId&#39;, is_read_only=True)
    start = DateOrDateTimeField(field_uri=&#39;calendar:Start&#39;, is_required=True)
    end = DateOrDateTimeField(field_uri=&#39;calendar:End&#39;, is_required=True)
    original_start = DateTimeField(field_uri=&#39;calendar:OriginalStart&#39;, is_read_only=True)
    is_all_day = BooleanField(field_uri=&#39;calendar:IsAllDayEvent&#39;, is_required=True, default=False)
    legacy_free_busy_status = FreeBusyStatusField(field_uri=&#39;calendar:LegacyFreeBusyStatus&#39;, is_required=True,
                                                  default=&#39;Busy&#39;)
    location = TextField(field_uri=&#39;calendar:Location&#39;)
    when = TextField(field_uri=&#39;calendar:When&#39;)
    is_meeting = BooleanField(field_uri=&#39;calendar:IsMeeting&#39;, is_read_only=True)
    is_cancelled = BooleanField(field_uri=&#39;calendar:IsCancelled&#39;, is_read_only=True)
    is_recurring = BooleanField(field_uri=&#39;calendar:IsRecurring&#39;, is_read_only=True)
    meeting_request_was_sent = BooleanField(field_uri=&#39;calendar:MeetingRequestWasSent&#39;, is_read_only=True)
    is_response_requested = BooleanField(field_uri=&#39;calendar:IsResponseRequested&#39;, default=None,
                                         is_required_after_save=True, is_searchable=False)
    type = ChoiceField(field_uri=&#39;calendar:CalendarItemType&#39;, choices={Choice(c) for c in CALENDAR_ITEM_CHOICES},
                       is_read_only=True)
    my_response_type = ChoiceField(field_uri=&#39;calendar:MyResponseType&#39;, choices={
            Choice(c) for c in Attendee.RESPONSE_TYPES
    }, is_read_only=True)
    organizer = MailboxField(field_uri=&#39;calendar:Organizer&#39;, is_read_only=True)
    required_attendees = AttendeesField(field_uri=&#39;calendar:RequiredAttendees&#39;, is_searchable=False)
    optional_attendees = AttendeesField(field_uri=&#39;calendar:OptionalAttendees&#39;, is_searchable=False)
    resources = AttendeesField(field_uri=&#39;calendar:Resources&#39;, is_searchable=False)
    conflicting_meeting_count = IntegerField(field_uri=&#39;calendar:ConflictingMeetingCount&#39;, is_read_only=True)
    adjacent_meeting_count = IntegerField(field_uri=&#39;calendar:AdjacentMeetingCount&#39;, is_read_only=True)
    conflicting_meetings = EWSElementListField(field_uri=&#39;calendar:ConflictingMeetings&#39;, value_cls=&#39;CalendarItem&#39;,
                                               namespace=Item.NAMESPACE, is_read_only=True)
    adjacent_meetings = EWSElementListField(field_uri=&#39;calendar:AdjacentMeetings&#39;, value_cls=&#39;CalendarItem&#39;,
                                            namespace=Item.NAMESPACE, is_read_only=True)
    duration = CharField(field_uri=&#39;calendar:Duration&#39;, is_read_only=True)
    appointment_reply_time = DateTimeField(field_uri=&#39;calendar:AppointmentReplyTime&#39;, is_read_only=True)
    appointment_sequence_number = IntegerField(field_uri=&#39;calendar:AppointmentSequenceNumber&#39;, is_read_only=True)
    appointment_state = AppointmentStateField(field_uri=&#39;calendar:AppointmentState&#39;, is_read_only=True)
    recurrence = RecurrenceField(field_uri=&#39;calendar:Recurrence&#39;, is_searchable=False)
    first_occurrence = OccurrenceField(field_uri=&#39;calendar:FirstOccurrence&#39;, value_cls=FirstOccurrence,
                                       is_read_only=True)
    last_occurrence = OccurrenceField(field_uri=&#39;calendar:LastOccurrence&#39;, value_cls=LastOccurrence,
                                      is_read_only=True)
    modified_occurrences = OccurrenceListField(field_uri=&#39;calendar:ModifiedOccurrences&#39;, value_cls=Occurrence,
                                               is_read_only=True)
    deleted_occurrences = OccurrenceListField(field_uri=&#39;calendar:DeletedOccurrences&#39;, value_cls=DeletedOccurrence,
                                              is_read_only=True)
    _meeting_timezone = TimeZoneField(field_uri=&#39;calendar:MeetingTimeZone&#39;, deprecated_from=EXCHANGE_2010,
                                      is_searchable=False)
    _start_timezone = TimeZoneField(field_uri=&#39;calendar:StartTimeZone&#39;, supported_from=EXCHANGE_2010,
                                    is_searchable=False)
    _end_timezone = TimeZoneField(field_uri=&#39;calendar:EndTimeZone&#39;, supported_from=EXCHANGE_2010,
                                  is_searchable=False)
    conference_type = EnumAsIntField(field_uri=&#39;calendar:ConferenceType&#39;, enum=CONFERENCE_TYPES, min=0,
                                     default=None, is_required_after_save=True)
    allow_new_time_proposal = BooleanField(field_uri=&#39;calendar:AllowNewTimeProposal&#39;, default=None,
                                           is_required_after_save=True, is_searchable=False)
    is_online_meeting = BooleanField(field_uri=&#39;calendar:IsOnlineMeeting&#39;, default=None,
                                     is_read_only=True)
    meeting_workspace_url = URIField(field_uri=&#39;calendar:MeetingWorkspaceUrl&#39;)
    net_show_url = URIField(field_uri=&#39;calendar:NetShowUrl&#39;)

    def occurrence(self, index):
        &#34;&#34;&#34;Get an occurrence of a recurring master by index. No query is sent to the server to actually fetch the item.
        Call refresh() on the item do do so.

        Only call this method on a recurring master.

        :param index: The index, which is 1-based

        :return The occurrence
        &#34;&#34;&#34;
        return self.__class__(
            account=self.account,
            folder=self.folder,
            _id=OccurrenceItemId(id=self.id, changekey=self.changekey, instance_index=index),
        )

    def recurring_master(self):
        &#34;&#34;&#34;Get the recurring master of an occurrence. No query is sent to the server to actually fetch the item.
        Call refresh() on the item do do so.

        Only call this method on an occurrence of a recurring master.

        :return: The master occurrence
        &#34;&#34;&#34;
        return self.__class__(
            account=self.account,
            folder=self.folder,
            _id=RecurringMasterItemId(id=self.id, changekey=self.changekey),
        )

    @classmethod
    def timezone_fields(cls):
        return [f for f in cls.FIELDS if isinstance(f, TimeZoneField)]

    def clean_timezone_fields(self, version):
        # Sets proper values on the timezone fields if they are not already set
        if self.start is None:
            start_tz = None
        elif type(self.start) in (EWSDate, datetime.date):
            start_tz = self.account.default_timezone
        else:
            start_tz = self.start.tzinfo
        if self.end is None:
            end_tz = None
        elif type(self.end) in (EWSDate, datetime.date):
            end_tz = self.account.default_timezone
        else:
            end_tz = self.end.tzinfo
        if version.build &lt; EXCHANGE_2010:
            if self._meeting_timezone is None:
                self._meeting_timezone = start_tz
            self._start_timezone = None
            self._end_timezone = None
        else:
            self._meeting_timezone = None
            if self._start_timezone is None:
                self._start_timezone = start_tz
            if self._end_timezone is None:
                self._end_timezone = end_tz

    def clean(self, version=None):
        super().clean(version=version)
        if self.start and self.end and self.end &lt; self.start:
            raise ValueError(&#34;&#39;end&#39; must be greater than &#39;start&#39; (%s -&gt; %s)&#34; % (self.start, self.end))
        if version:
            self.clean_timezone_fields(version=version)

    def cancel(self, **kwargs):
        return CancelCalendarItem(
            account=self.account,
            reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey),
            **kwargs
        ).send()

    def _update_fieldnames(self):
        update_fields = super()._update_fieldnames()
        if self.type == OCCURRENCE:
            # Some CalendarItem fields cannot be updated when the item is an occurrence. The values are empty when we
            # receive them so would have been updated because they are set to None.
            update_fields.remove(&#39;recurrence&#39;)
            update_fields.remove(&#39;uid&#39;)
        return update_fields

    @classmethod
    def from_xml(cls, elem, account):
        item = super().from_xml(elem=elem, account=account)
        # EWS returns the start and end values as a datetime regardless of the is_all_day status. Convert to date if
        # applicable.
        if not item.is_all_day:
            return item
        for field_name in (&#39;start&#39;, &#39;end&#39;):
            val = getattr(item, field_name)
            if val is None:
                continue
            # Return just the date part of the value. Subtract 1 day from the date if this is the end field. This is
            # the inverse of what we do in .to_xml(). Convert to the local timezone before getting the date.
            if field_name == &#39;end&#39;:
                val -= datetime.timedelta(days=1)
            tz = getattr(item, &#39;_%s_timezone&#39; % field_name)
            setattr(item, field_name, val.astimezone(tz).date())
        return item

    def tz_field_for_field_name(self, field_name):
        meeting_tz_field, start_tz_field, end_tz_field = CalendarItem.timezone_fields()
        if self.account.version.build &lt; EXCHANGE_2010:
            return meeting_tz_field
        if field_name == &#39;start&#39;:
            return start_tz_field
        if field_name == &#39;end&#39;:
            return end_tz_field
        raise ValueError(&#39;Unsupported field_name&#39;)

    def date_to_datetime(self, field_name):
        # EWS always expects a datetime. If we have a date value, then convert it to datetime in the local
        # timezone. Additionally, if this the end field, add 1 day to the date. We could add 12 hours to both
        # start and end values and let EWS apply its logic, but that seems hacky.
        value = getattr(self, field_name)
        tz = getattr(self, self.tz_field_for_field_name(field_name).name)
        value = EWSDateTime.combine(value, datetime.time(0, 0)).replace(tzinfo=tz)
        if field_name == &#39;end&#39;:
            value += datetime.timedelta(days=1)
        return value

    def to_xml(self, version):
        # EWS has some special logic related to all-day start and end values. Non-midnight start values are pushed to
        # the previous midnight. Non-midnight end values are pushed to the following midnight. Midnight in this context
        # refers to midnight in the local timezone. See
        #
        # https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/how-to-create-all-day-events-by-using-ews-in-exchange
        #
        elem = super().to_xml(version=version)
        if not self.is_all_day:
            return elem
        for field_name in (&#39;start&#39;, &#39;end&#39;):
            value = getattr(self, field_name)
            if value is None:
                continue
            if type(value) in (EWSDate, datetime.date):
                # EWS always expects a datetime
                value = self.date_to_datetime(field_name=field_name)
                # We already generated an XML element for this field, but it contains a plain date at this point, which
                # is invalid. Replace the value.
                field = self.get_field_by_fieldname(field_name)
                set_xml_value(elem=elem.find(field.response_tag()), value=value, version=version)
        return elem</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
<li><a title="exchangelib.items.calendar_item.AcceptDeclineMixIn" href="items/calendar_item.html#exchangelib.items.calendar_item.AcceptDeclineMixIn">AcceptDeclineMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.CalendarItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.CalendarItem.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem, account):
    item = super().from_xml(elem=elem, account=account)
    # EWS returns the start and end values as a datetime regardless of the is_all_day status. Convert to date if
    # applicable.
    if not item.is_all_day:
        return item
    for field_name in (&#39;start&#39;, &#39;end&#39;):
        val = getattr(item, field_name)
        if val is None:
            continue
        # Return just the date part of the value. Subtract 1 day from the date if this is the end field. This is
        # the inverse of what we do in .to_xml(). Convert to the local timezone before getting the date.
        if field_name == &#39;end&#39;:
            val -= datetime.timedelta(days=1)
        tz = getattr(item, &#39;_%s_timezone&#39; % field_name)
        setattr(item, field_name, val.astimezone(tz).date())
    return item</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.timezone_fields"><code class="name flex">
<span>def <span class="ident">timezone_fields</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def timezone_fields(cls):
    return [f for f in cls.FIELDS if isinstance(f, TimeZoneField)]</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.CalendarItem.adjacent_meeting_count"><code class="name">var <span class="ident">adjacent_meeting_count</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.adjacent_meetings"><code class="name">var <span class="ident">adjacent_meetings</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.allow_new_time_proposal"><code class="name">var <span class="ident">allow_new_time_proposal</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.appointment_reply_time"><code class="name">var <span class="ident">appointment_reply_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.appointment_sequence_number"><code class="name">var <span class="ident">appointment_sequence_number</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.appointment_state"><code class="name">var <span class="ident">appointment_state</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.conference_type"><code class="name">var <span class="ident">conference_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.conflicting_meeting_count"><code class="name">var <span class="ident">conflicting_meeting_count</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.conflicting_meetings"><code class="name">var <span class="ident">conflicting_meetings</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.deleted_occurrences"><code class="name">var <span class="ident">deleted_occurrences</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.duration"><code class="name">var <span class="ident">duration</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.first_occurrence"><code class="name">var <span class="ident">first_occurrence</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.is_all_day"><code class="name">var <span class="ident">is_all_day</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.is_cancelled"><code class="name">var <span class="ident">is_cancelled</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.is_meeting"><code class="name">var <span class="ident">is_meeting</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.is_online_meeting"><code class="name">var <span class="ident">is_online_meeting</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.is_recurring"><code class="name">var <span class="ident">is_recurring</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.is_response_requested"><code class="name">var <span class="ident">is_response_requested</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.last_occurrence"><code class="name">var <span class="ident">last_occurrence</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.legacy_free_busy_status"><code class="name">var <span class="ident">legacy_free_busy_status</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.location"><code class="name">var <span class="ident">location</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.meeting_request_was_sent"><code class="name">var <span class="ident">meeting_request_was_sent</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.meeting_workspace_url"><code class="name">var <span class="ident">meeting_workspace_url</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.modified_occurrences"><code class="name">var <span class="ident">modified_occurrences</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.my_response_type"><code class="name">var <span class="ident">my_response_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.net_show_url"><code class="name">var <span class="ident">net_show_url</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.optional_attendees"><code class="name">var <span class="ident">optional_attendees</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.organizer"><code class="name">var <span class="ident">organizer</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.original_start"><code class="name">var <span class="ident">original_start</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.recurrence"><code class="name">var <span class="ident">recurrence</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.recurrence_id"><code class="name">var <span class="ident">recurrence_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.required_attendees"><code class="name">var <span class="ident">required_attendees</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.start"><code class="name">var <span class="ident">start</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.type"><code class="name">var <span class="ident">type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.uid"><code class="name">var <span class="ident">uid</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CalendarItem.when"><code class="name">var <span class="ident">when</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.CalendarItem.cancel"><code class="name flex">
<span>def <span class="ident">cancel</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cancel(self, **kwargs):
    return CancelCalendarItem(
        account=self.account,
        reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey),
        **kwargs
    ).send()</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, version=None):
    super().clean(version=version)
    if self.start and self.end and self.end &lt; self.start:
        raise ValueError(&#34;&#39;end&#39; must be greater than &#39;start&#39; (%s -&gt; %s)&#34; % (self.start, self.end))
    if version:
        self.clean_timezone_fields(version=version)</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.clean_timezone_fields"><code class="name flex">
<span>def <span class="ident">clean_timezone_fields</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_timezone_fields(self, version):
    # Sets proper values on the timezone fields if they are not already set
    if self.start is None:
        start_tz = None
    elif type(self.start) in (EWSDate, datetime.date):
        start_tz = self.account.default_timezone
    else:
        start_tz = self.start.tzinfo
    if self.end is None:
        end_tz = None
    elif type(self.end) in (EWSDate, datetime.date):
        end_tz = self.account.default_timezone
    else:
        end_tz = self.end.tzinfo
    if version.build &lt; EXCHANGE_2010:
        if self._meeting_timezone is None:
            self._meeting_timezone = start_tz
        self._start_timezone = None
        self._end_timezone = None
    else:
        self._meeting_timezone = None
        if self._start_timezone is None:
            self._start_timezone = start_tz
        if self._end_timezone is None:
            self._end_timezone = end_tz</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.date_to_datetime"><code class="name flex">
<span>def <span class="ident">date_to_datetime</span></span>(<span>self, field_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def date_to_datetime(self, field_name):
    # EWS always expects a datetime. If we have a date value, then convert it to datetime in the local
    # timezone. Additionally, if this the end field, add 1 day to the date. We could add 12 hours to both
    # start and end values and let EWS apply its logic, but that seems hacky.
    value = getattr(self, field_name)
    tz = getattr(self, self.tz_field_for_field_name(field_name).name)
    value = EWSDateTime.combine(value, datetime.time(0, 0)).replace(tzinfo=tz)
    if field_name == &#39;end&#39;:
        value += datetime.timedelta(days=1)
    return value</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.occurrence"><code class="name flex">
<span>def <span class="ident">occurrence</span></span>(<span>self, index)</span>
</code></dt>
<dd>
<div class="desc"><p>Get an occurrence of a recurring master by index. No query is sent to the server to actually fetch the item.
Call refresh() on the item do do so.</p>
<p>Only call this method on a recurring master.</p>
<p>:param index: The index, which is 1-based</p>
<p>:return The occurrence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def occurrence(self, index):
    &#34;&#34;&#34;Get an occurrence of a recurring master by index. No query is sent to the server to actually fetch the item.
    Call refresh() on the item do do so.

    Only call this method on a recurring master.

    :param index: The index, which is 1-based

    :return The occurrence
    &#34;&#34;&#34;
    return self.__class__(
        account=self.account,
        folder=self.folder,
        _id=OccurrenceItemId(id=self.id, changekey=self.changekey, instance_index=index),
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.recurring_master"><code class="name flex">
<span>def <span class="ident">recurring_master</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the recurring master of an occurrence. No query is sent to the server to actually fetch the item.
Call refresh() on the item do do so.</p>
<p>Only call this method on an occurrence of a recurring master.</p>
<p>:return: The master occurrence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def recurring_master(self):
    &#34;&#34;&#34;Get the recurring master of an occurrence. No query is sent to the server to actually fetch the item.
    Call refresh() on the item do do so.

    Only call this method on an occurrence of a recurring master.

    :return: The master occurrence
    &#34;&#34;&#34;
    return self.__class__(
        account=self.account,
        folder=self.folder,
        _id=RecurringMasterItemId(id=self.id, changekey=self.changekey),
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.to_xml"><code class="name flex">
<span>def <span class="ident">to_xml</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xml(self, version):
    # EWS has some special logic related to all-day start and end values. Non-midnight start values are pushed to
    # the previous midnight. Non-midnight end values are pushed to the following midnight. Midnight in this context
    # refers to midnight in the local timezone. See
    #
    # https://docs.microsoft.com/en-us/exchange/client-developer/exchange-web-services/how-to-create-all-day-events-by-using-ews-in-exchange
    #
    elem = super().to_xml(version=version)
    if not self.is_all_day:
        return elem
    for field_name in (&#39;start&#39;, &#39;end&#39;):
        value = getattr(self, field_name)
        if value is None:
            continue
        if type(value) in (EWSDate, datetime.date):
            # EWS always expects a datetime
            value = self.date_to_datetime(field_name=field_name)
            # We already generated an XML element for this field, but it contains a plain date at this point, which
            # is invalid. Replace the value.
            field = self.get_field_by_fieldname(field_name)
            set_xml_value(elem=elem.find(field.response_tag()), value=value, version=version)
    return elem</code></pre>
</details>
</dd>
<dt id="exchangelib.CalendarItem.tz_field_for_field_name"><code class="name flex">
<span>def <span class="ident">tz_field_for_field_name</span></span>(<span>self, field_name)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tz_field_for_field_name(self, field_name):
    meeting_tz_field, start_tz_field, end_tz_field = CalendarItem.timezone_fields()
    if self.account.version.build &lt; EXCHANGE_2010:
        return meeting_tz_field
    if field_name == &#39;start&#39;:
        return start_tz_field
    if field_name == &#39;end&#39;:
        return end_tz_field
    raise ValueError(&#39;Unsupported field_name&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.item.Item.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.item.Item.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attach" href="items/item.html#exchangelib.items.item.Item.attach">attach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.item.Item.detach" href="items/item.html#exchangelib.items.item.Item.detach">detach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.item.Item.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.item.Item.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.item.Item.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.CancelCalendarItem"><code class="flex name class">
<span>class <span class="ident">CancelCalendarItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/cancelcalendaritem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/cancelcalendaritem</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CancelCalendarItem(BaseReplyItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/cancelcalendaritem&#34;&#34;&#34;

    ELEMENT_NAME = &#39;CancelCalendarItem&#39;
    author_idx = BaseReplyItem.FIELDS.index_by_name(&#39;author&#39;)
    FIELDS = BaseReplyItem.FIELDS[:author_idx] + BaseReplyItem.FIELDS[author_idx + 1:]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.CancelCalendarItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CancelCalendarItem.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.CancelCalendarItem.author_idx"><code class="name">var <span class="ident">author_idx</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.base.BaseReplyItem.account" href="items/base.html#exchangelib.items.base.BaseReplyItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.save" href="items/base.html#exchangelib.items.base.BaseReplyItem.save">save</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Configuration"><code class="flex name class">
<span>class <span class="ident">Configuration</span></span>
<span>(</span><span>credentials=None, server=None, service_endpoint=None, auth_type=None, version=None, retry_policy=None, max_connections=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains information needed to create an authenticated connection to an EWS endpoint.</p>
<p>The 'credentials' argument contains the credentials needed to authenticate with the server. Multiple credentials
implementations are available in 'exchangelib.credentials'.</p>
<p>config = Configuration(credentials=Credentials('john@example.com', 'MY_SECRET'), &hellip;)</p>
<p>The 'server' and 'service_endpoint' arguments are mutually exclusive. The former must contain only a domain name,
the latter a full URL:</p>
<pre><code>config = Configuration(server='example.com', ...)
config = Configuration(service_endpoint='https://mail.example.com/EWS/Exchange.asmx', ...)
</code></pre>
<p>If you know which authentication type the server uses, you add that as a hint in 'auth_type'. Likewise, you can
add the server version as a hint. This allows to skip the auth type and version guessing routines:</p>
<pre><code>config = Configuration(auth_type=NTLM, ...)
config = Configuration(version=Version(build=Build(15, 1, 2, 3)), ...)
</code></pre>
<p>You can use 'retry_policy' to define a custom retry policy for handling server connection failures:</p>
<pre><code>config = Configuration(retry_policy=FaultTolerance(max_wait=3600), ...)
</code></pre>
<p>'max_connections' defines the max number of connections allowed for this server. This may be restricted by
policies on the Exchange server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Configuration:
    &#34;&#34;&#34;Contains information needed to create an authenticated connection to an EWS endpoint.

    The &#39;credentials&#39; argument contains the credentials needed to authenticate with the server. Multiple credentials
    implementations are available in &#39;exchangelib.credentials&#39;.

    config = Configuration(credentials=Credentials(&#39;john@example.com&#39;, &#39;MY_SECRET&#39;), ...)

    The &#39;server&#39; and &#39;service_endpoint&#39; arguments are mutually exclusive. The former must contain only a domain name,
    the latter a full URL:

        config = Configuration(server=&#39;example.com&#39;, ...)
        config = Configuration(service_endpoint=&#39;https://mail.example.com/EWS/Exchange.asmx&#39;, ...)

    If you know which authentication type the server uses, you add that as a hint in &#39;auth_type&#39;. Likewise, you can
    add the server version as a hint. This allows to skip the auth type and version guessing routines:

        config = Configuration(auth_type=NTLM, ...)
        config = Configuration(version=Version(build=Build(15, 1, 2, 3)), ...)

    You can use &#39;retry_policy&#39; to define a custom retry policy for handling server connection failures:

        config = Configuration(retry_policy=FaultTolerance(max_wait=3600), ...)

    &#39;max_connections&#39; defines the max number of connections allowed for this server. This may be restricted by
    policies on the Exchange server.
    &#34;&#34;&#34;

    def __init__(self, credentials=None, server=None, service_endpoint=None, auth_type=None, version=None,
                 retry_policy=None, max_connections=None):
        if not isinstance(credentials, (BaseCredentials, type(None))):
            raise ValueError(&#34;&#39;credentials&#39; %r must be a Credentials instance&#34; % credentials)
        if isinstance(credentials, OAuth2Credentials) and auth_type is None:
            # This type of credentials *must* use the OAuth auth type
            auth_type = OAUTH2
        if server and service_endpoint:
            raise AttributeError(&#34;Only one of &#39;server&#39; or &#39;service_endpoint&#39; must be provided&#34;)
        if auth_type is not None and auth_type not in AUTH_TYPE_MAP:
            raise ValueError(&#34;&#39;auth_type&#39; %r must be one of %s&#34;
                             % (auth_type, &#39;, &#39;.join(&#34;&#39;%s&#39;&#34; % k for k in sorted(AUTH_TYPE_MAP))))
        if not retry_policy:
            retry_policy = FailFast()
        if not isinstance(version, (Version, type(None))):
            raise ValueError(&#34;&#39;version&#39; %r must be a Version instance&#34; % version)
        if not isinstance(retry_policy, RetryPolicy):
            raise ValueError(&#34;&#39;retry_policy&#39; %r must be a RetryPolicy instance&#34; % retry_policy)
        if not isinstance(max_connections, (int, type(None))):
            raise ValueError(&#34;&#39;max_connections&#39; must be an integer&#34;)
        self._credentials = credentials
        if server:
            self.service_endpoint = &#39;https://%s/EWS/Exchange.asmx&#39; % server
        else:
            self.service_endpoint = service_endpoint
        self.auth_type = auth_type
        self.version = version
        self.retry_policy = retry_policy
        self.max_connections = max_connections

    @property
    def credentials(self):
        # Do not update credentials from this class. Instead, do it from Protocol
        return self._credentials

    @threaded_cached_property
    def server(self):
        if not self.service_endpoint:
            return None
        return split_url(self.service_endpoint)[1]

    def __repr__(self):
        return self.__class__.__name__ + &#39;(%s)&#39; % &#39;, &#39;.join(&#39;%s=%r&#39; % (k, getattr(self, k)) for k in (
            &#39;credentials&#39;, &#39;service_endpoint&#39;, &#39;auth_type&#39;, &#39;version&#39;, &#39;retry_policy&#39;
        ))</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Configuration.credentials"><code class="name">var <span class="ident">credentials</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def credentials(self):
    # Do not update credentials from this class. Instead, do it from Protocol
    return self._credentials</code></pre>
</details>
</dd>
<dt id="exchangelib.Configuration.server"><code class="name">var <span class="ident">server</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.Contact"><code class="flex name class">
<span>class <span class="ident">Contact</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/contact">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/contact</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Contact(Item):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/contact&#34;&#34;&#34;

    ELEMENT_NAME = &#39;Contact&#39;

    file_as = TextField(field_uri=&#39;contacts:FileAs&#39;)
    file_as_mapping = ChoiceField(field_uri=&#39;contacts:FileAsMapping&#39;, choices={
        Choice(&#39;None&#39;), Choice(&#39;LastCommaFirst&#39;), Choice(&#39;FirstSpaceLast&#39;), Choice(&#39;Company&#39;),
        Choice(&#39;LastCommaFirstCompany&#39;), Choice(&#39;CompanyLastFirst&#39;), Choice(&#39;LastFirst&#39;),
        Choice(&#39;LastFirstCompany&#39;), Choice(&#39;CompanyLastCommaFirst&#39;), Choice(&#39;LastFirstSuffix&#39;),
        Choice(&#39;LastSpaceFirstCompany&#39;), Choice(&#39;CompanyLastSpaceFirst&#39;), Choice(&#39;LastSpaceFirst&#39;),
        Choice(&#39;DisplayName&#39;), Choice(&#39;FirstName&#39;), Choice(&#39;LastFirstMiddleSuffix&#39;), Choice(&#39;LastName&#39;),
        Choice(&#39;Empty&#39;),
    })
    display_name = TextField(field_uri=&#39;contacts:DisplayName&#39;, is_required=True)
    given_name = CharField(field_uri=&#39;contacts:GivenName&#39;)
    initials = TextField(field_uri=&#39;contacts:Initials&#39;)
    middle_name = CharField(field_uri=&#39;contacts:MiddleName&#39;)
    nickname = TextField(field_uri=&#39;contacts:Nickname&#39;)
    complete_name = EWSElementField(field_uri=&#39;contacts:CompleteName&#39;, value_cls=CompleteName, is_read_only=True)
    company_name = TextField(field_uri=&#39;contacts:CompanyName&#39;)
    email_addresses = EmailAddressesField(field_uri=&#39;contacts:EmailAddress&#39;)
    physical_addresses = PhysicalAddressField(field_uri=&#39;contacts:PhysicalAddress&#39;)
    phone_numbers = PhoneNumberField(field_uri=&#39;contacts:PhoneNumber&#39;)
    assistant_name = TextField(field_uri=&#39;contacts:AssistantName&#39;)
    birthday = DateTimeBackedDateField(field_uri=&#39;contacts:Birthday&#39;, default_time=datetime.time(11, 59))
    business_homepage = URIField(field_uri=&#39;contacts:BusinessHomePage&#39;)
    children = TextListField(field_uri=&#39;contacts:Children&#39;)
    companies = TextListField(field_uri=&#39;contacts:Companies&#39;, is_searchable=False)
    contact_source = ChoiceField(field_uri=&#39;contacts:ContactSource&#39;, choices={
        Choice(&#39;Store&#39;), Choice(&#39;ActiveDirectory&#39;)
    }, is_read_only=True)
    department = TextField(field_uri=&#39;contacts:Department&#39;)
    generation = TextField(field_uri=&#39;contacts:Generation&#39;)
    im_addresses = CharField(field_uri=&#39;contacts:ImAddresses&#39;, is_read_only=True)
    job_title = TextField(field_uri=&#39;contacts:JobTitle&#39;)
    manager = TextField(field_uri=&#39;contacts:Manager&#39;)
    mileage = TextField(field_uri=&#39;contacts:Mileage&#39;)
    office = TextField(field_uri=&#39;contacts:OfficeLocation&#39;)
    postal_address_index = ChoiceField(field_uri=&#39;contacts:PostalAddressIndex&#39;, choices={
        Choice(&#39;Business&#39;), Choice(&#39;Home&#39;), Choice(&#39;Other&#39;), Choice(&#39;None&#39;)
    }, default=&#39;None&#39;, is_required_after_save=True)
    profession = TextField(field_uri=&#39;contacts:Profession&#39;)
    spouse_name = TextField(field_uri=&#39;contacts:SpouseName&#39;)
    surname = CharField(field_uri=&#39;contacts:Surname&#39;)
    wedding_anniversary = DateTimeBackedDateField(field_uri=&#39;contacts:WeddingAnniversary&#39;,
                                                  default_time=datetime.time(11, 59))
    has_picture = BooleanField(field_uri=&#39;contacts:HasPicture&#39;, supported_from=EXCHANGE_2010, is_read_only=True)
    phonetic_full_name = TextField(field_uri=&#39;contacts:PhoneticFullName&#39;, supported_from=EXCHANGE_2010_SP2,
                                   is_read_only=True)
    phonetic_first_name = TextField(field_uri=&#39;contacts:PhoneticFirstName&#39;, supported_from=EXCHANGE_2010_SP2,
                                    is_read_only=True)
    phonetic_last_name = TextField(field_uri=&#39;contacts:PhoneticLastName&#39;, supported_from=EXCHANGE_2010_SP2,
                                   is_read_only=True)
    email_alias = EmailAddressField(field_uri=&#39;contacts:Alias&#39;, is_read_only=True,
                                    supported_from=EXCHANGE_2010_SP2)
    # &#39;notes&#39; is documented in MSDN but apparently unused. Writing to it raises ErrorInvalidPropertyRequest. OWA
    # put entries into the &#39;notes&#39; form field into the &#39;body&#39; field.
    notes = CharField(field_uri=&#39;contacts:Notes&#39;, supported_from=EXCHANGE_2010_SP2, is_read_only=True)
    # &#39;photo&#39; is documented in MSDN but apparently unused. Writing to it raises ErrorInvalidPropertyRequest. OWA
    # adds photos as FileAttachments on the contact item (with &#39;is_contact_photo=True&#39;), which automatically flips
    # the &#39;has_picture&#39; field.
    photo = Base64Field(field_uri=&#39;contacts:Photo&#39;, supported_from=EXCHANGE_2010_SP2, is_read_only=True)
    user_smime_certificate = Base64Field(field_uri=&#39;contacts:UserSMIMECertificate&#39;, supported_from=EXCHANGE_2010_SP2,
                                         is_read_only=True)
    ms_exchange_certificate = Base64Field(field_uri=&#39;contacts:MSExchangeCertificate&#39;, supported_from=EXCHANGE_2010_SP2,
                                          is_read_only=True)
    directory_id = TextField(field_uri=&#39;contacts:DirectoryId&#39;, supported_from=EXCHANGE_2010_SP2, is_read_only=True)
    manager_mailbox = MailboxField(field_uri=&#39;contacts:ManagerMailbox&#39;, supported_from=EXCHANGE_2010_SP2,
                                   is_read_only=True)
    direct_reports = MailboxListField(field_uri=&#39;contacts:DirectReports&#39;, supported_from=EXCHANGE_2010_SP2,
                                      is_read_only=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Contact.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Contact.assistant_name"><code class="name">var <span class="ident">assistant_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.birthday"><code class="name">var <span class="ident">birthday</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.business_homepage"><code class="name">var <span class="ident">business_homepage</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.companies"><code class="name">var <span class="ident">companies</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.company_name"><code class="name">var <span class="ident">company_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.complete_name"><code class="name">var <span class="ident">complete_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.contact_source"><code class="name">var <span class="ident">contact_source</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.department"><code class="name">var <span class="ident">department</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.direct_reports"><code class="name">var <span class="ident">direct_reports</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.directory_id"><code class="name">var <span class="ident">directory_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.display_name"><code class="name">var <span class="ident">display_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.email_addresses"><code class="name">var <span class="ident">email_addresses</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.email_alias"><code class="name">var <span class="ident">email_alias</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.file_as"><code class="name">var <span class="ident">file_as</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.file_as_mapping"><code class="name">var <span class="ident">file_as_mapping</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.generation"><code class="name">var <span class="ident">generation</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.given_name"><code class="name">var <span class="ident">given_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.has_picture"><code class="name">var <span class="ident">has_picture</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.im_addresses"><code class="name">var <span class="ident">im_addresses</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.initials"><code class="name">var <span class="ident">initials</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.job_title"><code class="name">var <span class="ident">job_title</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.manager"><code class="name">var <span class="ident">manager</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.manager_mailbox"><code class="name">var <span class="ident">manager_mailbox</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.middle_name"><code class="name">var <span class="ident">middle_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.mileage"><code class="name">var <span class="ident">mileage</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.ms_exchange_certificate"><code class="name">var <span class="ident">ms_exchange_certificate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.nickname"><code class="name">var <span class="ident">nickname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.notes"><code class="name">var <span class="ident">notes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.office"><code class="name">var <span class="ident">office</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.phone_numbers"><code class="name">var <span class="ident">phone_numbers</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.phonetic_first_name"><code class="name">var <span class="ident">phonetic_first_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.phonetic_full_name"><code class="name">var <span class="ident">phonetic_full_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.phonetic_last_name"><code class="name">var <span class="ident">phonetic_last_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.photo"><code class="name">var <span class="ident">photo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.physical_addresses"><code class="name">var <span class="ident">physical_addresses</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.postal_address_index"><code class="name">var <span class="ident">postal_address_index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.profession"><code class="name">var <span class="ident">profession</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.spouse_name"><code class="name">var <span class="ident">spouse_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.surname"><code class="name">var <span class="ident">surname</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.user_smime_certificate"><code class="name">var <span class="ident">user_smime_certificate</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Contact.wedding_anniversary"><code class="name">var <span class="ident">wedding_anniversary</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.item.Item.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.item.Item.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attach" href="items/item.html#exchangelib.items.item.Item.attach">attach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.item.Item.detach" href="items/item.html#exchangelib.items.item.Item.detach">detach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.item.Item.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.item.Item.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.item.Item.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Credentials"><code class="flex name class">
<span>class <span class="ident">Credentials</span></span>
<span>(</span><span>username, password)</span>
</code></dt>
<dd>
<div class="desc"><p>Keeps login info the way Exchange likes it.</p>
<p>Usernames for authentication are of one of these forms:
* PrimarySMTPAddress
* WINDOMAIN\username
* User Principal Name (UPN)
password: Clear-text password</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Credentials(BaseCredentials):
    r&#34;&#34;&#34;Keeps login info the way Exchange likes it.

    Usernames for authentication are of one of these forms:
    * PrimarySMTPAddress
    * WINDOMAIN\username
    * User Principal Name (UPN)
      password: Clear-text password
    &#34;&#34;&#34;

    EMAIL = &#39;email&#39;
    DOMAIN = &#39;domain&#39;
    UPN = &#39;upn&#39;

    def __init__(self, username, password):
        super().__init__()
        if username.count(&#39;@&#39;) == 1:
            self.type = self.EMAIL
        elif username.count(&#39;\\&#39;) == 1:
            self.type = self.DOMAIN
        else:
            self.type = self.UPN
        self.username = username
        self.password = password

    def refresh(self, session):
        pass

    def __repr__(self):
        return self.__class__.__name__ + repr((self.username, &#39;********&#39;))

    def __str__(self):
        return self.username</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.BaseCredentials" href="credentials.html#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Credentials.DOMAIN"><code class="name">var <span class="ident">DOMAIN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Credentials.EMAIL"><code class="name">var <span class="ident">EMAIL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Credentials.UPN"><code class="name">var <span class="ident">UPN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.credentials.BaseCredentials" href="credentials.html#exchangelib.credentials.BaseCredentials">BaseCredentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.BaseCredentials.refresh" href="credentials.html#exchangelib.credentials.BaseCredentials.refresh">refresh</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.DLMailbox"><code class="flex name class">
<span>class <span class="ident">DLMailbox</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like Mailbox, but creates elements in the 'messages' namespace when sending requests.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DLMailbox(Mailbox):
    &#34;&#34;&#34;Like Mailbox, but creates elements in the &#39;messages&#39; namespace when sending requests.&#34;&#34;&#34;

    NAMESPACE = MNS</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.Mailbox" href="properties.html#exchangelib.properties.Mailbox">Mailbox</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.DLMailbox.NAMESPACE"><code class="name">var <span class="ident">NAMESPACE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.Mailbox" href="properties.html#exchangelib.properties.Mailbox">Mailbox</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.Mailbox.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.DeclineItem"><code class="flex name class">
<span>class <span class="ident">DeclineItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/declineitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/declineitem</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeclineItem(BaseMeetingReplyItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/declineitem&#34;&#34;&#34;

    ELEMENT_NAME = &#39;DeclineItem&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem" href="items/calendar_item.html#exchangelib.items.calendar_item.BaseMeetingReplyItem">BaseMeetingReplyItem</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.DeclineItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem" href="items/calendar_item.html#exchangelib.items.calendar_item.BaseMeetingReplyItem">BaseMeetingReplyItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.DistributionList"><code class="flex name class">
<span>class <span class="ident">DistributionList</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/distributionlist">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/distributionlist</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DistributionList(Item):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/distributionlist&#34;&#34;&#34;

    ELEMENT_NAME = &#39;DistributionList&#39;

    display_name = CharField(field_uri=&#39;contacts:DisplayName&#39;, is_required=True)
    file_as = CharField(field_uri=&#39;contacts:FileAs&#39;, is_read_only=True)
    contact_source = ChoiceField(field_uri=&#39;contacts:ContactSource&#39;, choices={
        Choice(&#39;Store&#39;), Choice(&#39;ActiveDirectory&#39;)
    }, is_read_only=True)
    members = MemberListField(field_uri=&#39;distributionlist:Members&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.DistributionList.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.DistributionList.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.DistributionList.contact_source"><code class="name">var <span class="ident">contact_source</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.DistributionList.display_name"><code class="name">var <span class="ident">display_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.DistributionList.file_as"><code class="name">var <span class="ident">file_as</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.DistributionList.members"><code class="name">var <span class="ident">members</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.item.Item.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.item.Item.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attach" href="items/item.html#exchangelib.items.item.Item.attach">attach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.item.Item.detach" href="items/item.html#exchangelib.items.item.Item.detach">detach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.item.Item.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.item.Item.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.item.Item.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.EWSDate"><code class="flex name class">
<span>class <span class="ident">EWSDate</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends the normal date implementation to satisfy EWS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EWSDate(datetime.date):
    &#34;&#34;&#34;Extends the normal date implementation to satisfy EWS.&#34;&#34;&#34;

    __slots__ = &#39;_year&#39;, &#39;_month&#39;, &#39;_day&#39;, &#39;_hashcode&#39;

    def ewsformat(self):
        &#34;&#34;&#34;ISO 8601 format to satisfy xs:date as interpreted by EWS. Example: 2009-01-15.&#34;&#34;&#34;
        return self.isoformat()

    def __add__(self, other):
        dt = super().__add__(other)
        if isinstance(dt, self.__class__):
            return dt
        return self.from_date(dt)  # We want to return EWSDate objects

    def __iadd__(self, other):
        return self + other

    def __sub__(self, other):
        dt = super().__sub__(other)
        if isinstance(dt, datetime.timedelta):
            return dt
        if isinstance(dt, self.__class__):
            return dt
        return self.from_date(dt)  # We want to return EWSDate objects

    def __isub__(self, other):
        return self - other

    @classmethod
    def fromordinal(cls, n):
        dt = super().fromordinal(n)
        if isinstance(dt, cls):
            return dt
        return cls.from_date(dt)  # We want to return EWSDate objects

    @classmethod
    def from_date(cls, d):
        if type(d) is not datetime.date:
            raise ValueError(&#34;%r must be a date instance&#34; % d)
        return cls(d.year, d.month, d.day)

    @classmethod
    def from_string(cls, date_string):
        # Sometimes, we&#39;ll receive a date string with timezone information. Not very useful.
        if date_string.endswith(&#39;Z&#39;):
            date_fmt = &#39;%Y-%m-%dZ&#39;
        elif &#39;:&#39; in date_string:
            if &#39;+&#39; in date_string:
                date_fmt = &#39;%Y-%m-%d+%H:%M&#39;
            else:
                date_fmt = &#39;%Y-%m-%d-%H:%M&#39;
        else:
            date_fmt = &#39;%Y-%m-%d&#39;
        d = datetime.datetime.strptime(date_string, date_fmt).date()
        if isinstance(d, cls):
            return d
        return cls.from_date(d)  # We want to return EWSDate objects</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>datetime.date</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.EWSDate.from_date"><code class="name flex">
<span>def <span class="ident">from_date</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_date(cls, d):
    if type(d) is not datetime.date:
        raise ValueError(&#34;%r must be a date instance&#34; % d)
    return cls(d.year, d.month, d.day)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDate.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>date_string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls, date_string):
    # Sometimes, we&#39;ll receive a date string with timezone information. Not very useful.
    if date_string.endswith(&#39;Z&#39;):
        date_fmt = &#39;%Y-%m-%dZ&#39;
    elif &#39;:&#39; in date_string:
        if &#39;+&#39; in date_string:
            date_fmt = &#39;%Y-%m-%d+%H:%M&#39;
        else:
            date_fmt = &#39;%Y-%m-%d-%H:%M&#39;
    else:
        date_fmt = &#39;%Y-%m-%d&#39;
    d = datetime.datetime.strptime(date_string, date_fmt).date()
    if isinstance(d, cls):
        return d
    return cls.from_date(d)  # We want to return EWSDate objects</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDate.fromordinal"><code class="name flex">
<span>def <span class="ident">fromordinal</span></span>(<span>n)</span>
</code></dt>
<dd>
<div class="desc"><p>int -&gt; date corresponding to a proleptic Gregorian ordinal.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromordinal(cls, n):
    dt = super().fromordinal(n)
    if isinstance(dt, cls):
        return dt
    return cls.from_date(dt)  # We want to return EWSDate objects</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.EWSDate.ewsformat"><code class="name flex">
<span>def <span class="ident">ewsformat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ISO 8601 format to satisfy xs:date as interpreted by EWS. Example: 2009-01-15.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ewsformat(self):
    &#34;&#34;&#34;ISO 8601 format to satisfy xs:date as interpreted by EWS. Example: 2009-01-15.&#34;&#34;&#34;
    return self.isoformat()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.EWSDateTime"><code class="flex name class">
<span>class <span class="ident">EWSDateTime</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Extends the normal datetime implementation to satisfy EWS.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EWSDateTime(datetime.datetime):
    &#34;&#34;&#34;Extends the normal datetime implementation to satisfy EWS.&#34;&#34;&#34;

    __slots__ = &#39;_year&#39;, &#39;_month&#39;, &#39;_day&#39;, &#39;_hour&#39;, &#39;_minute&#39;, &#39;_second&#39;, &#39;_microsecond&#39;, &#39;_tzinfo&#39;, &#39;_hashcode&#39;

    def __new__(cls, *args, **kwargs):
        # pylint: disable=arguments-differ

        if len(args) == 8:
            tzinfo = args[7]
        else:
            tzinfo = kwargs.get(&#39;tzinfo&#39;)
        if isinstance(tzinfo, zoneinfo.ZoneInfo):
            # Don&#39;t allow pytz or dateutil timezones here. They are not safe to use as direct input for datetime()
            tzinfo = EWSTimeZone.from_timezone(tzinfo)
        if not isinstance(tzinfo, (EWSTimeZone, type(None))):
            raise ValueError(&#39;tzinfo %r must be an EWSTimeZone instance&#39; % tzinfo)
        if len(args) == 8:
            args = args[:7] + (tzinfo,)
        else:
            kwargs[&#39;tzinfo&#39;] = tzinfo
        return super().__new__(cls, *args, **kwargs)

    def ewsformat(self):
        &#34;&#34;&#34;ISO 8601 format to satisfy xs:datetime as interpreted by EWS. Examples:
        * 2009-01-15T13:45:56Z
        * 2009-01-15T13:45:56+01:00
        &#34;&#34;&#34;
        if not self.tzinfo:
            raise ValueError(&#39;%r must be timezone-aware&#39; % self)
        if self.tzinfo.key == &#39;UTC&#39;:
            if self.microsecond:
                return self.strftime(&#39;%Y-%m-%dT%H:%M:%S.%fZ&#39;)
            return self.strftime(&#39;%Y-%m-%dT%H:%M:%SZ&#39;)
        return self.isoformat()

    @classmethod
    def from_datetime(cls, d):
        if type(d) is not datetime.datetime:
            raise ValueError(&#34;%r must be a datetime instance&#34; % d)
        if d.tzinfo is None:
            tz = None
        elif isinstance(d.tzinfo, EWSTimeZone):
            tz = d.tzinfo
        else:
            tz = EWSTimeZone.from_timezone(d.tzinfo)
        return cls(d.year, d.month, d.day, d.hour, d.minute, d.second, d.microsecond, tzinfo=tz)

    def astimezone(self, tz=None):
        if tz is None:
            tz = EWSTimeZone.localzone()
        t = super().astimezone(tz=tz).replace(tzinfo=tz)
        if isinstance(t, self.__class__):
            return t
        return self.from_datetime(t)  # We want to return EWSDateTime objects

    def __add__(self, other):
        t = super().__add__(other)
        if isinstance(t, self.__class__):
            return t
        return self.from_datetime(t)  # We want to return EWSDateTime objects

    def __iadd__(self, other):
        return self + other

    def __sub__(self, other):
        t = super().__sub__(other)
        if isinstance(t, datetime.timedelta):
            return t
        if isinstance(t, self.__class__):
            return t
        return self.from_datetime(t)  # We want to return EWSDateTime objects

    def __isub__(self, other):
        return self - other

    @classmethod
    def from_string(cls, date_string):
        # Parses several common datetime formats and returns timezone-aware EWSDateTime objects
        if date_string.endswith(&#39;Z&#39;):
            # UTC datetime
            return super().strptime(date_string, &#39;%Y-%m-%dT%H:%M:%SZ&#39;).replace(tzinfo=UTC)
        if len(date_string) == 19:
            # This is probably a naive datetime. Don&#39;t allow this, but signal caller with an appropriate error
            local_dt = super().strptime(date_string, &#39;%Y-%m-%dT%H:%M:%S&#39;)
            raise NaiveDateTimeNotAllowed(local_dt)
        # This is probably a datetime value with timezone information. This comes in the form &#39;+/-HH:MM&#39;.
        aware_dt = datetime.datetime.fromisoformat(date_string).astimezone(UTC).replace(tzinfo=UTC)
        if isinstance(aware_dt, cls):
            return aware_dt
        return cls.from_datetime(aware_dt)

    @classmethod
    def fromtimestamp(cls, t, tz=None):
        dt = super().fromtimestamp(t, tz=tz)
        if isinstance(dt, cls):
            return dt
        return cls.from_datetime(dt)  # We want to return EWSDateTime objects

    @classmethod
    def utcfromtimestamp(cls, t):
        dt = super().utcfromtimestamp(t)
        if isinstance(dt, cls):
            return dt
        return cls.from_datetime(dt)  # We want to return EWSDateTime objects

    @classmethod
    def now(cls, tz=None):
        t = super().now(tz=tz)
        if isinstance(t, cls):
            return t
        return cls.from_datetime(t)  # We want to return EWSDateTime objects

    @classmethod
    def utcnow(cls):
        t = super().utcnow()
        if isinstance(t, cls):
            return t
        return cls.from_datetime(t)  # We want to return EWSDateTime objects

    def date(self):
        d = super().date()
        if isinstance(d, EWSDate):
            return d
        return EWSDate.from_date(d)  # We want to return EWSDate objects</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>datetime.datetime</li>
<li>datetime.date</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.EWSDateTime.from_datetime"><code class="name flex">
<span>def <span class="ident">from_datetime</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_datetime(cls, d):
    if type(d) is not datetime.datetime:
        raise ValueError(&#34;%r must be a datetime instance&#34; % d)
    if d.tzinfo is None:
        tz = None
    elif isinstance(d.tzinfo, EWSTimeZone):
        tz = d.tzinfo
    else:
        tz = EWSTimeZone.from_timezone(d.tzinfo)
    return cls(d.year, d.month, d.day, d.hour, d.minute, d.second, d.microsecond, tzinfo=tz)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.from_string"><code class="name flex">
<span>def <span class="ident">from_string</span></span>(<span>date_string)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_string(cls, date_string):
    # Parses several common datetime formats and returns timezone-aware EWSDateTime objects
    if date_string.endswith(&#39;Z&#39;):
        # UTC datetime
        return super().strptime(date_string, &#39;%Y-%m-%dT%H:%M:%SZ&#39;).replace(tzinfo=UTC)
    if len(date_string) == 19:
        # This is probably a naive datetime. Don&#39;t allow this, but signal caller with an appropriate error
        local_dt = super().strptime(date_string, &#39;%Y-%m-%dT%H:%M:%S&#39;)
        raise NaiveDateTimeNotAllowed(local_dt)
    # This is probably a datetime value with timezone information. This comes in the form &#39;+/-HH:MM&#39;.
    aware_dt = datetime.datetime.fromisoformat(date_string).astimezone(UTC).replace(tzinfo=UTC)
    if isinstance(aware_dt, cls):
        return aware_dt
    return cls.from_datetime(aware_dt)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.fromtimestamp"><code class="name flex">
<span>def <span class="ident">fromtimestamp</span></span>(<span>t, tz=None)</span>
</code></dt>
<dd>
<div class="desc"><p>timestamp[, tz] -&gt; tz's local time from POSIX timestamp.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromtimestamp(cls, t, tz=None):
    dt = super().fromtimestamp(t, tz=tz)
    if isinstance(dt, cls):
        return dt
    return cls.from_datetime(dt)  # We want to return EWSDateTime objects</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.now"><code class="name flex">
<span>def <span class="ident">now</span></span>(<span>tz=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns new datetime object representing current time local to tz.</p>
<p>tz
Timezone object.</p>
<p>If no tz is specified, uses local timezone.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def now(cls, tz=None):
    t = super().now(tz=tz)
    if isinstance(t, cls):
        return t
    return cls.from_datetime(t)  # We want to return EWSDateTime objects</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.utcfromtimestamp"><code class="name flex">
<span>def <span class="ident">utcfromtimestamp</span></span>(<span>t)</span>
</code></dt>
<dd>
<div class="desc"><p>Construct a naive UTC datetime from a POSIX timestamp.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def utcfromtimestamp(cls, t):
    dt = super().utcfromtimestamp(t)
    if isinstance(dt, cls):
        return dt
    return cls.from_datetime(dt)  # We want to return EWSDateTime objects</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.utcnow"><code class="name flex">
<span>def <span class="ident">utcnow</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a new datetime representing UTC day and time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def utcnow(cls):
    t = super().utcnow()
    if isinstance(t, cls):
        return t
    return cls.from_datetime(t)  # We want to return EWSDateTime objects</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.EWSDateTime.astimezone"><code class="name flex">
<span>def <span class="ident">astimezone</span></span>(<span>self, tz=None)</span>
</code></dt>
<dd>
<div class="desc"><p>tz -&gt; convert to local time in new timezone tz</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def astimezone(self, tz=None):
    if tz is None:
        tz = EWSTimeZone.localzone()
    t = super().astimezone(tz=tz).replace(tzinfo=tz)
    if isinstance(t, self.__class__):
        return t
    return self.from_datetime(t)  # We want to return EWSDateTime objects</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.date"><code class="name flex">
<span>def <span class="ident">date</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return date object with same year, month and day.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def date(self):
    d = super().date()
    if isinstance(d, EWSDate):
        return d
    return EWSDate.from_date(d)  # We want to return EWSDate objects</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSDateTime.ewsformat"><code class="name flex">
<span>def <span class="ident">ewsformat</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ISO 8601 format to satisfy xs:datetime as interpreted by EWS. Examples:
* 2009-01-15T13:45:56Z
* 2009-01-15T13:45:56+01:00</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ewsformat(self):
    &#34;&#34;&#34;ISO 8601 format to satisfy xs:datetime as interpreted by EWS. Examples:
    * 2009-01-15T13:45:56Z
    * 2009-01-15T13:45:56+01:00
    &#34;&#34;&#34;
    if not self.tzinfo:
        raise ValueError(&#39;%r must be timezone-aware&#39; % self)
    if self.tzinfo.key == &#39;UTC&#39;:
        if self.microsecond:
            return self.strftime(&#39;%Y-%m-%dT%H:%M:%S.%fZ&#39;)
        return self.strftime(&#39;%Y-%m-%dT%H:%M:%SZ&#39;)
    return self.isoformat()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.EWSTimeZone"><code class="flex name class">
<span>class <span class="ident">EWSTimeZone</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a timezone as expected by the EWS TimezoneContext / TimezoneDefinition XML element, and returned by
services.GetServerTimeZones.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EWSTimeZone(zoneinfo.ZoneInfo):
    &#34;&#34;&#34;Represents a timezone as expected by the EWS TimezoneContext / TimezoneDefinition XML element, and returned by
    services.GetServerTimeZones.
    &#34;&#34;&#34;

    IANA_TO_MS_MAP = IANA_TO_MS_TIMEZONE_MAP
    MS_TO_IANA_MAP = MS_TIMEZONE_TO_IANA_MAP

    def __new__(cls, *args, **kwargs):
        try:
            instance = super().__new__(cls, *args, **kwargs)
        except zoneinfo.ZoneInfoNotFoundError as e:
            raise UnknownTimeZone(e.args[0])
        try:
            instance.ms_id = cls.IANA_TO_MS_MAP[instance.key][0]
        except KeyError:
            raise UnknownTimeZone(&#39;No Windows timezone name found for timezone &#34;%s&#34;&#39; % instance.key)

        # We don&#39;t need the Windows long-format timezone name in long format. It&#39;s used in timezone XML elements, but
        # EWS happily accepts empty strings. For a full list of timezones supported by the target server, including
        # long-format names, see output of services.GetServerTimeZones(account.protocol).call()
        instance.ms_name = &#39;&#39;
        return instance

    def __eq__(self, other):
        # Microsoft timezones are less granular than IANA, so an EWSTimeZone created from &#39;Europe/Copenhagen&#39; may return
        # from the server as &#39;Europe/Copenhagen&#39;. We&#39;re catering for Microsoft here, so base equality on the Microsoft
        # timezone ID.
        if not isinstance(other, self.__class__):
            return NotImplemented
        return self.ms_id == other.ms_id

    @classmethod
    def from_ms_id(cls, ms_id):
        # Create a timezone instance from a Microsoft timezone ID. This is lossy because there is not a 1:1 translation
        # from MS timezone ID to IANA timezone.
        try:
            return cls(cls.MS_TO_IANA_MAP[ms_id])
        except KeyError:
            if &#39;/&#39; in ms_id:
                # EWS sometimes returns an ID that has a region/location format, e.g. &#39;Europe/Copenhagen&#39;. Try the
                # string unaltered.
                return cls(ms_id)
            raise UnknownTimeZone(&#34;Windows timezone ID &#39;%s&#39; is unknown by CLDR&#34; % ms_id)

    @classmethod
    def from_pytz(cls, tz):
        return cls(tz.zone)

    @classmethod
    def from_dateutil(cls, tz):
        # Objects returned by dateutil.tz.tzlocal() and dateutil.tz.gettz() are not supported. They
        # don&#39;t contain enough information to reliably match them with a CLDR timezone.
        if hasattr(tz, &#39;_filename&#39;):
            key = &#39;/&#39;.join(tz._filename.split(&#39;/&#39;)[-2:])
            return cls(key)
        return cls(tz.tzname(datetime.datetime.now()))

    @classmethod
    def from_zoneinfo(cls, tz):
        return cls(tz.key)

    @classmethod
    def from_timezone(cls, tz):
        # Support multiple tzinfo implementations. We could use isinstance(), but then we&#39;d have to have pytz
        # and dateutil as dependencies for this package.
        tz_module = tz.__class__.__module__.split(&#39;.&#39;)[0]
        try:
            return {
                cls.__module__.split(&#39;.&#39;)[0]: lambda z: z,
                &#39;backports&#39;: cls.from_zoneinfo,
                &#39;dateutil&#39;: cls.from_dateutil,
                &#39;pytz&#39;: cls.from_pytz,
                &#39;zoneinfo&#39;: cls.from_zoneinfo,
                &#39;pytz_deprecation_shim&#39;: lambda z: cls.from_zoneinfo(z.unwrap_shim())
            }[tz_module](tz)
        except KeyError:
            raise TypeError(&#39;Unsupported tzinfo type: %r&#39; % tz)

    @classmethod
    def localzone(cls):
        try:
            tz = tzlocal.get_localzone()
        except zoneinfo.ZoneInfoNotFoundError:
            # Older versions of tzlocal will raise a pytz exception. Let&#39;s not depend on pytz just for that.
            raise UnknownTimeZone(&#34;Failed to guess local timezone&#34;)
        # Handle both old and new versions of tzlocal that may return pytz or zoneinfo objects, respectively
        return cls.from_timezone(tz)

    @classmethod
    def timezone(cls, location):
        warnings.warn(&#39;replace EWSTimeZone.timezone() with just EWSTimeZone()&#39;, DeprecationWarning, stacklevel=2)
        return cls(location)

    def normalize(self, dt, is_dst=False):
        warnings.warn(&#39;normalization is now handled gracefully&#39;, DeprecationWarning, stacklevel=2)
        return dt

    def localize(self, dt, is_dst=False):
        warnings.warn(&#39;replace tz.localize() with dt.replace(tzinfo=tz)&#39;, DeprecationWarning, stacklevel=2)
        if dt.tzinfo is not None:
            raise ValueError(&#39;%r must be timezone-unaware&#39; % dt)
        dt = dt.replace(tzinfo=self)
        if is_dst is not None:
            # DST dates are assumed to always be after non-DST dates
            dt_before = dt.replace(fold=0)
            dt_after = dt.replace(fold=1)
            dst_before = dt_before.dst()
            dst_after = dt_after.dst()
            if dst_before &gt; dst_after:
                dt = dt_before if is_dst else dt_after
            elif dst_before &lt; dst_after:
                dt = dt_after if is_dst else dt_before
        return dt

    def fromutc(self, dt):
        t = super().fromutc(dt)
        if isinstance(t, EWSDateTime):
            return t
        return EWSDateTime.from_datetime(t)  # We want to return EWSDateTime objects</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>backports.zoneinfo.ZoneInfo</li>
<li>datetime.tzinfo</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.EWSTimeZone.IANA_TO_MS_MAP"><code class="name">var <span class="ident">IANA_TO_MS_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.EWSTimeZone.MS_TO_IANA_MAP"><code class="name">var <span class="ident">MS_TO_IANA_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.EWSTimeZone.from_dateutil"><code class="name flex">
<span>def <span class="ident">from_dateutil</span></span>(<span>tz)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_dateutil(cls, tz):
    # Objects returned by dateutil.tz.tzlocal() and dateutil.tz.gettz() are not supported. They
    # don&#39;t contain enough information to reliably match them with a CLDR timezone.
    if hasattr(tz, &#39;_filename&#39;):
        key = &#39;/&#39;.join(tz._filename.split(&#39;/&#39;)[-2:])
        return cls(key)
    return cls(tz.tzname(datetime.datetime.now()))</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSTimeZone.from_ms_id"><code class="name flex">
<span>def <span class="ident">from_ms_id</span></span>(<span>ms_id)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_ms_id(cls, ms_id):
    # Create a timezone instance from a Microsoft timezone ID. This is lossy because there is not a 1:1 translation
    # from MS timezone ID to IANA timezone.
    try:
        return cls(cls.MS_TO_IANA_MAP[ms_id])
    except KeyError:
        if &#39;/&#39; in ms_id:
            # EWS sometimes returns an ID that has a region/location format, e.g. &#39;Europe/Copenhagen&#39;. Try the
            # string unaltered.
            return cls(ms_id)
        raise UnknownTimeZone(&#34;Windows timezone ID &#39;%s&#39; is unknown by CLDR&#34; % ms_id)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSTimeZone.from_pytz"><code class="name flex">
<span>def <span class="ident">from_pytz</span></span>(<span>tz)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_pytz(cls, tz):
    return cls(tz.zone)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSTimeZone.from_timezone"><code class="name flex">
<span>def <span class="ident">from_timezone</span></span>(<span>tz)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_timezone(cls, tz):
    # Support multiple tzinfo implementations. We could use isinstance(), but then we&#39;d have to have pytz
    # and dateutil as dependencies for this package.
    tz_module = tz.__class__.__module__.split(&#39;.&#39;)[0]
    try:
        return {
            cls.__module__.split(&#39;.&#39;)[0]: lambda z: z,
            &#39;backports&#39;: cls.from_zoneinfo,
            &#39;dateutil&#39;: cls.from_dateutil,
            &#39;pytz&#39;: cls.from_pytz,
            &#39;zoneinfo&#39;: cls.from_zoneinfo,
            &#39;pytz_deprecation_shim&#39;: lambda z: cls.from_zoneinfo(z.unwrap_shim())
        }[tz_module](tz)
    except KeyError:
        raise TypeError(&#39;Unsupported tzinfo type: %r&#39; % tz)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSTimeZone.from_zoneinfo"><code class="name flex">
<span>def <span class="ident">from_zoneinfo</span></span>(<span>tz)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_zoneinfo(cls, tz):
    return cls(tz.key)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSTimeZone.localzone"><code class="name flex">
<span>def <span class="ident">localzone</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def localzone(cls):
    try:
        tz = tzlocal.get_localzone()
    except zoneinfo.ZoneInfoNotFoundError:
        # Older versions of tzlocal will raise a pytz exception. Let&#39;s not depend on pytz just for that.
        raise UnknownTimeZone(&#34;Failed to guess local timezone&#34;)
    # Handle both old and new versions of tzlocal that may return pytz or zoneinfo objects, respectively
    return cls.from_timezone(tz)</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSTimeZone.timezone"><code class="name flex">
<span>def <span class="ident">timezone</span></span>(<span>location)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def timezone(cls, location):
    warnings.warn(&#39;replace EWSTimeZone.timezone() with just EWSTimeZone()&#39;, DeprecationWarning, stacklevel=2)
    return cls(location)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.EWSTimeZone.fromutc"><code class="name flex">
<span>def <span class="ident">fromutc</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a datetime with local time in UTC, retrieve an adjusted datetime in local time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fromutc(self, dt):
    t = super().fromutc(dt)
    if isinstance(t, EWSDateTime):
        return t
    return EWSDateTime.from_datetime(t)  # We want to return EWSDateTime objects</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSTimeZone.localize"><code class="name flex">
<span>def <span class="ident">localize</span></span>(<span>self, dt, is_dst=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def localize(self, dt, is_dst=False):
    warnings.warn(&#39;replace tz.localize() with dt.replace(tzinfo=tz)&#39;, DeprecationWarning, stacklevel=2)
    if dt.tzinfo is not None:
        raise ValueError(&#39;%r must be timezone-unaware&#39; % dt)
    dt = dt.replace(tzinfo=self)
    if is_dst is not None:
        # DST dates are assumed to always be after non-DST dates
        dt_before = dt.replace(fold=0)
        dt_after = dt.replace(fold=1)
        dst_before = dt_before.dst()
        dst_after = dt_after.dst()
        if dst_before &gt; dst_after:
            dt = dt_before if is_dst else dt_after
        elif dst_before &lt; dst_after:
            dt = dt_after if is_dst else dt_before
    return dt</code></pre>
</details>
</dd>
<dt id="exchangelib.EWSTimeZone.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self, dt, is_dst=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize(self, dt, is_dst=False):
    warnings.warn(&#39;normalization is now handled gracefully&#39;, DeprecationWarning, stacklevel=2)
    return dt</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.ExtendedProperty"><code class="flex name class">
<span>class <span class="ident">ExtendedProperty</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/extendedproperty">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/extendedproperty</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtendedProperty(EWSElement):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/extendedproperty&#34;&#34;&#34;

    ELEMENT_NAME = &#39;ExtendedProperty&#39;

    # Enum values: https://docs.microsoft.com/en-us/dotnet/api/exchangewebservices.distinguishedpropertysettype
    DISTINGUISHED_SETS = {
        &#39;Address&#39;,
        &#39;Appointment&#39;,
        &#39;CalendarAssistant&#39;,
        &#39;Common&#39;,
        &#39;InternetHeaders&#39;,
        &#39;Meeting&#39;,
        &#39;PublicStrings&#39;,
        &#39;Sharing&#39;,
        &#39;Task&#39;,
        &#39;UnifiedMessaging&#39;,
    }
    # Enum values: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/extendedfielduri
    PROPERTY_TYPES = {
        &#39;ApplicationTime&#39;,
        &#39;Binary&#39;,
        &#39;BinaryArray&#39;,
        &#39;Boolean&#39;,
        &#39;CLSID&#39;,
        &#39;CLSIDArray&#39;,
        &#39;Currency&#39;,
        &#39;CurrencyArray&#39;,
        &#39;Double&#39;,
        &#39;DoubleArray&#39;,
        # &#39;Error&#39;,
        &#39;Float&#39;,
        &#39;FloatArray&#39;,
        &#39;Integer&#39;,
        &#39;IntegerArray&#39;,
        &#39;Long&#39;,
        &#39;LongArray&#39;,
        # &#39;Null&#39;,
        # &#39;Object&#39;,
        # &#39;ObjectArray&#39;,
        &#39;Short&#39;,
        &#39;ShortArray&#39;,
        &#39;SystemTime&#39;,
        &#39;SystemTimeArray&#39;,
        &#39;String&#39;,
        &#39;StringArray&#39;,
    }  # The commented-out types cannot be used for setting or getting (see docs) and are thus not very useful here

    # Translation table between common distinguished_property_set_id and property_set_id values. See
    # https://docs.microsoft.com/en-us/office/client-developer/outlook/mapi/commonly-used-property-sets
    # ID values must be lowercase.
    DISTINGUISHED_SET_NAME_TO_ID_MAP = {
        &#39;Address&#39;: &#39;00062004-0000-0000-c000-000000000046&#39;,
        &#39;AirSync&#39;: &#39;71035549-0739-4dcb-9163-00f0580dbbdf&#39;,
        &#39;Appointment&#39;: &#39;00062002-0000-0000-c000-000000000046&#39;,
        &#39;Common&#39;: &#39;00062008-0000-0000-c000-000000000046&#39;,
        &#39;InternetHeaders&#39;: &#39;00020386-0000-0000-c000-000000000046&#39;,
        &#39;Log&#39;: &#39;0006200a-0000-0000-c000-000000000046&#39;,
        &#39;Mapi&#39;: &#39;00020328-0000-0000-c000-000000000046&#39;,
        &#39;Meeting&#39;: &#39;6ed8da90-450b-101b-98da-00aa003f1305&#39;,
        &#39;Messaging&#39;: &#39;41f28f13-83f4-4114-a584-eedb5a6b0bff&#39;,
        &#39;Note&#39;: &#39;0006200e-0000-0000-c000-000000000046&#39;,
        &#39;PostRss&#39;: &#39;00062041-0000-0000-c000-000000000046&#39;,
        &#39;PublicStrings&#39;: &#39;00020329-0000-0000-c000-000000000046&#39;,
        &#39;Remote&#39;: &#39;00062014-0000-0000-c000-000000000046&#39;,
        &#39;Report&#39;: &#39;00062013-0000-0000-c000-000000000046&#39;,
        &#39;Sharing&#39;: &#39;00062040-0000-0000-c000-000000000046&#39;,
        &#39;Task&#39;: &#39;00062003-0000-0000-c000-000000000046&#39;,
        &#39;UnifiedMessaging&#39;: &#39;4442858e-a9e3-4e80-b900-317a210cc15b&#39;,
    }
    DISTINGUISHED_SET_ID_TO_NAME_MAP = {v: k for k, v in DISTINGUISHED_SET_NAME_TO_ID_MAP.items()}

    distinguished_property_set_id = None
    property_set_id = None
    property_tag = None  # hex integer (e.g. 0x8000) or string (&#39;0x8000&#39;)
    property_name = None
    property_id = None  # integer as hex-formatted int (e.g. 0x8000) or normal int (32768)
    property_type = &#39;&#39;

    __slots__ = &#39;value&#39;,

    def __init__(self, *args, **kwargs):
        if not kwargs:
            # Allow to set attributes without keyword
            kwargs = dict(zip(self._slots_keys, args))
        self.value = kwargs.pop(&#39;value&#39;)
        super().__init__(**kwargs)

    @classmethod
    def validate_cls(cls):
        # Validate values of class attributes and their inter-dependencies
        cls._validate_distinguished_property_set_id()
        cls._validate_property_set_id()
        cls._validate_property_tag()
        cls._validate_property_name()
        cls._validate_property_id()
        cls._validate_property_type()

    @classmethod
    def _validate_distinguished_property_set_id(cls):
        if cls.distinguished_property_set_id:
            if any([cls.property_set_id, cls.property_tag]):
                raise ValueError(
                    &#34;When &#39;distinguished_property_set_id&#39; is set, &#39;property_set_id&#39; and &#39;property_tag&#39; must be None&#34;
                )
            if not any([cls.property_id, cls.property_name]):
                raise ValueError(
                    &#34;When &#39;distinguished_property_set_id&#39; is set, &#39;property_id&#39; or &#39;property_name&#39; must also be set&#34;
                )
            if cls.distinguished_property_set_id not in cls.DISTINGUISHED_SETS:
                raise ValueError(
                    &#34;&#39;distinguished_property_set_id&#39; %r must be one of %s&#34;
                    % (cls.distinguished_property_set_id, sorted(cls.DISTINGUISHED_SETS))
                )

    @classmethod
    def _validate_property_set_id(cls):
        if cls.property_set_id:
            if any([cls.distinguished_property_set_id, cls.property_tag]):
                raise ValueError(
                    &#34;When &#39;property_set_id&#39; is set, &#39;distinguished_property_set_id&#39; and &#39;property_tag&#39; must be None&#34;
                )
            if not any([cls.property_id, cls.property_name]):
                raise ValueError(
                    &#34;When &#39;property_set_id&#39; is set, &#39;property_id&#39; or &#39;property_name&#39; must also be set&#34;
                )

    @classmethod
    def _validate_property_tag(cls):
        if cls.property_tag:
            if any([
                cls.distinguished_property_set_id, cls.property_set_id, cls.property_name, cls.property_id
            ]):
                raise ValueError(&#34;When &#39;property_tag&#39; is set, only &#39;property_type&#39; must be set&#34;)
            if 0x8000 &lt;= cls.property_tag_as_int() &lt;= 0xFFFE:
                raise ValueError(
                    &#34;&#39;property_tag&#39; value &#39;%s&#39; is reserved for custom properties&#34; % cls.property_tag_as_hex()
                )

    @classmethod
    def _validate_property_name(cls):
        if cls.property_name:
            if any([cls.property_id, cls.property_tag]):
                raise ValueError(&#34;When &#39;property_name&#39; is set, &#39;property_id&#39; and &#39;property_tag&#39; must be None&#34;)
            if not any([cls.distinguished_property_set_id, cls.property_set_id]):
                raise ValueError(
                    &#34;When &#39;property_name&#39; is set, &#39;distinguished_property_set_id&#39; or &#39;property_set_id&#39; must also be set&#34;
                )

    @classmethod
    def _validate_property_id(cls):
        if cls.property_id:
            if any([cls.property_name, cls.property_tag]):
                raise ValueError(&#34;When &#39;property_id&#39; is set, &#39;property_name&#39; and &#39;property_tag&#39; must be None&#34;)
            if not any([cls.distinguished_property_set_id, cls.property_set_id]):
                raise ValueError(
                    &#34;When &#39;property_id&#39; is set, &#39;distinguished_property_set_id&#39; or &#39;property_set_id&#39; must also be set&#34;
                )

    @classmethod
    def _validate_property_type(cls):
        if cls.property_type not in cls.PROPERTY_TYPES:
            raise ValueError(
                &#34;&#39;property_type&#39; %r must be one of %s&#34; % (cls.property_type, sorted(cls.PROPERTY_TYPES))
            )

    def clean(self, version=None):
        self.validate_cls()
        python_type = self.python_type()
        if self.is_array_type():
            if not is_iterable(self.value):
                raise ValueError(&#34;&#39;%s&#39; value %r must be a list&#34; % (self.__class__.__name__, self.value))
            for v in self.value:
                if not isinstance(v, python_type):
                    raise TypeError(
                        &#34;&#39;%s&#39; value element %r must be an instance of %s&#34; % (self.__class__.__name__, v, python_type))
        else:
            if not isinstance(self.value, python_type):
                raise TypeError(
                    &#34;&#39;%s&#39; value %r must be an instance of %s&#34; % (self.__class__.__name__, self.value, python_type))

    @classmethod
    def _normalize_obj(cls, obj):
        # Sometimes, EWS will helpfully translate a &#39;distinguished_property_set_id&#39; value to a &#39;property_set_id&#39; value
        # and vice versa. Align these values on an ExtendedFieldURI instance.
        try:
            obj.property_set_id = cls.DISTINGUISHED_SET_NAME_TO_ID_MAP[obj.distinguished_property_set_id]
        except KeyError:
            try:
                obj.distinguished_property_set_id = cls.DISTINGUISHED_SET_ID_TO_NAME_MAP[obj.property_set_id]
            except KeyError:
                pass
        return obj

    @classmethod
    def is_property_instance(cls, elem):
        &#34;&#34;&#34;Return whether an &#39;ExtendedProperty&#39; element matches the definition for this class. Extended property fields
        do not have a name, so we must match on the cls.property_* attributes to match a field in the request with a
        field in the response.
        &#34;&#34;&#34;
        # We can&#39;t use ExtendedFieldURI.from_xml(). It clears the XML element but we may not want to consume it here.
        kwargs = {
            f.name: f.from_xml(elem=elem.find(ExtendedFieldURI.response_tag()), account=None)
            for f in ExtendedFieldURI.FIELDS
        }
        xml_obj = ExtendedFieldURI(**kwargs)
        cls_obj = cls.as_object()
        return cls._normalize_obj(cls_obj) == cls._normalize_obj(xml_obj)

    @classmethod
    def from_xml(cls, elem, account):
        # Gets value of this specific ExtendedProperty from a list of &#39;ExtendedProperty&#39; XML elements
        python_type = cls.python_type()
        if cls.is_array_type():
            values = elem.find(&#39;{%s}Values&#39; % TNS)
            return [
                xml_text_to_value(value=val, value_type=python_type)
                for val in get_xml_attrs(values, &#39;{%s}Value&#39; % TNS)
            ]
        extended_field_value = xml_text_to_value(value=get_xml_attr(elem, &#39;{%s}Value&#39; % TNS), value_type=python_type)
        if python_type == str and not extended_field_value:
            # For string types, we want to return the empty string instead of None if the element was
            # actually found, but there was no XML value. For other types, it would be more problematic
            # to make that distinction, e.g. return False for bool, 0 for int, etc.
            return &#39;&#39;
        return extended_field_value

    def to_xml(self, version):
        if self.is_array_type():
            values = create_element(&#39;t:Values&#39;)
            for v in self.value:
                add_xml_child(values, &#39;t:Value&#39;, v)
            return values
        return set_xml_value(create_element(&#39;t:Value&#39;), self.value, version=version)

    @classmethod
    def is_array_type(cls):
        return cls.property_type.endswith(&#39;Array&#39;)

    @classmethod
    def property_tag_as_int(cls):
        if isinstance(cls.property_tag, str):
            return int(cls.property_tag, base=16)
        return cls.property_tag

    @classmethod
    def property_tag_as_hex(cls):
        return hex(cls.property_tag) if isinstance(cls.property_tag, int) else cls.property_tag

    @classmethod
    def python_type(cls):
        # Return the best equivalent for a Python type for the property type of this class
        base_type = cls.property_type[:-5] if cls.is_array_type() else cls.property_type
        return {
            &#39;ApplicationTime&#39;: Decimal,
            &#39;Binary&#39;: bytes,
            &#39;Boolean&#39;: bool,
            &#39;CLSID&#39;: str,
            &#39;Currency&#39;: int,
            &#39;Double&#39;: Decimal,
            &#39;Float&#39;: Decimal,
            &#39;Integer&#39;: int,
            &#39;Long&#39;: int,
            &#39;Short&#39;: int,
            &#39;SystemTime&#39;: EWSDateTime,
            &#39;String&#39;: str,
        }[base_type]

    @classmethod
    def as_object(cls):
        # Return an object we can use to match with the incoming object from XML
        return ExtendedFieldURI(
            distinguished_property_set_id=cls.distinguished_property_set_id,
            property_set_id=cls.property_set_id.lower() if cls.property_set_id else None,
            property_tag=cls.property_tag_as_hex(),
            property_name=cls.property_name,
            property_id=value_to_xml_text(cls.property_id) if cls.property_id else None,
            property_type=cls.property_type,
        )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.extended_properties.ExternId" href="extended_properties.html#exchangelib.extended_properties.ExternId">ExternId</a></li>
<li><a title="exchangelib.extended_properties.Flag" href="extended_properties.html#exchangelib.extended_properties.Flag">Flag</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.ExtendedProperty.DISTINGUISHED_SETS"><code class="name">var <span class="ident">DISTINGUISHED_SETS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.DISTINGUISHED_SET_ID_TO_NAME_MAP"><code class="name">var <span class="ident">DISTINGUISHED_SET_ID_TO_NAME_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.DISTINGUISHED_SET_NAME_TO_ID_MAP"><code class="name">var <span class="ident">DISTINGUISHED_SET_NAME_TO_ID_MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.PROPERTY_TYPES"><code class="name">var <span class="ident">PROPERTY_TYPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.distinguished_property_set_id"><code class="name">var <span class="ident">distinguished_property_set_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.property_id"><code class="name">var <span class="ident">property_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.property_name"><code class="name">var <span class="ident">property_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.property_set_id"><code class="name">var <span class="ident">property_set_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.property_tag"><code class="name">var <span class="ident">property_tag</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ExtendedProperty.property_type"><code class="name">var <span class="ident">property_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.ExtendedProperty.as_object"><code class="name flex">
<span>def <span class="ident">as_object</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def as_object(cls):
    # Return an object we can use to match with the incoming object from XML
    return ExtendedFieldURI(
        distinguished_property_set_id=cls.distinguished_property_set_id,
        property_set_id=cls.property_set_id.lower() if cls.property_set_id else None,
        property_tag=cls.property_tag_as_hex(),
        property_name=cls.property_name,
        property_id=value_to_xml_text(cls.property_id) if cls.property_id else None,
        property_type=cls.property_type,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem, account):
    # Gets value of this specific ExtendedProperty from a list of &#39;ExtendedProperty&#39; XML elements
    python_type = cls.python_type()
    if cls.is_array_type():
        values = elem.find(&#39;{%s}Values&#39; % TNS)
        return [
            xml_text_to_value(value=val, value_type=python_type)
            for val in get_xml_attrs(values, &#39;{%s}Value&#39; % TNS)
        ]
    extended_field_value = xml_text_to_value(value=get_xml_attr(elem, &#39;{%s}Value&#39; % TNS), value_type=python_type)
    if python_type == str and not extended_field_value:
        # For string types, we want to return the empty string instead of None if the element was
        # actually found, but there was no XML value. For other types, it would be more problematic
        # to make that distinction, e.g. return False for bool, 0 for int, etc.
        return &#39;&#39;
    return extended_field_value</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.is_array_type"><code class="name flex">
<span>def <span class="ident">is_array_type</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_array_type(cls):
    return cls.property_type.endswith(&#39;Array&#39;)</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.is_property_instance"><code class="name flex">
<span>def <span class="ident">is_property_instance</span></span>(<span>elem)</span>
</code></dt>
<dd>
<div class="desc"><p>Return whether an 'ExtendedProperty' element matches the definition for this class. Extended property fields
do not have a name, so we must match on the cls.property_* attributes to match a field in the request with a
field in the response.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_property_instance(cls, elem):
    &#34;&#34;&#34;Return whether an &#39;ExtendedProperty&#39; element matches the definition for this class. Extended property fields
    do not have a name, so we must match on the cls.property_* attributes to match a field in the request with a
    field in the response.
    &#34;&#34;&#34;
    # We can&#39;t use ExtendedFieldURI.from_xml(). It clears the XML element but we may not want to consume it here.
    kwargs = {
        f.name: f.from_xml(elem=elem.find(ExtendedFieldURI.response_tag()), account=None)
        for f in ExtendedFieldURI.FIELDS
    }
    xml_obj = ExtendedFieldURI(**kwargs)
    cls_obj = cls.as_object()
    return cls._normalize_obj(cls_obj) == cls._normalize_obj(xml_obj)</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.property_tag_as_hex"><code class="name flex">
<span>def <span class="ident">property_tag_as_hex</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def property_tag_as_hex(cls):
    return hex(cls.property_tag) if isinstance(cls.property_tag, int) else cls.property_tag</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.property_tag_as_int"><code class="name flex">
<span>def <span class="ident">property_tag_as_int</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def property_tag_as_int(cls):
    if isinstance(cls.property_tag, str):
        return int(cls.property_tag, base=16)
    return cls.property_tag</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.python_type"><code class="name flex">
<span>def <span class="ident">python_type</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def python_type(cls):
    # Return the best equivalent for a Python type for the property type of this class
    base_type = cls.property_type[:-5] if cls.is_array_type() else cls.property_type
    return {
        &#39;ApplicationTime&#39;: Decimal,
        &#39;Binary&#39;: bytes,
        &#39;Boolean&#39;: bool,
        &#39;CLSID&#39;: str,
        &#39;Currency&#39;: int,
        &#39;Double&#39;: Decimal,
        &#39;Float&#39;: Decimal,
        &#39;Integer&#39;: int,
        &#39;Long&#39;: int,
        &#39;Short&#39;: int,
        &#39;SystemTime&#39;: EWSDateTime,
        &#39;String&#39;: str,
    }[base_type]</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.validate_cls"><code class="name flex">
<span>def <span class="ident">validate_cls</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def validate_cls(cls):
    # Validate values of class attributes and their inter-dependencies
    cls._validate_distinguished_property_set_id()
    cls._validate_property_set_id()
    cls._validate_property_tag()
    cls._validate_property_name()
    cls._validate_property_id()
    cls._validate_property_type()</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.ExtendedProperty.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.ExtendedProperty.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, version=None):
    self.validate_cls()
    python_type = self.python_type()
    if self.is_array_type():
        if not is_iterable(self.value):
            raise ValueError(&#34;&#39;%s&#39; value %r must be a list&#34; % (self.__class__.__name__, self.value))
        for v in self.value:
            if not isinstance(v, python_type):
                raise TypeError(
                    &#34;&#39;%s&#39; value element %r must be an instance of %s&#34; % (self.__class__.__name__, v, python_type))
    else:
        if not isinstance(self.value, python_type):
            raise TypeError(
                &#34;&#39;%s&#39; value %r must be an instance of %s&#34; % (self.__class__.__name__, self.value, python_type))</code></pre>
</details>
</dd>
<dt id="exchangelib.ExtendedProperty.to_xml"><code class="name flex">
<span>def <span class="ident">to_xml</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xml(self, version):
    if self.is_array_type():
        values = create_element(&#39;t:Values&#39;)
        for v in self.value:
            add_xml_child(values, &#39;t:Value&#39;, v)
        return values
    return set_xml_value(create_element(&#39;t:Value&#39;), self.value, version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.EWSElement.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.FailFast"><code class="flex name class">
<span>class <span class="ident">FailFast</span></span>
</code></dt>
<dd>
<div class="desc"><p>Fail immediately on server errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FailFast(RetryPolicy):
    &#34;&#34;&#34;Fail immediately on server errors.&#34;&#34;&#34;

    @property
    def fail_fast(self):
        return True

    @property
    def back_off_until(self):
        return None

    def back_off(self, seconds):
        raise ValueError(&#39;Cannot back off with fail-fast policy&#39;)

    def may_retry_on_error(self, response, wait):
        log.debug(&#39;No retry: no fail-fast policy&#39;)
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.protocol.RetryPolicy" href="protocol.html#exchangelib.protocol.RetryPolicy">RetryPolicy</a></li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.FailFast.back_off_until"><code class="name">var <span class="ident">back_off_until</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def back_off_until(self):
    return None</code></pre>
</details>
</dd>
<dt id="exchangelib.FailFast.fail_fast"><code class="name">var <span class="ident">fail_fast</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fail_fast(self):
    return True</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.FailFast.back_off"><code class="name flex">
<span>def <span class="ident">back_off</span></span>(<span>self, seconds)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def back_off(self, seconds):
    raise ValueError(&#39;Cannot back off with fail-fast policy&#39;)</code></pre>
</details>
</dd>
<dt id="exchangelib.FailFast.may_retry_on_error"><code class="name flex">
<span>def <span class="ident">may_retry_on_error</span></span>(<span>self, response, wait)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def may_retry_on_error(self, response, wait):
    log.debug(&#39;No retry: no fail-fast policy&#39;)
    return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.FaultTolerance"><code class="flex name class">
<span>class <span class="ident">FaultTolerance</span></span>
<span>(</span><span>max_wait=3600)</span>
</code></dt>
<dd>
<div class="desc"><p>Enables fault-tolerant error handling. Tells internal methods to do an exponential back off when requests start
failing, and wait up to max_wait seconds before failing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FaultTolerance(RetryPolicy):
    &#34;&#34;&#34;Enables fault-tolerant error handling. Tells internal methods to do an exponential back off when requests start
    failing, and wait up to max_wait seconds before failing.
    &#34;&#34;&#34;

    # Back off 60 seconds if we didn&#39;t get an explicit suggested value
    DEFAULT_BACKOFF = 60

    def __init__(self, max_wait=3600):
        self.max_wait = max_wait
        self._back_off_until = None
        self._back_off_lock = Lock()

    def __getstate__(self):
        # Locks cannot be pickled
        state = self.__dict__.copy()
        del state[&#39;_back_off_lock&#39;]
        return state

    def __setstate__(self, state):
        # Restore the lock
        self.__dict__.update(state)
        self._back_off_lock = Lock()

    @property
    def fail_fast(self):
        return False

    @property
    def back_off_until(self):
        &#34;&#34;&#34;Return the back off value as a datetime. Reset the current back off value if it has expired.&#34;&#34;&#34;
        if self._back_off_until is None:
            return None
        with self._back_off_lock:
            if self._back_off_until is None:
                return None
            if self._back_off_until &lt; datetime.datetime.now():
                self._back_off_until = None  # The back off value has expired. Reset
                return None
            return self._back_off_until

    @back_off_until.setter
    def back_off_until(self, value):
        with self._back_off_lock:
            self._back_off_until = value

    def back_off(self, seconds):
        if seconds is None:
            seconds = self.DEFAULT_BACKOFF
        value = datetime.datetime.now() + datetime.timedelta(seconds=seconds)
        with self._back_off_lock:
            self._back_off_until = value

    def may_retry_on_error(self, response, wait):
        if response.status_code not in (301, 302, 401, 500, 503):
            # Don&#39;t retry if we didn&#39;t get a status code that we can hope to recover from
            log.debug(&#39;No retry: wrong status code %s&#39;, response.status_code)
            return False
        if wait &gt; self.max_wait:
            # We lost patience. Session is cleaned up in outer loop
            raise RateLimitError(
                &#39;Max timeout reached&#39;, url=response.url, status_code=response.status_code, total_wait=wait)
        if response.status_code == 401:
            # EWS sometimes throws 401&#39;s when it wants us to throttle connections. OK to retry.
            return True
        if response.headers.get(&#39;connection&#39;) == &#39;close&#39;:
            # Connection closed. OK to retry.
            return True
        if response.status_code == 302 and response.headers.get(&#39;location&#39;, &#39;&#39;).lower() \
                == &#39;/ews/genericerrorpage.htm?aspxerrorpath=/ews/exchange.asmx&#39;:
            # The genericerrorpage.htm/internalerror.asp is ridiculous behaviour for random outages. OK to retry.
            #
            # Redirect to &#39;/internalsite/internalerror.asp&#39; or &#39;/internalsite/initparams.aspx&#39; is caused by e.g. TLS
            # certificate f*ckups on the Exchange server. We should not retry those.
            return True
        if response.status_code == 503:
            # Internal server error. OK to retry.
            return True
        if response.status_code == 500 and b&#34;Server Error in &#39;/EWS&#39; Application&#34; in response.content:
            # &#34;Server Error in &#39;/EWS&#39; Application&#34; has been seen in highly concurrent settings. OK to retry.
            log.debug(&#39;Retry allowed: conditions met&#39;)
            return True
        return False</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.protocol.RetryPolicy" href="protocol.html#exchangelib.protocol.RetryPolicy">RetryPolicy</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.FaultTolerance.DEFAULT_BACKOFF"><code class="name">var <span class="ident">DEFAULT_BACKOFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.FaultTolerance.back_off_until"><code class="name">var <span class="ident">back_off_until</span></code></dt>
<dd>
<div class="desc"><p>Return the back off value as a datetime. Reset the current back off value if it has expired.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def back_off_until(self):
    &#34;&#34;&#34;Return the back off value as a datetime. Reset the current back off value if it has expired.&#34;&#34;&#34;
    if self._back_off_until is None:
        return None
    with self._back_off_lock:
        if self._back_off_until is None:
            return None
        if self._back_off_until &lt; datetime.datetime.now():
            self._back_off_until = None  # The back off value has expired. Reset
            return None
        return self._back_off_until</code></pre>
</details>
</dd>
<dt id="exchangelib.FaultTolerance.fail_fast"><code class="name">var <span class="ident">fail_fast</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fail_fast(self):
    return False</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.FaultTolerance.back_off"><code class="name flex">
<span>def <span class="ident">back_off</span></span>(<span>self, seconds)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def back_off(self, seconds):
    if seconds is None:
        seconds = self.DEFAULT_BACKOFF
    value = datetime.datetime.now() + datetime.timedelta(seconds=seconds)
    with self._back_off_lock:
        self._back_off_until = value</code></pre>
</details>
</dd>
<dt id="exchangelib.FaultTolerance.may_retry_on_error"><code class="name flex">
<span>def <span class="ident">may_retry_on_error</span></span>(<span>self, response, wait)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def may_retry_on_error(self, response, wait):
    if response.status_code not in (301, 302, 401, 500, 503):
        # Don&#39;t retry if we didn&#39;t get a status code that we can hope to recover from
        log.debug(&#39;No retry: wrong status code %s&#39;, response.status_code)
        return False
    if wait &gt; self.max_wait:
        # We lost patience. Session is cleaned up in outer loop
        raise RateLimitError(
            &#39;Max timeout reached&#39;, url=response.url, status_code=response.status_code, total_wait=wait)
    if response.status_code == 401:
        # EWS sometimes throws 401&#39;s when it wants us to throttle connections. OK to retry.
        return True
    if response.headers.get(&#39;connection&#39;) == &#39;close&#39;:
        # Connection closed. OK to retry.
        return True
    if response.status_code == 302 and response.headers.get(&#39;location&#39;, &#39;&#39;).lower() \
            == &#39;/ews/genericerrorpage.htm?aspxerrorpath=/ews/exchange.asmx&#39;:
        # The genericerrorpage.htm/internalerror.asp is ridiculous behaviour for random outages. OK to retry.
        #
        # Redirect to &#39;/internalsite/internalerror.asp&#39; or &#39;/internalsite/initparams.aspx&#39; is caused by e.g. TLS
        # certificate f*ckups on the Exchange server. We should not retry those.
        return True
    if response.status_code == 503:
        # Internal server error. OK to retry.
        return True
    if response.status_code == 500 and b&#34;Server Error in &#39;/EWS&#39; Application&#34; in response.content:
        # &#34;Server Error in &#39;/EWS&#39; Application&#34; has been seen in highly concurrent settings. OK to retry.
        log.debug(&#39;Retry allowed: conditions met&#39;)
        return True
    return False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.FileAttachment"><code class="flex name class">
<span>class <span class="ident">FileAttachment</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/fileattachment">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/fileattachment</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileAttachment(Attachment):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/fileattachment&#34;&#34;&#34;

    ELEMENT_NAME = &#39;FileAttachment&#39;

    is_contact_photo = BooleanField(field_uri=&#39;IsContactPhoto&#39;)
    _content = Base64Field(field_uri=&#39;Content&#39;)

    __slots__ = &#39;_fp&#39;,

    def __init__(self, **kwargs):
        kwargs[&#39;_content&#39;] = kwargs.pop(&#39;content&#39;, None)
        super().__init__(**kwargs)
        self._fp = None

    @property
    def fp(self):
        # Return a file-like object for the content. This avoids creating multiple in-memory copies of the content.
        if self._fp is None:
            self._init_fp()
        return self._fp

    def _init_fp(self):
        # Create a file-like object for the attachment content. We try hard to reduce memory consumption so we never
        # store the full attachment content in-memory.
        if not self.parent_item or not self.parent_item.account:
            raise ValueError(&#39;%s must have an account&#39; % self.__class__.__name__)
        self._fp = FileAttachmentIO(attachment=self)

    @property
    def content(self):
        &#34;&#34;&#34;Return the attachment content. Stores a local copy of the content in case you want to upload the attachment
        again later.
        &#34;&#34;&#34;
        if self.attachment_id is None:
            return self._content
        if self._content is not None:
            return self._content
        # We have an ID to the data but still haven&#39;t called GetAttachment to get the actual data. Do that now.
        with self.fp as fp:
            self._content = fp.read()
        return self._content

    @content.setter
    def content(self, value):
        &#34;&#34;&#34;Replace the attachment content.&#34;&#34;&#34;
        if not isinstance(value, bytes):
            raise ValueError(&#34;&#39;value&#39; %r must be a bytes object&#34; % value)
        self._content = value

    @classmethod
    def from_xml(cls, elem, account):
        kwargs = {f.name: f.from_xml(elem=elem, account=account) for f in cls.FIELDS}
        kwargs[&#39;content&#39;] = kwargs.pop(&#39;_content&#39;)
        cls._clear(elem)
        return cls(**kwargs)

    def to_xml(self, version):
        self._content = self.content  # Make sure content is available, to avoid ErrorRequiredPropertyMissing
        return super().to_xml(version=version)

    def __getstate__(self):
        # The fp does not need to be pickled
        state = {k: getattr(self, k) for k in self._slots_keys}
        del state[&#39;_fp&#39;]
        return state

    def __setstate__(self, state):
        # Restore the fp
        for k in self._slots_keys:
            setattr(self, k, state.get(k))
        self._fp = None</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.attachments.Attachment" href="attachments.html#exchangelib.attachments.Attachment">Attachment</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.FileAttachment.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.FileAttachment.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.FileAttachment.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem, account):
    kwargs = {f.name: f.from_xml(elem=elem, account=account) for f in cls.FIELDS}
    kwargs[&#39;content&#39;] = kwargs.pop(&#39;_content&#39;)
    cls._clear(elem)
    return cls(**kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.FileAttachment.content"><code class="name">var <span class="ident">content</span></code></dt>
<dd>
<div class="desc"><p>Return the attachment content. Stores a local copy of the content in case you want to upload the attachment
again later.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def content(self):
    &#34;&#34;&#34;Return the attachment content. Stores a local copy of the content in case you want to upload the attachment
    again later.
    &#34;&#34;&#34;
    if self.attachment_id is None:
        return self._content
    if self._content is not None:
        return self._content
    # We have an ID to the data but still haven&#39;t called GetAttachment to get the actual data. Do that now.
    with self.fp as fp:
        self._content = fp.read()
    return self._content</code></pre>
</details>
</dd>
<dt id="exchangelib.FileAttachment.fp"><code class="name">var <span class="ident">fp</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fp(self):
    # Return a file-like object for the content. This avoids creating multiple in-memory copies of the content.
    if self._fp is None:
        self._init_fp()
    return self._fp</code></pre>
</details>
</dd>
<dt id="exchangelib.FileAttachment.is_contact_photo"><code class="name">var <span class="ident">is_contact_photo</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.FileAttachment.to_xml"><code class="name flex">
<span>def <span class="ident">to_xml</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xml(self, version):
    self._content = self.content  # Make sure content is available, to avoid ErrorRequiredPropertyMissing
    return super().to_xml(version=version)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.attachments.Attachment" href="attachments.html#exchangelib.attachments.Attachment">Attachment</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.attachments.Attachment.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.parent_item" href="attachments.html#exchangelib.attachments.Attachment.parent_item">parent_item</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Folder"><code class="flex name class">
<span>class <span class="ident">Folder</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/folder">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/folder</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Folder(BaseFolder):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/folder&#34;&#34;&#34;

    permission_set = PermissionSetField(field_uri=&#39;folder:PermissionSet&#39;, supported_from=EXCHANGE_2007_SP1)
    effective_rights = EffectiveRightsField(field_uri=&#39;folder:EffectiveRights&#39;, is_read_only=True,
                                            supported_from=EXCHANGE_2007_SP1)

    __slots__ = &#39;_root&#39;,

    def __init__(self, **kwargs):
        self._root = kwargs.pop(&#39;root&#39;, None)  # This is a pointer to the root of the folder hierarchy
        parent = kwargs.pop(&#39;parent&#39;, None)
        if parent:
            if self.root:
                if parent.root != self.root:
                    raise ValueError(&#34;&#39;parent.root&#39; must match &#39;root&#39;&#34;)
            else:
                self.root = parent.root
            if &#39;parent_folder_id&#39; in kwargs and parent.id != kwargs[&#39;parent_folder_id&#39;]:
                raise ValueError(&#34;&#39;parent_folder_id&#39; must match &#39;parent&#39; ID&#34;)
            kwargs[&#39;parent_folder_id&#39;] = ParentFolderId(id=parent.id, changekey=parent.changekey)
        super().__init__(**kwargs)

    @property
    def account(self):
        if self.root is None:
            return None
        return self.root.account

    @property
    def root(self):
        return self._root

    @root.setter
    def root(self, value):
        self._root = value

    @classmethod
    def register(cls, *args, **kwargs):
        if cls is not Folder:
            raise TypeError(&#39;For folders, custom fields must be registered on the Folder class&#39;)
        return super().register(*args, **kwargs)

    @classmethod
    def deregister(cls, *args, **kwargs):
        if cls is not Folder:
            raise TypeError(&#39;For folders, custom fields must be registered on the Folder class&#39;)
        return super().deregister(*args, **kwargs)

    @classmethod
    def get_distinguished(cls, root):
        &#34;&#34;&#34;Get the distinguished folder for this folder class.

        :param root:
        :return:
        &#34;&#34;&#34;
        try:
            return cls.resolve(
                account=root.account,
                folder=cls(root=root, name=cls.DISTINGUISHED_FOLDER_ID, is_distinguished=True)
            )
        except MISSING_FOLDER_ERRORS:
            raise ErrorFolderNotFound(&#39;Could not find distinguished folder %r&#39; % cls.DISTINGUISHED_FOLDER_ID)

    @property
    def parent(self):
        if not self.parent_folder_id:
            return None
        if self.parent_folder_id.id == self.id:
            # Some folders have a parent that references itself. Avoid circular references here
            return None
        return self.root.get_folder(self.parent_folder_id)

    @parent.setter
    def parent(self, value):
        if value is None:
            self.parent_folder_id = None
        else:
            if not isinstance(value, BaseFolder):
                raise ValueError(&#34;&#39;value&#39; %r must be a Folder instance&#34; % value)
            self.root = value.root
            self.parent_folder_id = ParentFolderId(id=value.id, changekey=value.changekey)

    def clean(self, version=None):
        from .roots import RootOfHierarchy
        super().clean(version=version)
        if self.root and not isinstance(self.root, RootOfHierarchy):
            raise ValueError(&#34;&#39;root&#39; %r must be a RootOfHierarchy instance&#34; % self.root)

    @classmethod
    def from_xml_with_root(cls, elem, root):
        folder = cls.from_xml(elem=elem, account=root.account)
        folder_cls = cls
        if cls == Folder:
            # We were called on the generic Folder class. Try to find a more specific class to return objects as.
            #
            # The &#34;FolderClass&#34; element value is the only indication we have in the FindFolder response of which
            # folder class we should create the folder with. And many folders share the same &#39;FolderClass&#39; value, e.g.
            # Inbox and DeletedItems. We want to distinguish between these because otherwise we can&#39;t locate the right
            # folders types for e.g. Account.inbox and Account.trash.
            #
            # We should be able to just use the name, but apparently default folder names can be renamed to a set of
            # localized names using a PowerShell command:
            # https://docs.microsoft.com/en-us/powershell/module/exchange/client-access/Set-MailboxRegionalConfiguration
            #
            # Instead, search for a folder class using the localized name. If none are found, fall back to getting the
            # folder class by the &#34;FolderClass&#34; value.
            #
            # The returned XML may contain neither folder class nor name. In that case, we default to the generic
            # Folder class.
            if folder.name:
                try:
                    # TODO: fld_class.LOCALIZED_NAMES is most definitely neither complete nor authoritative
                    folder_cls = root.folder_cls_from_folder_name(folder_name=folder.name,
                                                                  locale=root.account.locale)
                    log.debug(&#39;Folder class %s matches localized folder name %s&#39;, folder_cls, folder.name)
                except KeyError:
                    pass
            if folder.folder_class and folder_cls == Folder:
                try:
                    folder_cls = cls.folder_cls_from_container_class(container_class=folder.folder_class)
                    log.debug(&#39;Folder class %s matches container class %s (%s)&#39;, folder_cls, folder.folder_class,
                              folder.name)
                except KeyError:
                    pass
            if folder_cls == Folder:
                log.debug(&#39;Fallback to class Folder (folder_class %s, name %s)&#39;, folder.folder_class, folder.name)
        return folder_cls(root=root, **{f.name: getattr(folder, f.name) for f in folder.FIELDS})</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.folders.base.BaseFolder" href="folders/base.html#exchangelib.folders.base.BaseFolder">BaseFolder</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
<li><a title="exchangelib.queryset.SearchableMixIn" href="queryset.html#exchangelib.queryset.SearchableMixIn">SearchableMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.folders.known_folders.AllItems" href="folders/known_folders.html#exchangelib.folders.known_folders.AllItems">AllItems</a></li>
<li><a title="exchangelib.folders.known_folders.Audits" href="folders/known_folders.html#exchangelib.folders.known_folders.Audits">Audits</a></li>
<li><a title="exchangelib.folders.known_folders.Calendar" href="folders/known_folders.html#exchangelib.folders.known_folders.Calendar">Calendar</a></li>
<li><a title="exchangelib.folders.known_folders.CalendarLogging" href="folders/known_folders.html#exchangelib.folders.known_folders.CalendarLogging">CalendarLogging</a></li>
<li><a title="exchangelib.folders.known_folders.CommonViews" href="folders/known_folders.html#exchangelib.folders.known_folders.CommonViews">CommonViews</a></li>
<li><a title="exchangelib.folders.known_folders.Contacts" href="folders/known_folders.html#exchangelib.folders.known_folders.Contacts">Contacts</a></li>
<li><a title="exchangelib.folders.known_folders.ConversationSettings" href="folders/known_folders.html#exchangelib.folders.known_folders.ConversationSettings">ConversationSettings</a></li>
<li><a title="exchangelib.folders.known_folders.DefaultFoldersChangeHistory" href="folders/known_folders.html#exchangelib.folders.known_folders.DefaultFoldersChangeHistory">DefaultFoldersChangeHistory</a></li>
<li><a title="exchangelib.folders.known_folders.DeferredAction" href="folders/known_folders.html#exchangelib.folders.known_folders.DeferredAction">DeferredAction</a></li>
<li><a title="exchangelib.folders.known_folders.DeletedItems" href="folders/known_folders.html#exchangelib.folders.known_folders.DeletedItems">DeletedItems</a></li>
<li><a title="exchangelib.folders.known_folders.ExchangeSyncData" href="folders/known_folders.html#exchangelib.folders.known_folders.ExchangeSyncData">ExchangeSyncData</a></li>
<li><a title="exchangelib.folders.known_folders.Files" href="folders/known_folders.html#exchangelib.folders.known_folders.Files">Files</a></li>
<li><a title="exchangelib.folders.known_folders.FreebusyData" href="folders/known_folders.html#exchangelib.folders.known_folders.FreebusyData">FreebusyData</a></li>
<li><a title="exchangelib.folders.known_folders.GraphAnalytics" href="folders/known_folders.html#exchangelib.folders.known_folders.GraphAnalytics">GraphAnalytics</a></li>
<li><a title="exchangelib.folders.known_folders.Location" href="folders/known_folders.html#exchangelib.folders.known_folders.Location">Location</a></li>
<li><a title="exchangelib.folders.known_folders.MailboxAssociations" href="folders/known_folders.html#exchangelib.folders.known_folders.MailboxAssociations">MailboxAssociations</a></li>
<li><a title="exchangelib.folders.known_folders.Messages" href="folders/known_folders.html#exchangelib.folders.known_folders.Messages">Messages</a></li>
<li><a title="exchangelib.folders.known_folders.ParkedMessages" href="folders/known_folders.html#exchangelib.folders.known_folders.ParkedMessages">ParkedMessages</a></li>
<li><a title="exchangelib.folders.known_folders.PassThroughSearchResults" href="folders/known_folders.html#exchangelib.folders.known_folders.PassThroughSearchResults">PassThroughSearchResults</a></li>
<li><a title="exchangelib.folders.known_folders.PdpProfileV2Secured" href="folders/known_folders.html#exchangelib.folders.known_folders.PdpProfileV2Secured">PdpProfileV2Secured</a></li>
<li><a title="exchangelib.folders.known_folders.RSSFeeds" href="folders/known_folders.html#exchangelib.folders.known_folders.RSSFeeds">RSSFeeds</a></li>
<li><a title="exchangelib.folders.known_folders.Reminders" href="folders/known_folders.html#exchangelib.folders.known_folders.Reminders">Reminders</a></li>
<li><a title="exchangelib.folders.known_folders.Schedule" href="folders/known_folders.html#exchangelib.folders.known_folders.Schedule">Schedule</a></li>
<li><a title="exchangelib.folders.known_folders.Sharing" href="folders/known_folders.html#exchangelib.folders.known_folders.Sharing">Sharing</a></li>
<li><a title="exchangelib.folders.known_folders.Shortcuts" href="folders/known_folders.html#exchangelib.folders.known_folders.Shortcuts">Shortcuts</a></li>
<li><a title="exchangelib.folders.known_folders.Signal" href="folders/known_folders.html#exchangelib.folders.known_folders.Signal">Signal</a></li>
<li><a title="exchangelib.folders.known_folders.SmsAndChatsSync" href="folders/known_folders.html#exchangelib.folders.known_folders.SmsAndChatsSync">SmsAndChatsSync</a></li>
<li><a title="exchangelib.folders.known_folders.SpoolerQueue" href="folders/known_folders.html#exchangelib.folders.known_folders.SpoolerQueue">SpoolerQueue</a></li>
<li><a title="exchangelib.folders.known_folders.System" href="folders/known_folders.html#exchangelib.folders.known_folders.System">System</a></li>
<li><a title="exchangelib.folders.known_folders.System1" href="folders/known_folders.html#exchangelib.folders.known_folders.System1">System1</a></li>
<li><a title="exchangelib.folders.known_folders.Tasks" href="folders/known_folders.html#exchangelib.folders.known_folders.Tasks">Tasks</a></li>
<li><a title="exchangelib.folders.known_folders.TemporarySaves" href="folders/known_folders.html#exchangelib.folders.known_folders.TemporarySaves">TemporarySaves</a></li>
<li><a title="exchangelib.folders.known_folders.Views" href="folders/known_folders.html#exchangelib.folders.known_folders.Views">Views</a></li>
<li><a title="exchangelib.folders.known_folders.WellknownFolder" href="folders/known_folders.html#exchangelib.folders.known_folders.WellknownFolder">WellknownFolder</a></li>
<li><a title="exchangelib.folders.known_folders.WorkingSet" href="folders/known_folders.html#exchangelib.folders.known_folders.WorkingSet">WorkingSet</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Folder.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.Folder.from_xml_with_root"><code class="name flex">
<span>def <span class="ident">from_xml_with_root</span></span>(<span>elem, root)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml_with_root(cls, elem, root):
    folder = cls.from_xml(elem=elem, account=root.account)
    folder_cls = cls
    if cls == Folder:
        # We were called on the generic Folder class. Try to find a more specific class to return objects as.
        #
        # The &#34;FolderClass&#34; element value is the only indication we have in the FindFolder response of which
        # folder class we should create the folder with. And many folders share the same &#39;FolderClass&#39; value, e.g.
        # Inbox and DeletedItems. We want to distinguish between these because otherwise we can&#39;t locate the right
        # folders types for e.g. Account.inbox and Account.trash.
        #
        # We should be able to just use the name, but apparently default folder names can be renamed to a set of
        # localized names using a PowerShell command:
        # https://docs.microsoft.com/en-us/powershell/module/exchange/client-access/Set-MailboxRegionalConfiguration
        #
        # Instead, search for a folder class using the localized name. If none are found, fall back to getting the
        # folder class by the &#34;FolderClass&#34; value.
        #
        # The returned XML may contain neither folder class nor name. In that case, we default to the generic
        # Folder class.
        if folder.name:
            try:
                # TODO: fld_class.LOCALIZED_NAMES is most definitely neither complete nor authoritative
                folder_cls = root.folder_cls_from_folder_name(folder_name=folder.name,
                                                              locale=root.account.locale)
                log.debug(&#39;Folder class %s matches localized folder name %s&#39;, folder_cls, folder.name)
            except KeyError:
                pass
        if folder.folder_class and folder_cls == Folder:
            try:
                folder_cls = cls.folder_cls_from_container_class(container_class=folder.folder_class)
                log.debug(&#39;Folder class %s matches container class %s (%s)&#39;, folder_cls, folder.folder_class,
                          folder.name)
            except KeyError:
                pass
        if folder_cls == Folder:
            log.debug(&#39;Fallback to class Folder (folder_class %s, name %s)&#39;, folder.folder_class, folder.name)
    return folder_cls(root=root, **{f.name: getattr(folder, f.name) for f in folder.FIELDS})</code></pre>
</details>
</dd>
<dt id="exchangelib.Folder.get_distinguished"><code class="name flex">
<span>def <span class="ident">get_distinguished</span></span>(<span>root)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the distinguished folder for this folder class.</p>
<p>:param root:
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_distinguished(cls, root):
    &#34;&#34;&#34;Get the distinguished folder for this folder class.

    :param root:
    :return:
    &#34;&#34;&#34;
    try:
        return cls.resolve(
            account=root.account,
            folder=cls(root=root, name=cls.DISTINGUISHED_FOLDER_ID, is_distinguished=True)
        )
    except MISSING_FOLDER_ERRORS:
        raise ErrorFolderNotFound(&#39;Could not find distinguished folder %r&#39; % cls.DISTINGUISHED_FOLDER_ID)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Folder.account"><code class="name">var <span class="ident">account</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def account(self):
    if self.root is None:
        return None
    return self.root.account</code></pre>
</details>
</dd>
<dt id="exchangelib.Folder.effective_rights"><code class="name">var <span class="ident">effective_rights</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Folder.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    if not self.parent_folder_id:
        return None
    if self.parent_folder_id.id == self.id:
        # Some folders have a parent that references itself. Avoid circular references here
        return None
    return self.root.get_folder(self.parent_folder_id)</code></pre>
</details>
</dd>
<dt id="exchangelib.Folder.permission_set"><code class="name">var <span class="ident">permission_set</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Folder.root"><code class="name">var <span class="ident">root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def root(self):
    return self._root</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Folder.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, version=None):
    from .roots import RootOfHierarchy
    super().clean(version=version)
    if self.root and not isinstance(self.root, RootOfHierarchy):
        raise ValueError(&#34;&#39;root&#39; %r must be a RootOfHierarchy instance&#34; % self.root)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.folders.base.BaseFolder" href="folders/base.html#exchangelib.folders.base.BaseFolder">BaseFolder</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.folders.base.BaseFolder.ID_ELEMENT_CLS" href="folders/base.html#exchangelib.folders.base.BaseFolder.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.folder_cls_from_container_class" href="folders/base.html#exchangelib.folders.base.BaseFolder.folder_cls_from_container_class">folder_cls_from_container_class</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.folder_sync_state" href="folders/base.html#exchangelib.folders.base.BaseFolder.folder_sync_state">folder_sync_state</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.get_events" href="folders/base.html#exchangelib.folders.base.BaseFolder.get_events">get_events</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.get_streaming_events" href="folders/base.html#exchangelib.folders.base.BaseFolder.get_streaming_events">get_streaming_events</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.is_distinguished" href="folders/base.html#exchangelib.folders.base.BaseFolder.is_distinguished">is_distinguished</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.item_sync_state" href="folders/base.html#exchangelib.folders.base.BaseFolder.item_sync_state">item_sync_state</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.subscribe_to_pull" href="folders/base.html#exchangelib.folders.base.BaseFolder.subscribe_to_pull">subscribe_to_pull</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.subscribe_to_push" href="folders/base.html#exchangelib.folders.base.BaseFolder.subscribe_to_push">subscribe_to_push</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.subscribe_to_streaming" href="folders/base.html#exchangelib.folders.base.BaseFolder.subscribe_to_streaming">subscribe_to_streaming</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.sync_hierarchy" href="folders/base.html#exchangelib.folders.base.BaseFolder.sync_hierarchy">sync_hierarchy</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.sync_items" href="folders/base.html#exchangelib.folders.base.BaseFolder.sync_items">sync_items</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.test_access" href="folders/base.html#exchangelib.folders.base.BaseFolder.test_access">test_access</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.tree" href="folders/base.html#exchangelib.folders.base.BaseFolder.tree">tree</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.unsubscribe" href="folders/base.html#exchangelib.folders.base.BaseFolder.unsubscribe">unsubscribe</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.FolderCollection"><code class="flex name class">
<span>class <span class="ident">FolderCollection</span></span>
<span>(</span><span>account, folders)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that implements an API for searching folders.</p>
<p>Implement a search API on a collection of folders.</p>
<p>:param account: An Account object
:param folders: An iterable of folders, e.g. Folder.walk(), Folder.glob(), or [a.calendar, a.inbox]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FolderCollection(SearchableMixIn):
    &#34;&#34;&#34;A class that implements an API for searching folders.&#34;&#34;&#34;

    # These fields are required in a FindFolder or GetFolder call to properly identify folder types
    REQUIRED_FOLDER_FIELDS = (&#39;name&#39;, &#39;folder_class&#39;)

    def __init__(self, account, folders):
        &#34;&#34;&#34;Implement a search API on a collection of folders.

        :param account: An Account object
        :param folders: An iterable of folders, e.g. Folder.walk(), Folder.glob(), or [a.calendar, a.inbox]
        &#34;&#34;&#34;
        self.account = account
        self._folders = folders

    @threaded_cached_property
    def folders(self):
        # Resolve the list of folders, in case it&#39;s a generator
        return list(self._folders)

    def __len__(self):
        return len(self.folders)

    def __iter__(self):
        yield from self.folders

    def get(self, *args, **kwargs):
        return QuerySet(self).get(*args, **kwargs)

    def all(self):
        return QuerySet(self).all()

    def none(self):
        return QuerySet(self).none()

    def filter(self, *args, **kwargs):
        &#34;&#34;&#34;Find items in the folder(s).

        Non-keyword args may be a list of Q instances.

        Optional extra keyword arguments follow a Django-like QuerySet filter syntax (see
           https://docs.djangoproject.com/en/1.10/ref/models/querysets/#field-lookups).

        We don&#39;t support &#39;__year&#39; and other date-related lookups. We also don&#39;t support &#39;__endswith&#39; or &#39;__iendswith&#39;.

        We support the additional &#39;__not&#39; lookup in place of Django&#39;s exclude() for simple cases. For more complicated
        cases you need to create a Q object and use ~Q().

        Examples:

            my_account.inbox.filter(datetime_received__gt=EWSDateTime(2016, 1, 1))
            my_account.calendar.filter(start__range=(EWSDateTime(2016, 1, 1), EWSDateTime(2017, 1, 1)))
            my_account.tasks.filter(subject=&#39;Hi mom&#39;)
            my_account.tasks.filter(subject__not=&#39;Hi mom&#39;)
            my_account.tasks.filter(subject__contains=&#39;Foo&#39;)
            my_account.tasks.filter(subject__icontains=&#39;foo&#39;)

        &#39;endswith&#39; and &#39;iendswith&#39; could be emulated by searching with &#39;contains&#39; or &#39;icontains&#39; and then
        post-processing items. Fetch the field in question with additional_fields and remove items where the search
        string is not a postfix.
        &#34;&#34;&#34;
        return QuerySet(self).filter(*args, **kwargs)

    def exclude(self, *args, **kwargs):
        return QuerySet(self).exclude(*args, **kwargs)

    def people(self):
        return QuerySet(self).people()

    def view(self, start, end, max_items=None, *args, **kwargs):
        &#34;&#34;&#34;Implement the CalendarView option to FindItem. The difference between &#39;filter&#39; and &#39;view&#39; is that &#39;filter&#39;
        only returns the master CalendarItem for recurring items, while &#39;view&#39; unfolds recurring items and returns all
        CalendarItem occurrences as one would normally expect when presenting a calendar.

        Supports the same semantics as filter, except for &#39;start&#39; and &#39;end&#39; keyword attributes which are both required
        and behave differently than filter. Here, they denote the start and end of the timespan of the view. All items
        the overlap the timespan are returned (items that end exactly on &#39;start&#39; are also returned, for some reason).

        EWS does not allow combining CalendarView with search restrictions (filter and exclude).

        &#39;max_items&#39; defines the maximum number of items returned in this view. Optional.

        :param start:
        :param end:
        :param max_items:  (Default value = None)
        :return:
        &#34;&#34;&#34;
        qs = QuerySet(self).filter(*args, **kwargs)
        qs.calendar_view = CalendarView(start=start, end=end, max_items=max_items)
        return qs

    def allowed_item_fields(self):
        # Return non-ID fields of all item classes allowed in this folder type
        fields = set()
        for item_model in self.supported_item_models:
            fields.update(set(item_model.supported_fields(version=self.account.version)))
        return fields

    @property
    def supported_item_models(self):
        return tuple(item_model for folder in self.folders for item_model in folder.supported_item_models)

    def validate_item_field(self, field, version):
        # For each field, check if the field is valid for any of the item models supported by this folder
        for item_model in self.supported_item_models:
            try:
                item_model.validate_field(field=field, version=version)
                break
            except InvalidField:
                continue
        else:
            raise InvalidField(&#34;%r is not a valid field on %s&#34; % (field, self.supported_item_models))

    def find_items(self, q, shape=ID_ONLY, depth=None, additional_fields=None, order_fields=None,
                   calendar_view=None, page_size=None, max_items=None, offset=0):
        &#34;&#34;&#34;Private method to call the FindItem service.

        :param q: a Q instance containing any restrictions
        :param shape: controls whether to return (id, chanegkey) tuples or Item objects. If additional_fields is
          non-null, we always return Item objects. (Default value = ID_ONLY)
        :param depth: controls the whether to return soft-deleted items or not. (Default value = None)
        :param additional_fields: the extra properties we want on the return objects. Default is no properties. Be aware
          that complex fields can only be fetched with fetch() (i.e. the GetItem service).
        :param order_fields: the SortOrder fields, if any (Default value = None)
        :param calendar_view: a CalendarView instance, if any (Default value = None)
        :param page_size: the requested number of items per page (Default value = None)
        :param max_items: the max number of items to return (Default value = None)
        :param offset: the offset relative to the first item in the item collection (Default value = 0)

        :return: a generator for the returned item IDs or items
        &#34;&#34;&#34;
        if not self.folders:
            log.debug(&#39;Folder list is empty&#39;)
            return
        if q.is_never():
            log.debug(&#39;Query will never return results&#39;)
            return
        if shape not in SHAPE_CHOICES:
            raise ValueError(&#34;&#39;shape&#39; %s must be one of %s&#34; % (shape, SHAPE_CHOICES))
        if depth is None:
            depth = self._get_default_item_traversal_depth()
        if depth not in ITEM_TRAVERSAL_CHOICES:
            raise ValueError(&#34;&#39;depth&#39; %s must be one of %s&#34; % (depth, ITEM_TRAVERSAL_CHOICES))
        if additional_fields:
            for f in additional_fields:
                self.validate_item_field(field=f, version=self.account.version)
                if f.field.is_complex:
                    raise ValueError(&#34;find_items() does not support field &#39;%s&#39;. Use fetch() instead&#34; % f.field.name)
        if calendar_view is not None and not isinstance(calendar_view, CalendarView):
            raise ValueError(&#34;&#39;calendar_view&#39; %s must be a CalendarView instance&#34; % calendar_view)

        # Build up any restrictions
        if q.is_empty():
            restriction = None
            query_string = None
        elif q.query_string:
            restriction = None
            query_string = Restriction(q, folders=self.folders, applies_to=Restriction.ITEMS)
        else:
            restriction = Restriction(q, folders=self.folders, applies_to=Restriction.ITEMS)
            query_string = None
        log.debug(
            &#39;Finding %s items in folders %s (shape: %s, depth: %s, additional_fields: %s, restriction: %s)&#39;,
            self.folders,
            self.account,
            shape,
            depth,
            additional_fields,
            restriction.q if restriction else None,
        )
        yield from FindItem(account=self.account, chunk_size=page_size).call(
            folders=self.folders,
            additional_fields=additional_fields,
            restriction=restriction,
            order_fields=order_fields,
            shape=shape,
            query_string=query_string,
            depth=depth,
            calendar_view=calendar_view,
            max_items=calendar_view.max_items if calendar_view else max_items,
            offset=offset,
        )

    def _get_single_folder(self):
        if len(self.folders) &gt; 1:
            raise ValueError(&#39;Syncing folder hierarchy can only be done on a single folder&#39;)
        if not self.folders:
            log.debug(&#39;Folder list is empty&#39;)
            return None
        return self.folders[0]

    def find_people(self, q, shape=ID_ONLY, depth=None, additional_fields=None, order_fields=None,
                    page_size=None, max_items=None, offset=0):
        &#34;&#34;&#34;Private method to call the FindPeople service.

        :param q: a Q instance containing any restrictions
        :param shape: controls whether to return (id, chanegkey) tuples or Persona objects. If additional_fields is
          non-null, we always return Persona objects. (Default value = ID_ONLY)
        :param depth: controls the whether to return soft-deleted items or not. (Default value = None)
        :param additional_fields: the extra properties we want on the return objects. Default is no properties.
        :param order_fields: the SortOrder fields, if any (Default value = None)
        :param page_size: the requested number of items per page (Default value = None)
        :param max_items: the max number of items to return (Default value = None)
        :param offset: the offset relative to the first item in the item collection (Default value = 0)

        :return: a generator for the returned personas
        &#34;&#34;&#34;
        folder = self._get_single_folder()
        if not folder:
            return
        if q.is_never():
            log.debug(&#39;Query will never return results&#39;)
            return
        if shape not in SHAPE_CHOICES:
            raise ValueError(&#34;&#39;shape&#39; %s must be one of %s&#34; % (shape, SHAPE_CHOICES))
        if depth is None:
            depth = self._get_default_item_traversal_depth()
        if depth not in ITEM_TRAVERSAL_CHOICES:
            raise ValueError(&#34;&#39;depth&#39; %s must be one of %s&#34; % (depth, ITEM_TRAVERSAL_CHOICES))
        if additional_fields:
            for f in additional_fields:
                Persona.validate_field(field=f, version=self.account.version)
                if f.field.is_complex:
                    raise ValueError(&#34;find_people() does not support field &#39;%s&#39;&#34; % f.field.name)

        # Build up any restrictions
        if q.is_empty():
            restriction = None
            query_string = None
        elif q.query_string:
            restriction = None
            query_string = Restriction(q, folders=[folder], applies_to=Restriction.ITEMS)
        else:
            restriction = Restriction(q, folders=[folder], applies_to=Restriction.ITEMS)
            query_string = None
        yield from FindPeople(account=self.account, chunk_size=page_size).call(
                folder=[folder],
                additional_fields=additional_fields,
                restriction=restriction,
                order_fields=order_fields,
                shape=shape,
                query_string=query_string,
                depth=depth,
                max_items=max_items,
                offset=offset,
        )

    def get_folder_fields(self, target_cls, is_complex=None):
        return {
            FieldPath(field=f) for f in target_cls.supported_fields(version=self.account.version)
            if is_complex is None or f.is_complex is is_complex
        }

    def _get_target_cls(self):
        # We may have root folders that don&#39;t support the same set of fields as normal folders. If there is a mix of
        # both folder types in self.folders, raise an error so we don&#39;t risk losing some fields in the query.
        from .base import Folder
        from .roots import RootOfHierarchy
        has_roots = False
        has_non_roots = False
        for f in self.folders:
            if isinstance(f, RootOfHierarchy):
                if has_non_roots:
                    raise ValueError(&#39;Cannot call GetFolder on a mix of folder types: {}&#39;.format(self.folders))
                has_roots = True
            else:
                if has_roots:
                    raise ValueError(&#39;Cannot call GetFolder on a mix of folder types: {}&#39;.format(self.folders))
                has_non_roots = True
        return RootOfHierarchy if has_roots else Folder

    def _get_default_traversal_depth(self, traversal_attr):
        unique_depths = {getattr(f, traversal_attr) for f in self.folders}
        if len(unique_depths) == 1:
            return unique_depths.pop()
        raise ValueError(
            &#39;Folders in this collection do not have a common %s value. You need to define an explicit traversal depth&#39;
            &#39;with QuerySet.depth() (values: %s)&#39; % (traversal_attr, unique_depths)
        )

    def _get_default_item_traversal_depth(self):
        # When searching folders, some folders require &#39;Shallow&#39; and others &#39;Associated&#39; traversal depth.
        return self._get_default_traversal_depth(&#39;DEFAULT_ITEM_TRAVERSAL_DEPTH&#39;)

    def _get_default_folder_traversal_depth(self):
        # When searching folders, some folders require &#39;Shallow&#39; and others &#39;Deep&#39; traversal depth.
        return self._get_default_traversal_depth(&#39;DEFAULT_FOLDER_TRAVERSAL_DEPTH&#39;)

    def resolve(self):
        # Looks up the folders or folder IDs in the collection and returns full Folder instances with all fields set.
        from .base import BaseFolder
        resolveable_folders = []
        for f in self.folders:
            if isinstance(f, BaseFolder) and not f.get_folder_allowed:
                log.debug(&#39;GetFolder not allowed on folder %s. Non-complex fields must be fetched with FindFolder&#39;, f)
                yield f
            else:
                resolveable_folders.append(f)
        # Fetch all properties for the remaining folders of folder IDs
        additional_fields = self.get_folder_fields(target_cls=self._get_target_cls(), is_complex=None)
        yield from self.__class__(account=self.account, folders=resolveable_folders).get_folders(
                additional_fields=additional_fields
        )

    @require_account
    def find_folders(self, q=None, shape=ID_ONLY, depth=None, additional_fields=None, page_size=None, max_items=None,
                     offset=0):
        # &#39;depth&#39; controls whether to return direct children or recurse into sub-folders
        from .base import BaseFolder, Folder
        if q is None:
            q = Q()
        if not self.folders:
            log.debug(&#39;Folder list is empty&#39;)
            return
        if q.is_never():
            log.debug(&#39;Query will never return results&#39;)
            return
        if q.is_empty():
            restriction = None
        else:
            restriction = Restriction(q, folders=self.folders, applies_to=Restriction.FOLDERS)
        if shape not in SHAPE_CHOICES:
            raise ValueError(&#34;&#39;shape&#39; %s must be one of %s&#34; % (shape, SHAPE_CHOICES))
        if depth is None:
            depth = self._get_default_folder_traversal_depth()
        if depth not in FOLDER_TRAVERSAL_CHOICES:
            raise ValueError(&#34;&#39;depth&#39; %s must be one of %s&#34; % (depth, FOLDER_TRAVERSAL_CHOICES))
        if additional_fields is None:
            # Default to all non-complex properties. Subfolders will always be of class Folder
            additional_fields = self.get_folder_fields(target_cls=Folder, is_complex=False)
        else:
            for f in additional_fields:
                if f.field.is_complex:
                    raise ValueError(&#34;find_folders() does not support field &#39;%s&#39;. Use get_folders().&#34; % f.field.name)

        # Add required fields
        additional_fields.update(
            (FieldPath(field=BaseFolder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
        )

        yield from FindFolder(account=self.account, chunk_size=page_size).call(
                folders=self.folders,
                additional_fields=additional_fields,
                restriction=restriction,
                shape=shape,
                depth=depth,
                max_items=max_items,
                offset=offset,
        )

    def get_folders(self, additional_fields=None):
        # Expand folders with their full set of properties
        from .base import BaseFolder
        if not self.folders:
            log.debug(&#39;Folder list is empty&#39;)
            return
        if additional_fields is None:
            # Default to all complex properties
            additional_fields = self.get_folder_fields(target_cls=self._get_target_cls(), is_complex=True)

        # Add required fields
        additional_fields.update(
            (FieldPath(field=BaseFolder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
        )

        yield from GetFolder(account=self.account).call(
                folders=self.folders,
                additional_fields=additional_fields,
                shape=ID_ONLY,
        )

    def subscribe_to_pull(self, event_types=SubscribeToPull.EVENT_TYPES, watermark=None, timeout=60):
        if not self.folders:
            log.debug(&#39;Folder list is empty&#39;)
            return
        yield from SubscribeToPull(account=self.account).call(
            folders=self.folders, event_types=event_types, watermark=watermark, timeout=timeout,
        )

    def subscribe_to_push(self, callback_url, event_types=SubscribeToPush.EVENT_TYPES, watermark=None,
                          status_frequency=1):
        if not self.folders:
            log.debug(&#39;Folder list is empty&#39;)
            return
        yield from SubscribeToPush(account=self.account).call(
            folders=self.folders, event_types=event_types, watermark=watermark, status_frequency=status_frequency,
            url=callback_url,
        )

    def subscribe_to_streaming(self, event_types=SubscribeToPush.EVENT_TYPES):
        if not self.folders:
            log.debug(&#39;Folder list is empty&#39;)
            return
        yield from SubscribeToStreaming(account=self.account).call(folders=self.folders, event_types=event_types)

    def sync_items(self, sync_state=None, only_fields=None, ignore=None, max_changes_returned=None, sync_scope=None):
        folder = self._get_single_folder()
        if not folder:
            return
        if only_fields is None:
            # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
            additional_fields = {FieldPath(field=f) for f in folder.allowed_item_fields(version=self.account.version)}
        else:
            for field in only_fields:
                folder.validate_item_field(field=field, version=self.account.version)
            # Remove ItemId and ChangeKey. We get them unconditionally
            additional_fields = {f for f in folder.normalize_fields(fields=only_fields) if not f.field.is_attribute}

        svc = SyncFolderItems(account=self.account)
        while True:
            yield from svc.call(
                folder=folder,
                shape=ID_ONLY,
                additional_fields=additional_fields,
                sync_state=sync_state,
                ignore=ignore,
                max_changes_returned=max_changes_returned,
                sync_scope=sync_scope,
            )
            if svc.sync_state == sync_state:
                # We sometimes get the same sync_state back, even though includes_last_item_in_range is False. Stop here
                break
            sync_state = svc.sync_state  # Set the new sync state in the next call
            if svc.includes_last_item_in_range:  # Try again if there are more items
                break
        raise SyncCompleted(sync_state=svc.sync_state)

    def sync_hierarchy(self, sync_state=None, only_fields=None):
        folder = self._get_single_folder()
        if not folder:
            return
        if only_fields is None:
            # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
            additional_fields = {FieldPath(field=f) for f in folder.supported_fields(version=self.account.version)}
        else:
            for f in only_fields:
                folder.validate_field(field=f, version=self.account.version)
            # Remove ItemId and ChangeKey. We get them unconditionally
            additional_fields = {f for f in folder.normalize_fields(fields=only_fields) if not f.field.is_attribute}

        # Add required fields
        additional_fields.update(
            (FieldPath(field=folder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
        )

        svc = SyncFolderHierarchy(account=self.account)
        while True:
            yield from svc.call(
                folder=folder,
                shape=ID_ONLY,
                additional_fields=additional_fields,
                sync_state=sync_state,
            )
            if svc.sync_state == sync_state:
                # We sometimes get the same sync_state back, even though includes_last_item_in_range is False. Stop here
                break
            sync_state = svc.sync_state  # Set the new sync state in the next call
            if svc.includes_last_item_in_range:  # Try again if there are more items
                break
        raise SyncCompleted(sync_state=svc.sync_state)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.queryset.SearchableMixIn" href="queryset.html#exchangelib.queryset.SearchableMixIn">SearchableMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.FolderCollection.REQUIRED_FOLDER_FIELDS"><code class="name">var <span class="ident">REQUIRED_FOLDER_FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.FolderCollection.folders"><code class="name">var <span class="ident">folders</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.supported_item_models"><code class="name">var <span class="ident">supported_item_models</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def supported_item_models(self):
    return tuple(item_model for folder in self.folders for item_model in folder.supported_item_models)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.FolderCollection.all"><code class="name flex">
<span>def <span class="ident">all</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def all(self):
    return QuerySet(self).all()</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.allowed_item_fields"><code class="name flex">
<span>def <span class="ident">allowed_item_fields</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allowed_item_fields(self):
    # Return non-ID fields of all item classes allowed in this folder type
    fields = set()
    for item_model in self.supported_item_models:
        fields.update(set(item_model.supported_fields(version=self.account.version)))
    return fields</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.exclude"><code class="name flex">
<span>def <span class="ident">exclude</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exclude(self, *args, **kwargs):
    return QuerySet(self).exclude(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Find items in the folder(s).</p>
<p>Non-keyword args may be a list of Q instances.</p>
<p>Optional extra keyword arguments follow a Django-like QuerySet filter syntax (see
<a href="https://docs.djangoproject.com/en/1.10/ref/models/querysets/#field-lookups">https://docs.djangoproject.com/en/1.10/ref/models/querysets/#field-lookups</a>).</p>
<p>We don't support '__year' and other date-related lookups. We also don't support '__endswith' or '__iendswith'.</p>
<p>We support the additional '__not' lookup in place of Django's exclude() for simple cases. For more complicated
cases you need to create a Q object and use ~Q().</p>
<h2 id="examples">Examples</h2>
<p>my_account.inbox.filter(datetime_received__gt=EWSDateTime(2016, 1, 1))
my_account.calendar.filter(start__range=(EWSDateTime(2016, 1, 1), EWSDateTime(2017, 1, 1)))
my_account.tasks.filter(subject='Hi mom')
my_account.tasks.filter(subject__not='Hi mom')
my_account.tasks.filter(subject__contains='Foo')
my_account.tasks.filter(subject__icontains='foo')</p>
<p>'endswith' and 'iendswith' could be emulated by searching with 'contains' or 'icontains' and then
post-processing items. Fetch the field in question with additional_fields and remove items where the search
string is not a postfix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, *args, **kwargs):
    &#34;&#34;&#34;Find items in the folder(s).

    Non-keyword args may be a list of Q instances.

    Optional extra keyword arguments follow a Django-like QuerySet filter syntax (see
       https://docs.djangoproject.com/en/1.10/ref/models/querysets/#field-lookups).

    We don&#39;t support &#39;__year&#39; and other date-related lookups. We also don&#39;t support &#39;__endswith&#39; or &#39;__iendswith&#39;.

    We support the additional &#39;__not&#39; lookup in place of Django&#39;s exclude() for simple cases. For more complicated
    cases you need to create a Q object and use ~Q().

    Examples:

        my_account.inbox.filter(datetime_received__gt=EWSDateTime(2016, 1, 1))
        my_account.calendar.filter(start__range=(EWSDateTime(2016, 1, 1), EWSDateTime(2017, 1, 1)))
        my_account.tasks.filter(subject=&#39;Hi mom&#39;)
        my_account.tasks.filter(subject__not=&#39;Hi mom&#39;)
        my_account.tasks.filter(subject__contains=&#39;Foo&#39;)
        my_account.tasks.filter(subject__icontains=&#39;foo&#39;)

    &#39;endswith&#39; and &#39;iendswith&#39; could be emulated by searching with &#39;contains&#39; or &#39;icontains&#39; and then
    post-processing items. Fetch the field in question with additional_fields and remove items where the search
    string is not a postfix.
    &#34;&#34;&#34;
    return QuerySet(self).filter(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.find_folders"><code class="name flex">
<span>def <span class="ident">find_folders</span></span>(<span>self, q=None, shape='IdOnly', depth=None, additional_fields=None, page_size=None, max_items=None, offset=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_account
def find_folders(self, q=None, shape=ID_ONLY, depth=None, additional_fields=None, page_size=None, max_items=None,
                 offset=0):
    # &#39;depth&#39; controls whether to return direct children or recurse into sub-folders
    from .base import BaseFolder, Folder
    if q is None:
        q = Q()
    if not self.folders:
        log.debug(&#39;Folder list is empty&#39;)
        return
    if q.is_never():
        log.debug(&#39;Query will never return results&#39;)
        return
    if q.is_empty():
        restriction = None
    else:
        restriction = Restriction(q, folders=self.folders, applies_to=Restriction.FOLDERS)
    if shape not in SHAPE_CHOICES:
        raise ValueError(&#34;&#39;shape&#39; %s must be one of %s&#34; % (shape, SHAPE_CHOICES))
    if depth is None:
        depth = self._get_default_folder_traversal_depth()
    if depth not in FOLDER_TRAVERSAL_CHOICES:
        raise ValueError(&#34;&#39;depth&#39; %s must be one of %s&#34; % (depth, FOLDER_TRAVERSAL_CHOICES))
    if additional_fields is None:
        # Default to all non-complex properties. Subfolders will always be of class Folder
        additional_fields = self.get_folder_fields(target_cls=Folder, is_complex=False)
    else:
        for f in additional_fields:
            if f.field.is_complex:
                raise ValueError(&#34;find_folders() does not support field &#39;%s&#39;. Use get_folders().&#34; % f.field.name)

    # Add required fields
    additional_fields.update(
        (FieldPath(field=BaseFolder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
    )

    yield from FindFolder(account=self.account, chunk_size=page_size).call(
            folders=self.folders,
            additional_fields=additional_fields,
            restriction=restriction,
            shape=shape,
            depth=depth,
            max_items=max_items,
            offset=offset,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.find_items"><code class="name flex">
<span>def <span class="ident">find_items</span></span>(<span>self, q, shape='IdOnly', depth=None, additional_fields=None, order_fields=None, calendar_view=None, page_size=None, max_items=None, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Private method to call the FindItem service.</p>
<p>:param q: a Q instance containing any restrictions
:param shape: controls whether to return (id, chanegkey) tuples or Item objects. If additional_fields is
non-null, we always return Item objects. (Default value = ID_ONLY)
:param depth: controls the whether to return soft-deleted items or not. (Default value = None)
:param additional_fields: the extra properties we want on the return objects. Default is no properties. Be aware
that complex fields can only be fetched with fetch() (i.e. the GetItem service).
:param order_fields: the SortOrder fields, if any (Default value = None)
:param calendar_view: a CalendarView instance, if any (Default value = None)
:param page_size: the requested number of items per page (Default value = None)
:param max_items: the max number of items to return (Default value = None)
:param offset: the offset relative to the first item in the item collection (Default value = 0)</p>
<p>:return: a generator for the returned item IDs or items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_items(self, q, shape=ID_ONLY, depth=None, additional_fields=None, order_fields=None,
               calendar_view=None, page_size=None, max_items=None, offset=0):
    &#34;&#34;&#34;Private method to call the FindItem service.

    :param q: a Q instance containing any restrictions
    :param shape: controls whether to return (id, chanegkey) tuples or Item objects. If additional_fields is
      non-null, we always return Item objects. (Default value = ID_ONLY)
    :param depth: controls the whether to return soft-deleted items or not. (Default value = None)
    :param additional_fields: the extra properties we want on the return objects. Default is no properties. Be aware
      that complex fields can only be fetched with fetch() (i.e. the GetItem service).
    :param order_fields: the SortOrder fields, if any (Default value = None)
    :param calendar_view: a CalendarView instance, if any (Default value = None)
    :param page_size: the requested number of items per page (Default value = None)
    :param max_items: the max number of items to return (Default value = None)
    :param offset: the offset relative to the first item in the item collection (Default value = 0)

    :return: a generator for the returned item IDs or items
    &#34;&#34;&#34;
    if not self.folders:
        log.debug(&#39;Folder list is empty&#39;)
        return
    if q.is_never():
        log.debug(&#39;Query will never return results&#39;)
        return
    if shape not in SHAPE_CHOICES:
        raise ValueError(&#34;&#39;shape&#39; %s must be one of %s&#34; % (shape, SHAPE_CHOICES))
    if depth is None:
        depth = self._get_default_item_traversal_depth()
    if depth not in ITEM_TRAVERSAL_CHOICES:
        raise ValueError(&#34;&#39;depth&#39; %s must be one of %s&#34; % (depth, ITEM_TRAVERSAL_CHOICES))
    if additional_fields:
        for f in additional_fields:
            self.validate_item_field(field=f, version=self.account.version)
            if f.field.is_complex:
                raise ValueError(&#34;find_items() does not support field &#39;%s&#39;. Use fetch() instead&#34; % f.field.name)
    if calendar_view is not None and not isinstance(calendar_view, CalendarView):
        raise ValueError(&#34;&#39;calendar_view&#39; %s must be a CalendarView instance&#34; % calendar_view)

    # Build up any restrictions
    if q.is_empty():
        restriction = None
        query_string = None
    elif q.query_string:
        restriction = None
        query_string = Restriction(q, folders=self.folders, applies_to=Restriction.ITEMS)
    else:
        restriction = Restriction(q, folders=self.folders, applies_to=Restriction.ITEMS)
        query_string = None
    log.debug(
        &#39;Finding %s items in folders %s (shape: %s, depth: %s, additional_fields: %s, restriction: %s)&#39;,
        self.folders,
        self.account,
        shape,
        depth,
        additional_fields,
        restriction.q if restriction else None,
    )
    yield from FindItem(account=self.account, chunk_size=page_size).call(
        folders=self.folders,
        additional_fields=additional_fields,
        restriction=restriction,
        order_fields=order_fields,
        shape=shape,
        query_string=query_string,
        depth=depth,
        calendar_view=calendar_view,
        max_items=calendar_view.max_items if calendar_view else max_items,
        offset=offset,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.find_people"><code class="name flex">
<span>def <span class="ident">find_people</span></span>(<span>self, q, shape='IdOnly', depth=None, additional_fields=None, order_fields=None, page_size=None, max_items=None, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Private method to call the FindPeople service.</p>
<p>:param q: a Q instance containing any restrictions
:param shape: controls whether to return (id, chanegkey) tuples or Persona objects. If additional_fields is
non-null, we always return Persona objects. (Default value = ID_ONLY)
:param depth: controls the whether to return soft-deleted items or not. (Default value = None)
:param additional_fields: the extra properties we want on the return objects. Default is no properties.
:param order_fields: the SortOrder fields, if any (Default value = None)
:param page_size: the requested number of items per page (Default value = None)
:param max_items: the max number of items to return (Default value = None)
:param offset: the offset relative to the first item in the item collection (Default value = 0)</p>
<p>:return: a generator for the returned personas</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_people(self, q, shape=ID_ONLY, depth=None, additional_fields=None, order_fields=None,
                page_size=None, max_items=None, offset=0):
    &#34;&#34;&#34;Private method to call the FindPeople service.

    :param q: a Q instance containing any restrictions
    :param shape: controls whether to return (id, chanegkey) tuples or Persona objects. If additional_fields is
      non-null, we always return Persona objects. (Default value = ID_ONLY)
    :param depth: controls the whether to return soft-deleted items or not. (Default value = None)
    :param additional_fields: the extra properties we want on the return objects. Default is no properties.
    :param order_fields: the SortOrder fields, if any (Default value = None)
    :param page_size: the requested number of items per page (Default value = None)
    :param max_items: the max number of items to return (Default value = None)
    :param offset: the offset relative to the first item in the item collection (Default value = 0)

    :return: a generator for the returned personas
    &#34;&#34;&#34;
    folder = self._get_single_folder()
    if not folder:
        return
    if q.is_never():
        log.debug(&#39;Query will never return results&#39;)
        return
    if shape not in SHAPE_CHOICES:
        raise ValueError(&#34;&#39;shape&#39; %s must be one of %s&#34; % (shape, SHAPE_CHOICES))
    if depth is None:
        depth = self._get_default_item_traversal_depth()
    if depth not in ITEM_TRAVERSAL_CHOICES:
        raise ValueError(&#34;&#39;depth&#39; %s must be one of %s&#34; % (depth, ITEM_TRAVERSAL_CHOICES))
    if additional_fields:
        for f in additional_fields:
            Persona.validate_field(field=f, version=self.account.version)
            if f.field.is_complex:
                raise ValueError(&#34;find_people() does not support field &#39;%s&#39;&#34; % f.field.name)

    # Build up any restrictions
    if q.is_empty():
        restriction = None
        query_string = None
    elif q.query_string:
        restriction = None
        query_string = Restriction(q, folders=[folder], applies_to=Restriction.ITEMS)
    else:
        restriction = Restriction(q, folders=[folder], applies_to=Restriction.ITEMS)
        query_string = None
    yield from FindPeople(account=self.account, chunk_size=page_size).call(
            folder=[folder],
            additional_fields=additional_fields,
            restriction=restriction,
            order_fields=order_fields,
            shape=shape,
            query_string=query_string,
            depth=depth,
            max_items=max_items,
            offset=offset,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, *args, **kwargs):
    return QuerySet(self).get(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.get_folder_fields"><code class="name flex">
<span>def <span class="ident">get_folder_fields</span></span>(<span>self, target_cls, is_complex=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_folder_fields(self, target_cls, is_complex=None):
    return {
        FieldPath(field=f) for f in target_cls.supported_fields(version=self.account.version)
        if is_complex is None or f.is_complex is is_complex
    }</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.get_folders"><code class="name flex">
<span>def <span class="ident">get_folders</span></span>(<span>self, additional_fields=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_folders(self, additional_fields=None):
    # Expand folders with their full set of properties
    from .base import BaseFolder
    if not self.folders:
        log.debug(&#39;Folder list is empty&#39;)
        return
    if additional_fields is None:
        # Default to all complex properties
        additional_fields = self.get_folder_fields(target_cls=self._get_target_cls(), is_complex=True)

    # Add required fields
    additional_fields.update(
        (FieldPath(field=BaseFolder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
    )

    yield from GetFolder(account=self.account).call(
            folders=self.folders,
            additional_fields=additional_fields,
            shape=ID_ONLY,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.none"><code class="name flex">
<span>def <span class="ident">none</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def none(self):
    return QuerySet(self).none()</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.people"><code class="name flex">
<span>def <span class="ident">people</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def people(self):
    return QuerySet(self).people()</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.resolve"><code class="name flex">
<span>def <span class="ident">resolve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve(self):
    # Looks up the folders or folder IDs in the collection and returns full Folder instances with all fields set.
    from .base import BaseFolder
    resolveable_folders = []
    for f in self.folders:
        if isinstance(f, BaseFolder) and not f.get_folder_allowed:
            log.debug(&#39;GetFolder not allowed on folder %s. Non-complex fields must be fetched with FindFolder&#39;, f)
            yield f
        else:
            resolveable_folders.append(f)
    # Fetch all properties for the remaining folders of folder IDs
    additional_fields = self.get_folder_fields(target_cls=self._get_target_cls(), is_complex=None)
    yield from self.__class__(account=self.account, folders=resolveable_folders).get_folders(
            additional_fields=additional_fields
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.subscribe_to_pull"><code class="name flex">
<span>def <span class="ident">subscribe_to_pull</span></span>(<span>self, event_types=('CopiedEvent', 'CreatedEvent', 'DeletedEvent', 'ModifiedEvent', 'MovedEvent', 'NewMailEvent', 'FreeBusyChangedEvent'), watermark=None, timeout=60)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe_to_pull(self, event_types=SubscribeToPull.EVENT_TYPES, watermark=None, timeout=60):
    if not self.folders:
        log.debug(&#39;Folder list is empty&#39;)
        return
    yield from SubscribeToPull(account=self.account).call(
        folders=self.folders, event_types=event_types, watermark=watermark, timeout=timeout,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.subscribe_to_push"><code class="name flex">
<span>def <span class="ident">subscribe_to_push</span></span>(<span>self, callback_url, event_types=('CopiedEvent', 'CreatedEvent', 'DeletedEvent', 'ModifiedEvent', 'MovedEvent', 'NewMailEvent', 'FreeBusyChangedEvent'), watermark=None, status_frequency=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe_to_push(self, callback_url, event_types=SubscribeToPush.EVENT_TYPES, watermark=None,
                      status_frequency=1):
    if not self.folders:
        log.debug(&#39;Folder list is empty&#39;)
        return
    yield from SubscribeToPush(account=self.account).call(
        folders=self.folders, event_types=event_types, watermark=watermark, status_frequency=status_frequency,
        url=callback_url,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.subscribe_to_streaming"><code class="name flex">
<span>def <span class="ident">subscribe_to_streaming</span></span>(<span>self, event_types=('CopiedEvent', 'CreatedEvent', 'DeletedEvent', 'ModifiedEvent', 'MovedEvent', 'NewMailEvent', 'FreeBusyChangedEvent'))</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe_to_streaming(self, event_types=SubscribeToPush.EVENT_TYPES):
    if not self.folders:
        log.debug(&#39;Folder list is empty&#39;)
        return
    yield from SubscribeToStreaming(account=self.account).call(folders=self.folders, event_types=event_types)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.sync_hierarchy"><code class="name flex">
<span>def <span class="ident">sync_hierarchy</span></span>(<span>self, sync_state=None, only_fields=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync_hierarchy(self, sync_state=None, only_fields=None):
    folder = self._get_single_folder()
    if not folder:
        return
    if only_fields is None:
        # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
        additional_fields = {FieldPath(field=f) for f in folder.supported_fields(version=self.account.version)}
    else:
        for f in only_fields:
            folder.validate_field(field=f, version=self.account.version)
        # Remove ItemId and ChangeKey. We get them unconditionally
        additional_fields = {f for f in folder.normalize_fields(fields=only_fields) if not f.field.is_attribute}

    # Add required fields
    additional_fields.update(
        (FieldPath(field=folder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
    )

    svc = SyncFolderHierarchy(account=self.account)
    while True:
        yield from svc.call(
            folder=folder,
            shape=ID_ONLY,
            additional_fields=additional_fields,
            sync_state=sync_state,
        )
        if svc.sync_state == sync_state:
            # We sometimes get the same sync_state back, even though includes_last_item_in_range is False. Stop here
            break
        sync_state = svc.sync_state  # Set the new sync state in the next call
        if svc.includes_last_item_in_range:  # Try again if there are more items
            break
    raise SyncCompleted(sync_state=svc.sync_state)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.sync_items"><code class="name flex">
<span>def <span class="ident">sync_items</span></span>(<span>self, sync_state=None, only_fields=None, ignore=None, max_changes_returned=None, sync_scope=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync_items(self, sync_state=None, only_fields=None, ignore=None, max_changes_returned=None, sync_scope=None):
    folder = self._get_single_folder()
    if not folder:
        return
    if only_fields is None:
        # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
        additional_fields = {FieldPath(field=f) for f in folder.allowed_item_fields(version=self.account.version)}
    else:
        for field in only_fields:
            folder.validate_item_field(field=field, version=self.account.version)
        # Remove ItemId and ChangeKey. We get them unconditionally
        additional_fields = {f for f in folder.normalize_fields(fields=only_fields) if not f.field.is_attribute}

    svc = SyncFolderItems(account=self.account)
    while True:
        yield from svc.call(
            folder=folder,
            shape=ID_ONLY,
            additional_fields=additional_fields,
            sync_state=sync_state,
            ignore=ignore,
            max_changes_returned=max_changes_returned,
            sync_scope=sync_scope,
        )
        if svc.sync_state == sync_state:
            # We sometimes get the same sync_state back, even though includes_last_item_in_range is False. Stop here
            break
        sync_state = svc.sync_state  # Set the new sync state in the next call
        if svc.includes_last_item_in_range:  # Try again if there are more items
            break
    raise SyncCompleted(sync_state=svc.sync_state)</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.validate_item_field"><code class="name flex">
<span>def <span class="ident">validate_item_field</span></span>(<span>self, field, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_item_field(self, field, version):
    # For each field, check if the field is valid for any of the item models supported by this folder
    for item_model in self.supported_item_models:
        try:
            item_model.validate_field(field=field, version=version)
            break
        except InvalidField:
            continue
    else:
        raise InvalidField(&#34;%r is not a valid field on %s&#34; % (field, self.supported_item_models))</code></pre>
</details>
</dd>
<dt id="exchangelib.FolderCollection.view"><code class="name flex">
<span>def <span class="ident">view</span></span>(<span>self, start, end, max_items=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the CalendarView option to FindItem. The difference between 'filter' and 'view' is that 'filter'
only returns the master CalendarItem for recurring items, while 'view' unfolds recurring items and returns all
CalendarItem occurrences as one would normally expect when presenting a calendar.</p>
<p>Supports the same semantics as filter, except for 'start' and 'end' keyword attributes which are both required
and behave differently than filter. Here, they denote the start and end of the timespan of the view. All items
the overlap the timespan are returned (items that end exactly on 'start' are also returned, for some reason).</p>
<p>EWS does not allow combining CalendarView with search restrictions (filter and exclude).</p>
<p>'max_items' defines the maximum number of items returned in this view. Optional.</p>
<p>:param start:
:param end:
:param max_items:
(Default value = None)
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view(self, start, end, max_items=None, *args, **kwargs):
    &#34;&#34;&#34;Implement the CalendarView option to FindItem. The difference between &#39;filter&#39; and &#39;view&#39; is that &#39;filter&#39;
    only returns the master CalendarItem for recurring items, while &#39;view&#39; unfolds recurring items and returns all
    CalendarItem occurrences as one would normally expect when presenting a calendar.

    Supports the same semantics as filter, except for &#39;start&#39; and &#39;end&#39; keyword attributes which are both required
    and behave differently than filter. Here, they denote the start and end of the timespan of the view. All items
    the overlap the timespan are returned (items that end exactly on &#39;start&#39; are also returned, for some reason).

    EWS does not allow combining CalendarView with search restrictions (filter and exclude).

    &#39;max_items&#39; defines the maximum number of items returned in this view. Optional.

    :param start:
    :param end:
    :param max_items:  (Default value = None)
    :return:
    &#34;&#34;&#34;
    qs = QuerySet(self).filter(*args, **kwargs)
    qs.calendar_view = CalendarView(start=start, end=end, max_items=max_items)
    return qs</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.ForwardItem"><code class="flex name class">
<span>class <span class="ident">ForwardItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/forwarditem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/forwarditem</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForwardItem(BaseReplyItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/forwarditem&#34;&#34;&#34;

    ELEMENT_NAME = &#39;ForwardItem&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.ForwardItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.base.BaseReplyItem.account" href="items/base.html#exchangelib.items.base.BaseReplyItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.save" href="items/base.html#exchangelib.items.base.BaseReplyItem.save">save</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.HTMLBody"><code class="flex name class">
<span>class <span class="ident">HTMLBody</span></span>
<span>(</span><span>...)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper to mark the 'body' field as a complex attribute.</p>
<p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/body">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/body</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HTMLBody(Body):
    &#34;&#34;&#34;Helper to mark the &#39;body&#39; field as a complex attribute.

    MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/body
    &#34;&#34;&#34;

    body_type = &#39;HTML&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.Body" href="properties.html#exchangelib.properties.Body">Body</a></li>
<li>builtins.str</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.HTMLBody.body_type"><code class="name">var <span class="ident">body_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.Body" href="properties.html#exchangelib.properties.Body">Body</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.Body.format" href="properties.html#exchangelib.properties.Body.format">format</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Identity"><code class="flex name class">
<span>class <span class="ident">Identity</span></span>
<span>(</span><span>primary_smtp_address=None, smtp_address=None, upn=None, sid=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Contains information that uniquely identifies an account. Currently only used for SOAP impersonation headers.</p>
<p>:param primary_smtp_address: The primary email address associated with the account (Default value = None)
:param smtp_address: The (non-)primary email address associated with the account (Default value = None)
:param upn: (Default value = None)
:param sid: (Default value = None)
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Identity:
    &#34;&#34;&#34;Contains information that uniquely identifies an account. Currently only used for SOAP impersonation headers.&#34;&#34;&#34;

    def __init__(self, primary_smtp_address=None, smtp_address=None, upn=None, sid=None):
        &#34;&#34;&#34;

        :param primary_smtp_address: The primary email address associated with the account (Default value = None)
        :param smtp_address: The (non-)primary email address associated with the account (Default value = None)
        :param upn: (Default value = None)
        :param sid: (Default value = None)
        :return:
        &#34;&#34;&#34;
        self.primary_smtp_address = primary_smtp_address
        self.smtp_address = smtp_address
        self.upn = upn
        self.sid = sid

    def __eq__(self, other):
        for k in self.__dict__:
            if getattr(self, k) != getattr(other, k):
                return False
        return True

    def __hash__(self):
        return hash(repr(self))

    def __repr__(self):
        return self.__class__.__name__ + repr((self.primary_smtp_address, self.smtp_address, self.upn, self.sid))</code></pre>
</details>
</dd>
<dt id="exchangelib.ItemAttachment"><code class="flex name class">
<span>class <span class="ident">ItemAttachment</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/itemattachment">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/itemattachment</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ItemAttachment(Attachment):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/itemattachment&#34;&#34;&#34;

    ELEMENT_NAME = &#39;ItemAttachment&#39;

    _item = ItemField(field_uri=&#39;Item&#39;)

    def __init__(self, **kwargs):
        kwargs[&#39;_item&#39;] = kwargs.pop(&#39;item&#39;, None)
        super().__init__(**kwargs)

    @property
    def item(self):
        from .folders import BaseFolder
        if self.attachment_id is None:
            return self._item
        if self._item is not None:
            return self._item
        # We have an ID to the data but still haven&#39;t called GetAttachment to get the actual data. Do that now.
        if not self.parent_item or not self.parent_item.account:
            raise ValueError(&#39;%s must have an account&#39; % self.__class__.__name__)
        additional_fields = {
            FieldPath(field=f) for f in BaseFolder.allowed_item_fields(version=self.parent_item.account.version)
        }
        attachment = GetAttachment(account=self.parent_item.account).get(
            items=[self.attachment_id], include_mime_content=True, body_type=None, filter_html_content=None,
            additional_fields=additional_fields,
        )
        self._item = attachment.item
        return self._item

    @item.setter
    def item(self, value):
        from .items import Item
        if not isinstance(value, Item):
            raise ValueError(&#34;&#39;value&#39; %r must be an Item object&#34; % value)
        self._item = value

    @classmethod
    def from_xml(cls, elem, account):
        kwargs = {f.name: f.from_xml(elem=elem, account=account) for f in cls.FIELDS}
        kwargs[&#39;item&#39;] = kwargs.pop(&#39;_item&#39;)
        cls._clear(elem)
        return cls(**kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.attachments.Attachment" href="attachments.html#exchangelib.attachments.Attachment">Attachment</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.ItemAttachment.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ItemAttachment.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.ItemAttachment.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem, account):
    kwargs = {f.name: f.from_xml(elem=elem, account=account) for f in cls.FIELDS}
    kwargs[&#39;item&#39;] = kwargs.pop(&#39;_item&#39;)
    cls._clear(elem)
    return cls(**kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.ItemAttachment.item"><code class="name">var <span class="ident">item</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def item(self):
    from .folders import BaseFolder
    if self.attachment_id is None:
        return self._item
    if self._item is not None:
        return self._item
    # We have an ID to the data but still haven&#39;t called GetAttachment to get the actual data. Do that now.
    if not self.parent_item or not self.parent_item.account:
        raise ValueError(&#39;%s must have an account&#39; % self.__class__.__name__)
    additional_fields = {
        FieldPath(field=f) for f in BaseFolder.allowed_item_fields(version=self.parent_item.account.version)
    }
    attachment = GetAttachment(account=self.parent_item.account).get(
        items=[self.attachment_id], include_mime_content=True, body_type=None, filter_html_content=None,
        additional_fields=additional_fields,
    )
    self._item = attachment.item
    return self._item</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.attachments.Attachment" href="attachments.html#exchangelib.attachments.Attachment">Attachment</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.attachments.Attachment.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.parent_item" href="attachments.html#exchangelib.attachments.Attachment.parent_item">parent_item</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.attachments.Attachment.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.ItemId"><code class="flex name class">
<span>class <span class="ident">ItemId</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>'id' and 'changekey' are UUIDs generated by Exchange.</p>
<p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/itemid">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/itemid</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ItemId(BaseItemId):
    &#34;&#34;&#34;&#39;id&#39; and &#39;changekey&#39; are UUIDs generated by Exchange.

    MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/itemid
    &#34;&#34;&#34;

    ELEMENT_NAME = &#39;ItemId&#39;
    ID_ATTR = &#39;Id&#39;
    CHANGEKEY_ATTR = &#39;ChangeKey&#39;

    id = IdField(field_uri=ID_ATTR, is_required=True)
    changekey = IdField(field_uri=CHANGEKEY_ATTR, is_required=False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.BaseItemId" href="properties.html#exchangelib.properties.BaseItemId">BaseItemId</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.AssociatedCalendarItemId" href="properties.html#exchangelib.properties.AssociatedCalendarItemId">AssociatedCalendarItemId</a></li>
<li><a title="exchangelib.properties.ConversationId" href="properties.html#exchangelib.properties.ConversationId">ConversationId</a></li>
<li><a title="exchangelib.properties.FolderId" href="properties.html#exchangelib.properties.FolderId">FolderId</a></li>
<li><a title="exchangelib.properties.MovedItemId" href="properties.html#exchangelib.properties.MovedItemId">MovedItemId</a></li>
<li><a title="exchangelib.properties.ParentFolderId" href="properties.html#exchangelib.properties.ParentFolderId">ParentFolderId</a></li>
<li><a title="exchangelib.properties.ParentItemId" href="properties.html#exchangelib.properties.ParentItemId">ParentItemId</a></li>
<li><a title="exchangelib.properties.PersonaId" href="properties.html#exchangelib.properties.PersonaId">PersonaId</a></li>
<li><a title="exchangelib.properties.ReferenceItemId" href="properties.html#exchangelib.properties.ReferenceItemId">ReferenceItemId</a></li>
<li><a title="exchangelib.properties.SourceId" href="properties.html#exchangelib.properties.SourceId">SourceId</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.ItemId.CHANGEKEY_ATTR"><code class="name">var <span class="ident">CHANGEKEY_ATTR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ItemId.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ItemId.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ItemId.ID_ATTR"><code class="name">var <span class="ident">ID_ATTR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.ItemId.changekey"><code class="name">var <span class="ident">changekey</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.ItemId.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.BaseItemId" href="properties.html#exchangelib.properties.BaseItemId">BaseItemId</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.BaseItemId.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.BaseItemId.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.BaseItemId.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.BaseItemId.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Mailbox"><code class="flex name class">
<span>class <span class="ident">Mailbox</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/mailbox">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/mailbox</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mailbox(EWSElement):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/mailbox&#34;&#34;&#34;

    ELEMENT_NAME = &#39;Mailbox&#39;
    MAILBOX = &#39;Mailbox&#39;
    ONE_OFF = &#39;OneOff&#39;
    MAILBOX_TYPE_CHOICES = {
            Choice(MAILBOX), Choice(&#39;PublicDL&#39;), Choice(&#39;PrivateDL&#39;), Choice(&#39;Contact&#39;), Choice(&#39;PublicFolder&#39;),
            Choice(&#39;Unknown&#39;), Choice(ONE_OFF), Choice(&#39;GroupMailbox&#39;, supported_from=EXCHANGE_2013)
        }

    name = TextField(field_uri=&#39;Name&#39;)
    email_address = EmailAddressField(field_uri=&#39;EmailAddress&#39;)
    # RoutingType values are not restricted:
    # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/routingtype-emailaddresstype
    routing_type = TextField(field_uri=&#39;RoutingType&#39;, default=&#39;SMTP&#39;)
    mailbox_type = ChoiceField(field_uri=&#39;MailboxType&#39;, choices=MAILBOX_TYPE_CHOICES, default=MAILBOX)
    item_id = EWSElementField(value_cls=ItemId, is_read_only=True)

    def clean(self, version=None):
        super().clean(version=version)

        if self.mailbox_type != self.ONE_OFF and not self.email_address and not self.item_id:
            # A OneOff Mailbox (a one-off member of a personal distribution list) may lack these fields, but other
            # Mailboxes require at least one. See also &#34;Remarks&#34; section of
            # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/mailbox
            raise ValueError(&#34;Mailbox type %r must have either &#39;email_address&#39; or &#39;item_id&#39; set&#34; % self.mailbox_type)

    def __hash__(self):
        # Exchange may add &#39;mailbox_type&#39; and &#39;name&#39; on insert. We&#39;re satisfied if the item_id or email address matches.
        if self.item_id:
            return hash(self.item_id)
        if self.email_address:
            return hash(self.email_address.lower())
        return super().__hash__()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.Address" href="properties.html#exchangelib.properties.Address">Address</a></li>
<li><a title="exchangelib.properties.DLMailbox" href="properties.html#exchangelib.properties.DLMailbox">DLMailbox</a></li>
<li><a title="exchangelib.properties.EmailAddress" href="properties.html#exchangelib.properties.EmailAddress">EmailAddress</a></li>
<li><a title="exchangelib.properties.EmailAddressTypeValue" href="properties.html#exchangelib.properties.EmailAddressTypeValue">EmailAddressTypeValue</a></li>
<li><a title="exchangelib.properties.PersonaPostalAddressTypeValue" href="properties.html#exchangelib.properties.PersonaPostalAddressTypeValue">PersonaPostalAddressTypeValue</a></li>
<li><a title="exchangelib.properties.RecipientAddress" href="properties.html#exchangelib.properties.RecipientAddress">RecipientAddress</a></li>
<li><a title="exchangelib.properties.Room" href="properties.html#exchangelib.properties.Room">Room</a></li>
<li><a title="exchangelib.properties.RoomList" href="properties.html#exchangelib.properties.RoomList">RoomList</a></li>
<li><a title="exchangelib.properties.SendingAs" href="properties.html#exchangelib.properties.SendingAs">SendingAs</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Mailbox.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.MAILBOX"><code class="name">var <span class="ident">MAILBOX</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.MAILBOX_TYPE_CHOICES"><code class="name">var <span class="ident">MAILBOX_TYPE_CHOICES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.ONE_OFF"><code class="name">var <span class="ident">ONE_OFF</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Mailbox.email_address"><code class="name">var <span class="ident">email_address</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.item_id"><code class="name">var <span class="ident">item_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.mailbox_type"><code class="name">var <span class="ident">mailbox_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Mailbox.routing_type"><code class="name">var <span class="ident">routing_type</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Mailbox.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, version=None):
    super().clean(version=version)

    if self.mailbox_type != self.ONE_OFF and not self.email_address and not self.item_id:
        # A OneOff Mailbox (a one-off member of a personal distribution list) may lack these fields, but other
        # Mailboxes require at least one. See also &#34;Remarks&#34; section of
        # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/mailbox
        raise ValueError(&#34;Mailbox type %r must have either &#39;email_address&#39; or &#39;item_id&#39; set&#34; % self.mailbox_type)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.EWSElement.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Message"><code class="flex name class">
<span>class <span class="ident">Message</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN:
<a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/message-ex15websvcsotherref">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/message-ex15websvcsotherref</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Message(Item):
    &#34;&#34;&#34;MSDN:
    https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/message-ex15websvcsotherref
    &#34;&#34;&#34;

    ELEMENT_NAME = &#39;Message&#39;

    sender = MailboxField(field_uri=&#39;message:Sender&#39;, is_read_only=True, is_read_only_after_send=True)
    to_recipients = MailboxListField(field_uri=&#39;message:ToRecipients&#39;, is_read_only_after_send=True,
                                     is_searchable=False)
    cc_recipients = MailboxListField(field_uri=&#39;message:CcRecipients&#39;, is_read_only_after_send=True,
                                     is_searchable=False)
    bcc_recipients = MailboxListField(field_uri=&#39;message:BccRecipients&#39;, is_read_only_after_send=True,
                                      is_searchable=False)
    is_read_receipt_requested = BooleanField(field_uri=&#39;message:IsReadReceiptRequested&#39;,
                                             is_required=True, default=False, is_read_only_after_send=True)
    is_delivery_receipt_requested = BooleanField(field_uri=&#39;message:IsDeliveryReceiptRequested&#39;, is_required=True,
                                                 default=False, is_read_only_after_send=True)
    conversation_index = Base64Field(field_uri=&#39;message:ConversationIndex&#39;, is_read_only=True)
    conversation_topic = CharField(field_uri=&#39;message:ConversationTopic&#39;, is_read_only=True)
    # Rename &#39;From&#39; to &#39;author&#39;. We can&#39;t use fieldname &#39;from&#39; since it&#39;s a Python keyword.
    author = MailboxField(field_uri=&#39;message:From&#39;, is_read_only_after_send=True)
    message_id = CharField(field_uri=&#39;message:InternetMessageId&#39;, is_read_only_after_send=True)
    is_read = BooleanField(field_uri=&#39;message:IsRead&#39;, is_required=True, default=False)
    is_response_requested = BooleanField(field_uri=&#39;message:IsResponseRequested&#39;, default=False, is_required=True)
    references = TextField(field_uri=&#39;message:References&#39;)
    reply_to = MailboxListField(field_uri=&#39;message:ReplyTo&#39;, is_read_only_after_send=True, is_searchable=False)
    received_by = MailboxField(field_uri=&#39;message:ReceivedBy&#39;, is_read_only=True)
    received_representing = MailboxField(field_uri=&#39;message:ReceivedRepresenting&#39;, is_read_only=True)
    reminder_message_data = EWSElementField(field_uri=&#39;message:ReminderMessageData&#39;, value_cls=ReminderMessageData,
                                            supported_from=EXCHANGE_2013_SP1, is_read_only=True)

    @require_account
    def send(self, save_copy=True, copy_to_folder=None, conflict_resolution=AUTO_RESOLVE,
             send_meeting_invitations=SEND_TO_NONE):
        # Only sends a message. The message can either be an existing draft stored in EWS or a new message that does
        # not yet exist in EWS.
        if copy_to_folder and not save_copy:
            raise AttributeError(&#34;&#39;save_copy&#39; must be True when &#39;copy_to_folder&#39; is set&#34;)
        if save_copy and not copy_to_folder:
            copy_to_folder = self.account.sent  # &#39;Sent&#39; is default EWS behaviour
        if self.id:
            SendItem(account=self.account).get(items=[self], saved_item_folder=copy_to_folder)
            # The item will be deleted from the original folder
            self._id = None
            self.folder = copy_to_folder
            return None

        # New message
        if copy_to_folder:
            # This would better be done via send_and_save() but lets just support it here
            self.folder = copy_to_folder
            return self.send_and_save(conflict_resolution=conflict_resolution,
                                      send_meeting_invitations=send_meeting_invitations)

        if self.account.version.build &lt; EXCHANGE_2013 and self.attachments:
            # At least some versions prior to Exchange 2013 can&#39;t send attachments immediately. You need to first save,
            # then attach, then send. This is done in send_and_save(). send() will delete the item again.
            self.send_and_save(conflict_resolution=conflict_resolution,
                               send_meeting_invitations=send_meeting_invitations)
            return None

        self._create(message_disposition=SEND_ONLY, send_meeting_invitations=send_meeting_invitations)
        return None

    def send_and_save(self, update_fields=None, conflict_resolution=AUTO_RESOLVE,
                      send_meeting_invitations=SEND_TO_NONE):
        # Sends Message and saves a copy in the parent folder. Does not return an ItemId.
        if self.id:
            self._update(
                update_fieldnames=update_fields,
                message_disposition=SEND_AND_SAVE_COPY,
                conflict_resolution=conflict_resolution,
                send_meeting_invitations=send_meeting_invitations
            )
        else:
            if self.account.version.build &lt; EXCHANGE_2013 and self.attachments:
                # At least some versions prior to Exchange 2013 can&#39;t send-and-save attachments immediately. You need
                # to first save, then attach, then send. This is done in save().
                self.save(update_fields=update_fields, conflict_resolution=conflict_resolution,
                          send_meeting_invitations=send_meeting_invitations)
                self.send(save_copy=False, conflict_resolution=conflict_resolution,
                          send_meeting_invitations=send_meeting_invitations)
            else:
                res = self._create(
                    message_disposition=SEND_AND_SAVE_COPY,
                    send_meeting_invitations=send_meeting_invitations
                )
                if res is not True:
                    raise ValueError(&#39;Unexpected response in send-only mode&#39;)

    @require_id
    def create_reply(self, subject, body, to_recipients=None, cc_recipients=None, bcc_recipients=None):
        if to_recipients is None:
            if not self.author:
                raise ValueError(&#34;&#39;to_recipients&#39; must be set when message has no &#39;author&#39;&#34;)
            to_recipients = [self.author]
        return ReplyToItem(
            account=self.account,
            reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey),
            subject=subject,
            new_body=body,
            to_recipients=to_recipients,
            cc_recipients=cc_recipients,
            bcc_recipients=bcc_recipients,
        )

    def reply(self, subject, body, to_recipients=None, cc_recipients=None, bcc_recipients=None):
        self.create_reply(
            subject,
            body,
            to_recipients,
            cc_recipients,
            bcc_recipients
        ).send()

    @require_id
    def create_reply_all(self, subject, body):
        to_recipients = list(self.to_recipients) if self.to_recipients else []
        if self.author:
            to_recipients.append(self.author)
        return ReplyAllToItem(
            account=self.account,
            reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey),
            subject=subject,
            new_body=body,
            to_recipients=to_recipients,
            cc_recipients=self.cc_recipients,
            bcc_recipients=self.bcc_recipients,
        )

    def reply_all(self, subject, body):
        self.create_reply_all(subject, body).send()

    def mark_as_junk(self, is_junk=True, move_item=True):
        &#34;&#34;&#34;Mark or un-marks items as junk email.

        :param is_junk: If True, the sender will be added from the blocked sender list. Otherwise, the sender will be
        removed.
        :param move_item: If true, the item will be moved to the junk folder.
        :return:
        &#34;&#34;&#34;
        res = MarkAsJunk(account=self.account).get(
            items=[self], is_junk=is_junk, move_item=move_item, expect_result=move_item
        )
        if res is None:
            return
        self.folder = self.account.junk if is_junk else self.account.inbox
        self.id, self.changekey = res</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Message.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Message.author"><code class="name">var <span class="ident">author</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.bcc_recipients"><code class="name">var <span class="ident">bcc_recipients</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.cc_recipients"><code class="name">var <span class="ident">cc_recipients</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.conversation_index"><code class="name">var <span class="ident">conversation_index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.conversation_topic"><code class="name">var <span class="ident">conversation_topic</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.is_delivery_receipt_requested"><code class="name">var <span class="ident">is_delivery_receipt_requested</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.is_read"><code class="name">var <span class="ident">is_read</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.is_read_receipt_requested"><code class="name">var <span class="ident">is_read_receipt_requested</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.is_response_requested"><code class="name">var <span class="ident">is_response_requested</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.message_id"><code class="name">var <span class="ident">message_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.received_by"><code class="name">var <span class="ident">received_by</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.received_representing"><code class="name">var <span class="ident">received_representing</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.references"><code class="name">var <span class="ident">references</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.reminder_message_data"><code class="name">var <span class="ident">reminder_message_data</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.reply_to"><code class="name">var <span class="ident">reply_to</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.sender"><code class="name">var <span class="ident">sender</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Message.to_recipients"><code class="name">var <span class="ident">to_recipients</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Message.create_reply"><code class="name flex">
<span>def <span class="ident">create_reply</span></span>(<span>self, subject, body, to_recipients=None, cc_recipients=None, bcc_recipients=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_id
def create_reply(self, subject, body, to_recipients=None, cc_recipients=None, bcc_recipients=None):
    if to_recipients is None:
        if not self.author:
            raise ValueError(&#34;&#39;to_recipients&#39; must be set when message has no &#39;author&#39;&#34;)
        to_recipients = [self.author]
    return ReplyToItem(
        account=self.account,
        reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey),
        subject=subject,
        new_body=body,
        to_recipients=to_recipients,
        cc_recipients=cc_recipients,
        bcc_recipients=bcc_recipients,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Message.create_reply_all"><code class="name flex">
<span>def <span class="ident">create_reply_all</span></span>(<span>self, subject, body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_id
def create_reply_all(self, subject, body):
    to_recipients = list(self.to_recipients) if self.to_recipients else []
    if self.author:
        to_recipients.append(self.author)
    return ReplyAllToItem(
        account=self.account,
        reference_item_id=ReferenceItemId(id=self.id, changekey=self.changekey),
        subject=subject,
        new_body=body,
        to_recipients=to_recipients,
        cc_recipients=self.cc_recipients,
        bcc_recipients=self.bcc_recipients,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.Message.mark_as_junk"><code class="name flex">
<span>def <span class="ident">mark_as_junk</span></span>(<span>self, is_junk=True, move_item=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Mark or un-marks items as junk email.</p>
<p>:param is_junk: If True, the sender will be added from the blocked sender list. Otherwise, the sender will be
removed.
:param move_item: If true, the item will be moved to the junk folder.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mark_as_junk(self, is_junk=True, move_item=True):
    &#34;&#34;&#34;Mark or un-marks items as junk email.

    :param is_junk: If True, the sender will be added from the blocked sender list. Otherwise, the sender will be
    removed.
    :param move_item: If true, the item will be moved to the junk folder.
    :return:
    &#34;&#34;&#34;
    res = MarkAsJunk(account=self.account).get(
        items=[self], is_junk=is_junk, move_item=move_item, expect_result=move_item
    )
    if res is None:
        return
    self.folder = self.account.junk if is_junk else self.account.inbox
    self.id, self.changekey = res</code></pre>
</details>
</dd>
<dt id="exchangelib.Message.reply"><code class="name flex">
<span>def <span class="ident">reply</span></span>(<span>self, subject, body, to_recipients=None, cc_recipients=None, bcc_recipients=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reply(self, subject, body, to_recipients=None, cc_recipients=None, bcc_recipients=None):
    self.create_reply(
        subject,
        body,
        to_recipients,
        cc_recipients,
        bcc_recipients
    ).send()</code></pre>
</details>
</dd>
<dt id="exchangelib.Message.reply_all"><code class="name flex">
<span>def <span class="ident">reply_all</span></span>(<span>self, subject, body)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reply_all(self, subject, body):
    self.create_reply_all(subject, body).send()</code></pre>
</details>
</dd>
<dt id="exchangelib.Message.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, save_copy=True, copy_to_folder=None, conflict_resolution='AutoResolve', send_meeting_invitations='SendToNone')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_account
def send(self, save_copy=True, copy_to_folder=None, conflict_resolution=AUTO_RESOLVE,
         send_meeting_invitations=SEND_TO_NONE):
    # Only sends a message. The message can either be an existing draft stored in EWS or a new message that does
    # not yet exist in EWS.
    if copy_to_folder and not save_copy:
        raise AttributeError(&#34;&#39;save_copy&#39; must be True when &#39;copy_to_folder&#39; is set&#34;)
    if save_copy and not copy_to_folder:
        copy_to_folder = self.account.sent  # &#39;Sent&#39; is default EWS behaviour
    if self.id:
        SendItem(account=self.account).get(items=[self], saved_item_folder=copy_to_folder)
        # The item will be deleted from the original folder
        self._id = None
        self.folder = copy_to_folder
        return None

    # New message
    if copy_to_folder:
        # This would better be done via send_and_save() but lets just support it here
        self.folder = copy_to_folder
        return self.send_and_save(conflict_resolution=conflict_resolution,
                                  send_meeting_invitations=send_meeting_invitations)

    if self.account.version.build &lt; EXCHANGE_2013 and self.attachments:
        # At least some versions prior to Exchange 2013 can&#39;t send attachments immediately. You need to first save,
        # then attach, then send. This is done in send_and_save(). send() will delete the item again.
        self.send_and_save(conflict_resolution=conflict_resolution,
                           send_meeting_invitations=send_meeting_invitations)
        return None

    self._create(message_disposition=SEND_ONLY, send_meeting_invitations=send_meeting_invitations)
    return None</code></pre>
</details>
</dd>
<dt id="exchangelib.Message.send_and_save"><code class="name flex">
<span>def <span class="ident">send_and_save</span></span>(<span>self, update_fields=None, conflict_resolution='AutoResolve', send_meeting_invitations='SendToNone')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_and_save(self, update_fields=None, conflict_resolution=AUTO_RESOLVE,
                  send_meeting_invitations=SEND_TO_NONE):
    # Sends Message and saves a copy in the parent folder. Does not return an ItemId.
    if self.id:
        self._update(
            update_fieldnames=update_fields,
            message_disposition=SEND_AND_SAVE_COPY,
            conflict_resolution=conflict_resolution,
            send_meeting_invitations=send_meeting_invitations
        )
    else:
        if self.account.version.build &lt; EXCHANGE_2013 and self.attachments:
            # At least some versions prior to Exchange 2013 can&#39;t send-and-save attachments immediately. You need
            # to first save, then attach, then send. This is done in save().
            self.save(update_fields=update_fields, conflict_resolution=conflict_resolution,
                      send_meeting_invitations=send_meeting_invitations)
            self.send(save_copy=False, conflict_resolution=conflict_resolution,
                      send_meeting_invitations=send_meeting_invitations)
        else:
            res = self._create(
                message_disposition=SEND_AND_SAVE_COPY,
                send_meeting_invitations=send_meeting_invitations
            )
            if res is not True:
                raise ValueError(&#39;Unexpected response in send-only mode&#39;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.item.Item.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.item.Item.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attach" href="items/item.html#exchangelib.items.item.Item.attach">attach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.item.Item.detach" href="items/item.html#exchangelib.items.item.Item.detach">detach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.item.Item.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.item.Item.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.item.Item.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.NoVerifyHTTPAdapter"><code class="flex name class">
<span>class <span class="ident">NoVerifyHTTPAdapter</span></span>
<span>(</span><span>pool_connections=10, pool_maxsize=10, max_retries=0, pool_block=False)</span>
</code></dt>
<dd>
<div class="desc"><p>An HTTP adapter that ignores TLS validation errors. Use at own risk.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NoVerifyHTTPAdapter(requests.adapters.HTTPAdapter):
    &#34;&#34;&#34;An HTTP adapter that ignores TLS validation errors. Use at own risk.&#34;&#34;&#34;

    def cert_verify(self, conn, url, verify, cert):
        # pylint: disable=unused-argument
        # We&#39;re overriding a method so we have to keep the signature
        super().cert_verify(conn=conn, url=url, verify=False, cert=cert)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>requests.adapters.HTTPAdapter</li>
<li>requests.adapters.BaseAdapter</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.NoVerifyHTTPAdapter.cert_verify"><code class="name flex">
<span>def <span class="ident">cert_verify</span></span>(<span>self, conn, url, verify, cert)</span>
</code></dt>
<dd>
<div class="desc"><p>Verify a SSL certificate. This method should not be called from user
code, and is only exposed for use when subclassing the
:class:<code>HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;</code>.</p>
<p>:param conn: The urllib3 connection object associated with the cert.
:param url: The requested URL.
:param verify: Either a boolean, in which case it controls whether we verify
the server's TLS certificate, or a string, in which case it must be a path
to a CA bundle to use
:param cert: The SSL certificate to verify.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cert_verify(self, conn, url, verify, cert):
    # pylint: disable=unused-argument
    # We&#39;re overriding a method so we have to keep the signature
    super().cert_verify(conn=conn, url=url, verify=False, cert=cert)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.OAuth2AuthorizationCodeCredentials"><code class="flex name class">
<span>class <span class="ident">OAuth2AuthorizationCodeCredentials</span></span>
<span>(</span><span>authorization_code=None, access_token=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Login info for OAuth 2.0 authentication using the authorization code grant type. This can be used in one of
several ways:
* Given an authorization code, client ID, and client secret, fetch a token ourselves and refresh it as needed if
supplied with a refresh token.
* Given an existing access token, refresh token, client ID, and client secret, use the access token until it
expires and then refresh it as needed.
* Given only an existing access token, use it until it expires. This can be used to let the calling application
refresh tokens itself by subclassing and implementing refresh().</p>
<p>Unlike the base (client credentials) grant, authorization code credentials don't require a Microsoft tenant ID
because each access token (and the authorization code used to get the access token) is restricted to a single
tenant.</p>
<p>:param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
:param client_secret: Secret associated with the OAuth application
:param tenant_id: Microsoft tenant ID of the account to access
:param identity: An Identity object representing the account that these credentials are connected to.
:param authorization_code: Code obtained when authorizing the application to access an account. In combination
with client_id and client_secret, will be used to obtain an access token.
:param access_token: Previously-obtained access token. If a token exists and the application will handle
refreshing by itself (or opts not to handle it), this parameter alone is sufficient.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OAuth2AuthorizationCodeCredentials(OAuth2Credentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 authentication using the authorization code grant type. This can be used in one of
    several ways:
    * Given an authorization code, client ID, and client secret, fetch a token ourselves and refresh it as needed if
      supplied with a refresh token.
    * Given an existing access token, refresh token, client ID, and client secret, use the access token until it
      expires and then refresh it as needed.
    * Given only an existing access token, use it until it expires. This can be used to let the calling application
      refresh tokens itself by subclassing and implementing refresh().

    Unlike the base (client credentials) grant, authorization code credentials don&#39;t require a Microsoft tenant ID
    because each access token (and the authorization code used to get the access token) is restricted to a single
    tenant.
    &#34;&#34;&#34;

    def __init__(self, authorization_code=None, access_token=None, **kwargs):
        &#34;&#34;&#34;

        :param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
        :param client_secret: Secret associated with the OAuth application
        :param tenant_id: Microsoft tenant ID of the account to access
        :param identity: An Identity object representing the account that these credentials are connected to.
        :param authorization_code: Code obtained when authorizing the application to access an account. In combination
          with client_id and client_secret, will be used to obtain an access token.
        :param access_token: Previously-obtained access token. If a token exists and the application will handle
          refreshing by itself (or opts not to handle it), this parameter alone is sufficient.
        &#34;&#34;&#34;
        super().__init__(**kwargs)
        self.authorization_code = authorization_code
        if access_token is not None and not isinstance(access_token, dict):
            raise ValueError(&#34;&#39;access_token&#39; must be an OAuth2Token&#34;)
        self.access_token = access_token

    def __repr__(self):
        return self.__class__.__name__ + repr(
            (self.client_id, &#39;[client_secret]&#39;, &#39;[authorization_code]&#39;, &#39;[access_token]&#39;)
        )

    def __str__(self):
        client_id = self.client_id
        credential = &#39;[access_token]&#39; if self.access_token is not None else \
            (&#39;[authorization_code]&#39; if self.authorization_code is not None else None)
        description = &#39; &#39;.join(filter(None, [client_id, credential]))
        return description or &#39;[underspecified credentials]&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.OAuth2Credentials" href="credentials.html#exchangelib.credentials.OAuth2Credentials">OAuth2Credentials</a></li>
<li><a title="exchangelib.credentials.BaseCredentials" href="credentials.html#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.credentials.OAuth2Credentials" href="credentials.html#exchangelib.credentials.OAuth2Credentials">OAuth2Credentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.OAuth2Credentials.on_token_auto_refreshed" href="credentials.html#exchangelib.credentials.OAuth2Credentials.on_token_auto_refreshed">on_token_auto_refreshed</a></code></li>
<li><code><a title="exchangelib.credentials.OAuth2Credentials.refresh" href="credentials.html#exchangelib.credentials.BaseCredentials.refresh">refresh</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.OAuth2Credentials"><code class="flex name class">
<span>class <span class="ident">OAuth2Credentials</span></span>
<span>(</span><span>client_id, client_secret, tenant_id=None, identity=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Login info for OAuth 2.0 client credentials authentication, as well as a base for other OAuth 2.0 grant types.</p>
<p>This is primarily useful for in-house applications accessing data from a single Microsoft account. For applications
that will access multiple tenants' data, the client credentials flow does not give the application enough
information to restrict end users' access to the appropriate account. Use OAuth2AuthorizationCodeCredentials and
the associated auth code grant type for multi-tenant applications.</p>
<p>:param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
:param client_secret: Secret associated with the OAuth application
:param tenant_id: Microsoft tenant ID of the account to access
:param identity: An Identity object representing the account that these credentials are connected to.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OAuth2Credentials(BaseCredentials):
    &#34;&#34;&#34;Login info for OAuth 2.0 client credentials authentication, as well as a base for other OAuth 2.0 grant types.

    This is primarily useful for in-house applications accessing data from a single Microsoft account. For applications
    that will access multiple tenants&#39; data, the client credentials flow does not give the application enough
    information to restrict end users&#39; access to the appropriate account. Use OAuth2AuthorizationCodeCredentials and
    the associated auth code grant type for multi-tenant applications.
    &#34;&#34;&#34;

    def __init__(self, client_id, client_secret, tenant_id=None, identity=None):
        &#34;&#34;&#34;

        :param client_id: ID of an authorized OAuth application, required for automatic token fetching and refreshing
        :param client_secret: Secret associated with the OAuth application
        :param tenant_id: Microsoft tenant ID of the account to access
        :param identity: An Identity object representing the account that these credentials are connected to.
        &#34;&#34;&#34;
        super().__init__()
        self.client_id = client_id
        self.client_secret = client_secret
        self.tenant_id = tenant_id
        self.identity = identity
        # When set, access_token is a dict (or an oauthlib.oauth2.OAuth2Token, which is also a dict)
        self.access_token = None

    def refresh(self, session):
        # Creating a new session gets a new access token, so there&#39;s no work here to refresh the credentials. This
        # implementation just makes sure we don&#39;t raise a NotImplementedError.
        pass

    def on_token_auto_refreshed(self, access_token):
        &#34;&#34;&#34;Set the access_token. Called after the access token is refreshed (requests-oauthlib can automatically
        refresh tokens if given an OAuth client ID and secret, so this is how our copy of the token stays up-to-date).
        Applications that cache access tokens can override this to store the new token - just remember to call the
        super() method.

        :param access_token: New token obtained by refreshing
        &#34;&#34;&#34;
        # Ensure we don&#39;t update the object in the middle of a new session being created, which could cause a race.
        if not isinstance(access_token, dict):
            raise ValueError(&#34;&#39;access_token&#39; must be an OAuth2Token&#34;)
        with self.lock:
            log.debug(&#39;%s auth token for %s&#39;, &#39;Refreshing&#39; if self.access_token else &#39;Setting&#39;, self.client_id)
            self.access_token = access_token

    def _get_hash_values(self):
        # &#39;access_token&#39; may be refreshed once in a while. This should not affect the hash signature.
        # &#39;identity&#39; is just informational and should also not affect the hash signature.
        return (getattr(self, k) for k in self.__dict__ if k not in (&#39;_lock&#39;, &#39;identity&#39;, &#39;access_token&#39;))

    def sig(self):
        # Like hash(self), but pulls in the access token. Protocol.refresh_credentials() uses this to find out
        # if the access_token needs to be refreshed.
        res = []
        for k in self.__dict__:
            if k in (&#39;_lock&#39;, &#39;identity&#39;):
                continue
            if k == &#39;access_token&#39;:
                res.append(self.access_token[&#39;access_token&#39;] if self.access_token else None)
                continue
            res.append(getattr(self, k))
        return hash(tuple(res))

    def __repr__(self):
        return self.__class__.__name__ + repr((self.client_id, &#39;********&#39;))

    def __str__(self):
        return self.client_id</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.BaseCredentials" href="credentials.html#exchangelib.credentials.BaseCredentials">BaseCredentials</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.credentials.OAuth2AuthorizationCodeCredentials" href="credentials.html#exchangelib.credentials.OAuth2AuthorizationCodeCredentials">OAuth2AuthorizationCodeCredentials</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.OAuth2Credentials.on_token_auto_refreshed"><code class="name flex">
<span>def <span class="ident">on_token_auto_refreshed</span></span>(<span>self, access_token)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the access_token. Called after the access token is refreshed (requests-oauthlib can automatically
refresh tokens if given an OAuth client ID and secret, so this is how our copy of the token stays up-to-date).
Applications that cache access tokens can override this to store the new token - just remember to call the
super() method.</p>
<p>:param access_token: New token obtained by refreshing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_token_auto_refreshed(self, access_token):
    &#34;&#34;&#34;Set the access_token. Called after the access token is refreshed (requests-oauthlib can automatically
    refresh tokens if given an OAuth client ID and secret, so this is how our copy of the token stays up-to-date).
    Applications that cache access tokens can override this to store the new token - just remember to call the
    super() method.

    :param access_token: New token obtained by refreshing
    &#34;&#34;&#34;
    # Ensure we don&#39;t update the object in the middle of a new session being created, which could cause a race.
    if not isinstance(access_token, dict):
        raise ValueError(&#34;&#39;access_token&#39; must be an OAuth2Token&#34;)
    with self.lock:
        log.debug(&#39;%s auth token for %s&#39;, &#39;Refreshing&#39; if self.access_token else &#39;Setting&#39;, self.client_id)
        self.access_token = access_token</code></pre>
</details>
</dd>
<dt id="exchangelib.OAuth2Credentials.sig"><code class="name flex">
<span>def <span class="ident">sig</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sig(self):
    # Like hash(self), but pulls in the access token. Protocol.refresh_credentials() uses this to find out
    # if the access_token needs to be refreshed.
    res = []
    for k in self.__dict__:
        if k in (&#39;_lock&#39;, &#39;identity&#39;):
            continue
        if k == &#39;access_token&#39;:
            res.append(self.access_token[&#39;access_token&#39;] if self.access_token else None)
            continue
        res.append(getattr(self, k))
    return hash(tuple(res))</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.credentials.BaseCredentials" href="credentials.html#exchangelib.credentials.BaseCredentials">BaseCredentials</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.credentials.BaseCredentials.refresh" href="credentials.html#exchangelib.credentials.BaseCredentials.refresh">refresh</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.OofSettings"><code class="flex name class">
<span>class <span class="ident">OofSettings</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/oofsettings">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/oofsettings</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OofSettings(EWSElement):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/oofsettings&#34;&#34;&#34;

    ELEMENT_NAME = &#39;OofSettings&#39;
    REQUEST_ELEMENT_NAME = &#39;UserOofSettings&#39;

    ENABLED = &#39;Enabled&#39;
    SCHEDULED = &#39;Scheduled&#39;
    DISABLED = &#39;Disabled&#39;
    STATE_CHOICES = (ENABLED, SCHEDULED, DISABLED)

    state = ChoiceField(field_uri=&#39;OofState&#39;, is_required=True, choices={Choice(c) for c in STATE_CHOICES})
    external_audience = ChoiceField(field_uri=&#39;ExternalAudience&#39;,
                                    choices={Choice(&#39;None&#39;), Choice(&#39;Known&#39;), Choice(&#39;All&#39;)}, default=&#39;All&#39;)
    start = DateTimeField(field_uri=&#39;StartTime&#39;)
    end = DateTimeField(field_uri=&#39;EndTime&#39;)
    internal_reply = MessageField(field_uri=&#39;InternalReply&#39;)
    external_reply = MessageField(field_uri=&#39;ExternalReply&#39;)

    def clean(self, version=None):
        super().clean(version=version)
        if self.state == self.SCHEDULED:
            if not self.start or not self.end:
                raise ValueError(&#34;&#39;start&#39; and &#39;end&#39; must be set when state is &#39;%s&#39;&#34; % self.SCHEDULED)
            if self.start &gt;= self.end:
                raise ValueError(&#34;&#39;start&#39; must be before &#39;end&#39;&#34;)
            if self.end &lt; datetime.datetime.now(tz=UTC):
                raise ValueError(&#34;&#39;end&#39; must be in the future&#34;)
        if self.state != self.DISABLED and (not self.internal_reply or not self.external_reply):
            raise ValueError(&#34;&#39;internal_reply&#39; and &#39;external_reply&#39; must be set when state is not &#39;%s&#39;&#34; % self.DISABLED)

    @classmethod
    def from_xml(cls, elem, account):
        kwargs = {}
        for attr in (&#39;state&#39;, &#39;external_audience&#39;, &#39;internal_reply&#39;, &#39;external_reply&#39;):
            f = cls.get_field_by_fieldname(attr)
            kwargs[attr] = f.from_xml(elem=elem, account=account)
        kwargs.update(OutOfOffice.duration_to_start_end(elem=elem, account=account))
        cls._clear(elem)
        return cls(**kwargs)

    def to_xml(self, version):
        self.clean(version=version)
        elem = create_element(&#39;t:%s&#39; % self.REQUEST_ELEMENT_NAME)
        for attr in (&#39;state&#39;, &#39;external_audience&#39;):
            value = getattr(self, attr)
            if value is None:
                continue
            f = self.get_field_by_fieldname(attr)
            set_xml_value(elem, f.to_xml(value, version=version), version=version)
        if self.start or self.end:
            duration = create_element(&#39;t:Duration&#39;)
            if self.start:
                f = self.get_field_by_fieldname(&#39;start&#39;)
                set_xml_value(duration, f.to_xml(self.start, version=version), version)
            if self.end:
                f = self.get_field_by_fieldname(&#39;end&#39;)
                set_xml_value(duration, f.to_xml(self.end, version=version), version)
            elem.append(duration)
        for attr in (&#39;internal_reply&#39;, &#39;external_reply&#39;):
            value = getattr(self, attr)
            if value is None:
                value = &#39;&#39;  # The value can be empty, but the XML element must always be present
            f = self.get_field_by_fieldname(attr)
            set_xml_value(elem, f.to_xml(value, version=version), version)
        return elem

    def __hash__(self):
        # Customize comparison
        if self.state == self.DISABLED:
            # All values except state are ignored by the server
            relevant_attrs = (&#39;state&#39;,)
        elif self.state != self.SCHEDULED:
            # &#39;start&#39; and &#39;end&#39; values are ignored by the server, and the server always returns today&#39;s date
            relevant_attrs = tuple(f.name for f in self.FIELDS if f.name not in (&#39;start&#39;, &#39;end&#39;))
        else:
            relevant_attrs = tuple(f.name for f in self.FIELDS)
        return hash(tuple(getattr(self, attr) for attr in relevant_attrs))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.OofSettings.DISABLED"><code class="name">var <span class="ident">DISABLED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.ENABLED"><code class="name">var <span class="ident">ENABLED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.REQUEST_ELEMENT_NAME"><code class="name">var <span class="ident">REQUEST_ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.SCHEDULED"><code class="name">var <span class="ident">SCHEDULED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.STATE_CHOICES"><code class="name">var <span class="ident">STATE_CHOICES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.OofSettings.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem, account):
    kwargs = {}
    for attr in (&#39;state&#39;, &#39;external_audience&#39;, &#39;internal_reply&#39;, &#39;external_reply&#39;):
        f = cls.get_field_by_fieldname(attr)
        kwargs[attr] = f.from_xml(elem=elem, account=account)
    kwargs.update(OutOfOffice.duration_to_start_end(elem=elem, account=account))
    cls._clear(elem)
    return cls(**kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.OofSettings.end"><code class="name">var <span class="ident">end</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.external_audience"><code class="name">var <span class="ident">external_audience</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.external_reply"><code class="name">var <span class="ident">external_reply</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.internal_reply"><code class="name">var <span class="ident">internal_reply</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.start"><code class="name">var <span class="ident">start</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.OofSettings.state"><code class="name">var <span class="ident">state</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.OofSettings.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, version=None):
    super().clean(version=version)
    if self.state == self.SCHEDULED:
        if not self.start or not self.end:
            raise ValueError(&#34;&#39;start&#39; and &#39;end&#39; must be set when state is &#39;%s&#39;&#34; % self.SCHEDULED)
        if self.start &gt;= self.end:
            raise ValueError(&#34;&#39;start&#39; must be before &#39;end&#39;&#34;)
        if self.end &lt; datetime.datetime.now(tz=UTC):
            raise ValueError(&#34;&#39;end&#39; must be in the future&#34;)
    if self.state != self.DISABLED and (not self.internal_reply or not self.external_reply):
        raise ValueError(&#34;&#39;internal_reply&#39; and &#39;external_reply&#39; must be set when state is not &#39;%s&#39;&#34; % self.DISABLED)</code></pre>
</details>
</dd>
<dt id="exchangelib.OofSettings.to_xml"><code class="name flex">
<span>def <span class="ident">to_xml</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xml(self, version):
    self.clean(version=version)
    elem = create_element(&#39;t:%s&#39; % self.REQUEST_ELEMENT_NAME)
    for attr in (&#39;state&#39;, &#39;external_audience&#39;):
        value = getattr(self, attr)
        if value is None:
            continue
        f = self.get_field_by_fieldname(attr)
        set_xml_value(elem, f.to_xml(value, version=version), version=version)
    if self.start or self.end:
        duration = create_element(&#39;t:Duration&#39;)
        if self.start:
            f = self.get_field_by_fieldname(&#39;start&#39;)
            set_xml_value(duration, f.to_xml(self.start, version=version), version)
        if self.end:
            f = self.get_field_by_fieldname(&#39;end&#39;)
            set_xml_value(duration, f.to_xml(self.end, version=version), version)
        elem.append(duration)
    for attr in (&#39;internal_reply&#39;, &#39;external_reply&#39;):
        value = getattr(self, attr)
        if value is None:
            value = &#39;&#39;  # The value can be empty, but the XML element must always be present
        f = self.get_field_by_fieldname(attr)
        set_xml_value(elem, f.to_xml(value, version=version), version)
    return elem</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.EWSElement.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.EWSElement.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.PostItem"><code class="flex name class">
<span>class <span class="ident">PostItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/postitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/postitem</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PostItem(Item):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/postitem&#34;&#34;&#34;

    ELEMENT_NAME = &#39;PostItem&#39;

    conversation_index = Message.FIELDS[&#39;conversation_index&#39;]
    conversation_topic = Message.FIELDS[&#39;conversation_topic&#39;]

    author = Message.FIELDS[&#39;author&#39;]
    message_id = Message.FIELDS[&#39;message_id&#39;]
    is_read = Message.FIELDS[&#39;is_read&#39;]

    posted_time = DateTimeField(field_uri=&#39;postitem:PostedTime&#39;, is_read_only=True)
    references = TextField(field_uri=&#39;message:References&#39;)
    sender = MailboxField(field_uri=&#39;message:Sender&#39;, is_read_only=True, is_read_only_after_send=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.PostItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.PostItem.author"><code class="name">var <span class="ident">author</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.conversation_index"><code class="name">var <span class="ident">conversation_index</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.conversation_topic"><code class="name">var <span class="ident">conversation_topic</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.is_read"><code class="name">var <span class="ident">is_read</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.message_id"><code class="name">var <span class="ident">message_id</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.posted_time"><code class="name">var <span class="ident">posted_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.references"><code class="name">var <span class="ident">references</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.PostItem.sender"><code class="name">var <span class="ident">sender</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.item.Item.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.item.Item.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attach" href="items/item.html#exchangelib.items.item.Item.attach">attach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.item.Item.detach" href="items/item.html#exchangelib.items.item.Item.detach">detach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.item.Item.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.item.Item.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.item.Item.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Q"><code class="flex name class">
<span>class <span class="ident">Q</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>A class with an API similar to Django Q objects. Used to implemnt advanced filtering logic.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Q:
    &#34;&#34;&#34;A class with an API similar to Django Q objects. Used to implemnt advanced filtering logic.&#34;&#34;&#34;

    # Connection types
    AND = &#39;AND&#39;
    OR = &#39;OR&#39;
    NOT = &#39;NOT&#39;
    NEVER = &#39;NEVER&#39;  # This is not specified by EWS. We use it for queries that will never match, e.g. &#39;foo__in=()&#39;
    CONN_TYPES = {AND, OR, NOT, NEVER}

    # EWS Operators
    EQ = &#39;==&#39;
    NE = &#39;!=&#39;
    GT = &#39;&gt;&#39;
    GTE = &#39;&gt;=&#39;
    LT = &#39;&lt;&#39;
    LTE = &#39;&lt;=&#39;
    EXACT = &#39;exact&#39;
    IEXACT = &#39;iexact&#39;
    CONTAINS = &#39;contains&#39;
    ICONTAINS = &#39;icontains&#39;
    STARTSWITH = &#39;startswith&#39;
    ISTARTSWITH = &#39;istartswith&#39;
    EXISTS = &#39;exists&#39;
    OP_TYPES = {EQ, NE, GT, GTE, LT, LTE, EXACT, IEXACT, CONTAINS, ICONTAINS, STARTSWITH, ISTARTSWITH, EXISTS}
    CONTAINS_OPS = {EXACT, IEXACT, CONTAINS, ICONTAINS, STARTSWITH, ISTARTSWITH}

    # Valid lookups
    LOOKUP_RANGE = &#39;range&#39;
    LOOKUP_IN = &#39;in&#39;
    LOOKUP_NOT = &#39;not&#39;
    LOOKUP_GT = &#39;gt&#39;
    LOOKUP_GTE = &#39;gte&#39;
    LOOKUP_LT = &#39;lt&#39;
    LOOKUP_LTE = &#39;lte&#39;
    LOOKUP_EXACT = &#39;exact&#39;
    LOOKUP_IEXACT = &#39;iexact&#39;
    LOOKUP_CONTAINS = &#39;contains&#39;
    LOOKUP_ICONTAINS = &#39;icontains&#39;
    LOOKUP_STARTSWITH = &#39;startswith&#39;
    LOOKUP_ISTARTSWITH = &#39;istartswith&#39;
    LOOKUP_EXISTS = &#39;exists&#39;
    LOOKUP_TYPES = {LOOKUP_RANGE, LOOKUP_IN, LOOKUP_NOT, LOOKUP_GT, LOOKUP_GTE, LOOKUP_LT, LOOKUP_LTE, LOOKUP_EXACT,
                    LOOKUP_IEXACT, LOOKUP_CONTAINS, LOOKUP_ICONTAINS, LOOKUP_STARTSWITH, LOOKUP_ISTARTSWITH,
                    LOOKUP_EXISTS}

    __slots__ = &#39;conn_type&#39;, &#39;field_path&#39;, &#39;op&#39;, &#39;value&#39;, &#39;children&#39;, &#39;query_string&#39;

    def __init__(self, *args, **kwargs):
        self.conn_type = kwargs.pop(&#39;conn_type&#39;, self.AND)

        self.field_path = None  # Name of the field we want to filter on
        self.op = None
        self.value = None
        self.query_string = None

        # Parsing of args and kwargs may require child elements
        self.children = []

        # Check for query string as the only argument
        if not kwargs and len(args) == 1 and isinstance(args[0], str):
            self.query_string = args[0]
            args = ()

        # Parse args which must now be Q objects
        for q in args:
            if not isinstance(q, self.__class__):
                raise ValueError(&#34;Non-keyword arg %r must be a Q instance&#34; % q)
        self.children.extend(args)

        # Parse keyword args and extract the filter
        is_single_kwarg = len(args) == 0 and len(kwargs) == 1
        for key, value in kwargs.items():
            self.children.extend(
                self._get_children_from_kwarg(key=key, value=value, is_single_kwarg=is_single_kwarg)
            )

        # Simplify this object
        self.reduce()

        # Final sanity check
        self._check_integrity()

    def _get_children_from_kwarg(self, key, value, is_single_kwarg=False):
        &#34;&#34;&#34;Generate Q objects corresponding to a single keyword argument. Make this a leaf if there are no children to
        generate.
        &#34;&#34;&#34;
        key_parts = key.rsplit(&#39;__&#39;, 1)
        if len(key_parts) == 2 and key_parts[1] in self.LOOKUP_TYPES:
            # This is a kwarg with a lookup at the end
            field_path, lookup = key_parts
            if lookup == self.LOOKUP_EXISTS:
                # value=True will fall through to further processing
                if not value:
                    return [~self.__class__(**{key: True})]

            if lookup == self.LOOKUP_RANGE:
                # EWS doesn&#39;t have a &#39;range&#39; operator. Emulate &#39;foo__range=(1, 2)&#39; as &#39;foo__gte=1 and foo__lte=2&#39;
                # (both values inclusive).
                if len(value) != 2:
                    raise ValueError(&#34;Value of lookup &#39;%s&#39; must have exactly 2 elements&#34; % key)
                return [
                    self.__class__(**{&#39;%s__gte&#39; % field_path: value[0]}),
                    self.__class__(**{&#39;%s__lte&#39; % field_path: value[1]}),
                ]

            # Filtering on list types is a bit quirky. The only lookup type I have found to work is:
            #
            #     item:Categories == &#39;foo&#39; AND item:Categories == &#39;bar&#39; AND ...
            #
            #     item:Categories == &#39;foo&#39; OR item:Categories == &#39;bar&#39; OR ...
            #
            # The former returns items that have all these categories, but maybe also others. The latter returns
            # items that have at least one of these categories. This translates to the &#39;contains&#39; and &#39;in&#39; lookups,
            # respectively. Both versions are case-insensitive.
            #
            # Exact matching and case-sensitive or partial-string matching is not possible since that requires the
            # &#39;Contains&#39; element which only supports matching on string elements, not arrays.
            #
            # Exact matching of categories (i.e. match [&#39;a&#39;, &#39;b&#39;] but not [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) could be implemented by
            # post-processing items by fetch the categories field unconditionally and removing the items that don&#39;t
            # have an exact match.
            if lookup == self.LOOKUP_IN:
                # EWS doesn&#39;t have an &#39;__in&#39; operator. Allow &#39;__in&#39; lookups on list and non-list field types,
                # specifying a list value. We&#39;ll emulate it as a set of OR&#39;ed exact matches.
                if not is_iterable(value, generators_allowed=True):
                    raise ValueError(&#34;Value for lookup %r must be a list&#34; % key)
                children = [self.__class__(**{field_path: v}) for v in value]
                if not children:
                    # This is an &#39;__in&#39; operator with an empty list as the value. We interpret it to mean &#34;is foo
                    # contained in the empty set?&#34; which is always false. Mark this Q object as such.
                    return [self.__class__(conn_type=self.NEVER)]
                return [self.__class__(*children, conn_type=self.OR)]

            if lookup == self.LOOKUP_CONTAINS and is_iterable(value, generators_allowed=True):
                # A &#39;__contains&#39; lookup with an list as the value ony makes sense for list fields, since exact match
                # on multiple distinct values will always fail for single-value fields.
                #
                # An empty list as value is allowed. We interpret it to mean &#34;are all values in the empty set contained
                # in foo?&#34; which is always true.
                children = [self.__class__(**{field_path: v}) for v in value]
                return [self.__class__(*children, conn_type=self.AND)]

            try:
                op = self._lookup_to_op(lookup)
            except KeyError:
                raise ValueError(&#34;Lookup &#39;%s&#39; is not supported (called as &#39;%s=%r&#39;)&#34; % (lookup, key, value))
        else:
            field_path, op = key, self.EQ

        if not is_single_kwarg:
            return [self.__class__(**{key: value})]

        # This is a single-kwarg Q object with a lookup that requires a single value. Make this a leaf
        self.field_path = field_path
        self.op = op
        self.value = value
        return []

    def reduce(self):
        &#34;&#34;&#34;Simplify this object, if possible.&#34;&#34;&#34;
        self._reduce_children()
        self._promote()

    def _reduce_children(self):
        &#34;&#34;&#34;Look at the children of this object and remove unnecessary items.&#34;&#34;&#34;
        children = self.children
        if any((isinstance(a, self.__class__) and a.is_never()) for a in children):
            # We have at least one &#39;never&#39; arg
            if self.conn_type == self.AND:
                # Remove all other args since nothing we AND together with a &#39;never&#39; arg can change the result
                children = [self.__class__(conn_type=self.NEVER)]
            elif self.conn_type == self.OR:
                # Remove all &#39;never&#39; args because all other args will decide the result. Keep one &#39;never&#39; arg in case
                # all args are &#39;never&#39; args.
                children = [a for a in children if not (isinstance(a, self.__class__) and a.is_never())]
                if not children:
                    children = [self.__class__(conn_type=self.NEVER)]
            elif self.conn_type == self.NOT:
                # Let&#39;s interpret &#39;not never&#39; to mean &#39;always&#39;. Remove all &#39;never&#39; args
                children = [a for a in children if not (isinstance(a, self.__class__) and a.is_never())]

        # Remove any empty Q elements in args before proceeding
        children = [a for a in children if not (isinstance(a, self.__class__) and a.is_empty())]
        self.children = children

    def _promote(self):
        &#34;&#34;&#34;When we only have one child and no expression on ourselves, we are a no-op. Flatten by taking over the only
        child.
        &#34;&#34;&#34;
        if len(self.children) != 1 or self.field_path is not None or self.conn_type == self.NOT:
            return

        q = self.children[0]
        self.conn_type = q.conn_type
        self.field_path = q.field_path
        self.op = q.op
        self.value = q.value
        self.query_string = q.query_string
        self.children = q.children

    def clean(self, version):
        &#34;&#34;&#34;Do some basic checks on the attributes, using a generic folder. to_xml() does a really good job of
        validating. There&#39;s no reason to replicate much of that here.
        &#34;&#34;&#34;
        from .folders import Folder
        self.to_xml(folders=[Folder()], version=version, applies_to=Restriction.ITEMS)

    @classmethod
    def _lookup_to_op(cls, lookup):
        return {
            cls.LOOKUP_NOT: cls.NE,
            cls.LOOKUP_GT: cls.GT,
            cls.LOOKUP_GTE: cls.GTE,
            cls.LOOKUP_LT: cls.LT,
            cls.LOOKUP_LTE: cls.LTE,
            cls.LOOKUP_EXACT: cls.EXACT,
            cls.LOOKUP_IEXACT: cls.IEXACT,
            cls.LOOKUP_CONTAINS: cls.CONTAINS,
            cls.LOOKUP_ICONTAINS: cls.ICONTAINS,
            cls.LOOKUP_STARTSWITH: cls.STARTSWITH,
            cls.LOOKUP_ISTARTSWITH: cls.ISTARTSWITH,
            cls.LOOKUP_EXISTS: cls.EXISTS,
        }[lookup]

    @classmethod
    def _conn_to_xml(cls, conn_type):
        xml_tag_map = {
            cls.AND: &#39;t:And&#39;,
            cls.OR: &#39;t:Or&#39;,
            cls.NOT: &#39;t:Not&#39;,
        }
        return create_element(xml_tag_map[conn_type])

    @classmethod
    def _op_to_xml(cls, op):
        xml_tag_map = {
            cls.EQ: &#39;t:IsEqualTo&#39;,
            cls.NE: &#39;t:IsNotEqualTo&#39;,
            cls.GTE: &#39;t:IsGreaterThanOrEqualTo&#39;,
            cls.LTE: &#39;t:IsLessThanOrEqualTo&#39;,
            cls.LT: &#39;t:IsLessThan&#39;,
            cls.GT: &#39;t:IsGreaterThan&#39;,
            cls.EXISTS: &#39;t:Exists&#39;,
        }
        if op in xml_tag_map:
            return create_element(xml_tag_map[op])
        valid_ops = cls.EXACT, cls.IEXACT, cls.CONTAINS, cls.ICONTAINS, cls.STARTSWITH, cls.ISTARTSWITH
        if op not in valid_ops:
            raise ValueError(&#34;&#39;op&#39; %s must be one of %s&#34; % (op, valid_ops))

        # For description of Contains attribute values, see
        #     https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/contains
        #
        # Possible ContainmentMode values:
        #     FullString, Prefixed, Substring, PrefixOnWords, ExactPhrase
        # Django lookups have no equivalent of PrefixOnWords and ExactPhrase (and I&#39;m unsure how they actually
        # work).
        #
        # EWS has no equivalent of &#39;__endswith&#39; or &#39;__iendswith&#39;. That could be emulated using &#39;__contains&#39; and
        # &#39;__icontains&#39; and filtering results afterwards in Python. But it could be inefficient because we might be
        # fetching and discarding a lot of non-matching items, plus we would need to always fetch the field we&#39;re
        # matching on, to be able to do the filtering. I think it&#39;s better to leave this to the consumer, i.e.:
        #
        # items = [i for i in fld.filter(subject__contains=suffix) if i.subject.endswith(suffix)]
        # items = [i for i in fld.filter(subject__icontains=suffix) if i.subject.lower().endswith(suffix.lower())]
        #
        # Possible ContainmentComparison values (there are more, but the rest are &#34;To be removed&#34;):
        #     Exact, IgnoreCase, IgnoreNonSpacingCharacters, IgnoreCaseAndNonSpacingCharacters
        # I&#39;m unsure about non-spacing characters, but as I read
        #    https://en.wikipedia.org/wiki/Graphic_character#Spacing_and_non-spacing_characters
        # we shouldn&#39;t ignore them (&#39;a&#39; would match both &#39;a&#39; and &#39;Ã¥&#39;, the latter having a non-spacing character).
        if op in {cls.EXACT, cls.IEXACT}:
            match_mode = &#39;FullString&#39;
        elif op in (cls.CONTAINS, cls.ICONTAINS):
            match_mode = &#39;Substring&#39;
        elif op in (cls.STARTSWITH, cls.ISTARTSWITH):
            match_mode = &#39;Prefixed&#39;
        else:
            raise ValueError(&#39;Unsupported op: %s&#39; % op)
        if op in (cls.IEXACT, cls.ICONTAINS, cls.ISTARTSWITH):
            compare_mode = &#39;IgnoreCase&#39;
        else:
            compare_mode = &#39;Exact&#39;
        return create_element(
            &#39;t:Contains&#39;,
            attrs=OrderedDict([
                (&#39;ContainmentMode&#39;, match_mode),
                (&#39;ContainmentComparison&#39;, compare_mode),
            ])
        )

    def is_leaf(self):
        return not self.children

    def is_empty(self):
        &#34;&#34;&#34;Return True if this object is without any restrictions at all.&#34;&#34;&#34;
        return self.is_leaf() and self.field_path is None and self.query_string is None and self.conn_type != self.NEVER

    def is_never(self):
        &#34;&#34;&#34;Return True if this object has a restriction that will never match anything.&#34;&#34;&#34;
        return self.conn_type == self.NEVER

    def expr(self):
        if self.is_empty():
            return None
        if self.is_never():
            return self.NEVER
        if self.query_string:
            return self.query_string
        if self.is_leaf():
            expr = &#39;%s %s %r&#39; % (self.field_path, self.op, self.value)
        else:
            # Sort children by field name so we get stable output (for easier testing). Children should never be empty.
            expr = (&#39; %s &#39; % (self.AND if self.conn_type == self.NOT else self.conn_type)).join(
                (c.expr() if c.is_leaf() or c.conn_type == self.NOT else &#39;(%s)&#39; % c.expr())
                for c in sorted(self.children, key=lambda i: i.field_path or &#39;&#39;)
            )
        if self.conn_type == self.NOT:
            # Add the NOT operator. Put children in parens if there is more than one child.
            if self.is_leaf() or len(self.children) == 1:
                return self.conn_type + &#39; %s&#39; % expr
            return self.conn_type + &#39; (%s)&#39; % expr
        return expr

    def to_xml(self, folders, version, applies_to):
        if self.query_string:
            self._check_integrity()
            if version.build &lt; EXCHANGE_2010:
                raise NotImplementedError(&#39;QueryString filtering is only supported for Exchange 2010 servers and later&#39;)
            elem = create_element(&#39;m:QueryString&#39;)
            elem.text = self.query_string
            return elem
        # Translate this Q object to a valid Restriction XML tree
        elem = self.xml_elem(folders=folders, version=version, applies_to=applies_to)
        if elem is None:
            return None
        restriction = create_element(&#39;m:Restriction&#39;)
        restriction.append(elem)
        return restriction

    def _check_integrity(self):
        if self.is_empty():
            return
        if self.conn_type == self.NEVER:
            if any([self.field_path, self.op, self.value, self.children]):
                raise ValueError(&#34;&#39;never&#39; queries cannot be combined with other settings&#34;)
            return
        if self.query_string:
            if any([self.field_path, self.op, self.value, self.children]):
                raise ValueError(&#39;Query strings cannot be combined with other settings&#39;)
            return
        if self.conn_type not in self.CONN_TYPES:
            raise ValueError(&#34;&#39;conn_type&#39; %s must be one of %s&#34; % (self.conn_type, self.CONN_TYPES))
        if not self.is_leaf():
            for q in self.children:
                if q.query_string and len(self.children) &gt; 1:
                    raise ValueError(
                        &#39;A query string cannot be combined with other restrictions&#39;
                    )
            return
        if not self.field_path:
            raise ValueError(&#34;&#39;field_path&#39; must be set&#34;)
        if self.op not in self.OP_TYPES:
            raise ValueError(&#34;&#39;op&#39; %s must be one of %s&#34; % (self.op, self.OP_TYPES))
        if self.op == self.EXISTS and self.value is not True:
            raise ValueError(&#34;&#39;value&#39; must be True when operator is EXISTS&#34;)
        if self.value is None:
            raise ValueError(&#39;Value for filter on field path &#34;%s&#34; cannot be None&#39; % self.field_path)
        if is_iterable(self.value, generators_allowed=True):
            raise ValueError(
                &#39;Value %r for filter on field path &#34;%s&#34; must be a single value&#39; % (self.value, self.field_path)
            )

    def _validate_field_path(self, field_path, folder, applies_to, version):
        from .indexed_properties import MultiFieldIndexedElement
        if applies_to == Restriction.FOLDERS:
            # This is a restriction on Folder fields
            folder.validate_field(field=field_path.field, version=version)
        else:
            folder.validate_item_field(field=field_path.field, version=version)
        if not field_path.field.is_searchable:
            raise ValueError(&#34;EWS does not support filtering on field &#39;%s&#39;&#34; % field_path.field.name)
        if field_path.subfield and not field_path.subfield.is_searchable:
            raise ValueError(&#34;EWS does not support filtering on subfield &#39;%s&#39;&#34; % field_path.subfield.name)
        if issubclass(field_path.field.value_cls, MultiFieldIndexedElement) and not field_path.subfield:
            raise ValueError(&#34;Field path &#39;%s&#39; must contain a subfield&#34; % self.field_path)

    def _get_field_path(self, folders, applies_to, version):
        # Convert the string field path to a real FieldPath object. The path is validated using the given folders.
        for folder in folders:
            try:
                if applies_to == Restriction.FOLDERS:
                    # This is a restriction on Folder fields
                    field = folder.get_field_by_fieldname(fieldname=self.field_path)
                    field_path = FieldPath(field=field)
                else:
                    field_path = FieldPath.from_string(field_path=self.field_path, folder=folder)
            except ValueError:
                continue
            self._validate_field_path(field_path=field_path, folder=folder, applies_to=applies_to, version=version)
            break
        else:
            raise InvalidField(&#34;Unknown field path %r on folders %s&#34; % (self.field_path, folders))
        return field_path

    def _get_clean_value(self, field_path, version):
        if self.op == self.EXISTS:
            return None
        clean_field = field_path.subfield if (field_path.subfield and field_path.label) else field_path.field
        if clean_field.is_list:
            # __contains and __in are implemented as multiple leaves, with one value per leaf. clean() on list fields
            # only works on lists, so clean a one-element list.
            return clean_field.clean(value=[self.value], version=version)[0]
        return clean_field.clean(value=self.value, version=version)

    def xml_elem(self, folders, version, applies_to):
        # Recursively build an XML tree structure of this Q object. If this is an empty leaf (the equivalent of Q()),
        # return None.
        from .indexed_properties import SingleFieldIndexedElement
        # Don&#39;t check self.value just yet. We want to return error messages on the field path first, and then the value.
        # This is done in _get_field_path() and _get_clean_value(), respectively.
        self._check_integrity()
        if self.is_empty():
            return None
        if self.is_never():
            raise ValueError(&#34;EWS does not support &#39;never&#39; queries&#34;)
        if self.is_leaf():
            elem = self._op_to_xml(self.op)
            field_path = self._get_field_path(folders, applies_to=applies_to, version=version)
            clean_value = self._get_clean_value(field_path=field_path, version=version)
            if issubclass(field_path.field.value_cls, SingleFieldIndexedElement) and not field_path.label:
                # We allow a filter shortcut of e.g. email_addresses__contains=EmailAddress(label=&#39;Foo&#39;, ...) instead of
                # email_addresses__Foo_email_address=.... Set FieldPath label now so we can generate the field_uri.
                field_path.label = clean_value.label
            elif isinstance(field_path.field, DateTimeBackedDateField):
                # We need to convert to datetime
                clean_value = field_path.field.date_to_datetime(clean_value)
            elem.append(field_path.to_xml())
            constant = create_element(&#39;t:Constant&#39;)
            if self.op != self.EXISTS:
                # Use .set() to not fill up the create_element() cache with unique values
                constant.set(&#39;Value&#39;, value_to_xml_text(clean_value))
                if self.op in self.CONTAINS_OPS:
                    elem.append(constant)
                else:
                    uriorconst = create_element(&#39;t:FieldURIOrConstant&#39;)
                    uriorconst.append(constant)
                    elem.append(uriorconst)
        elif len(self.children) == 1:
            # We have only one child
            elem = self.children[0].xml_elem(folders=folders, version=version, applies_to=applies_to)
        else:
            # We have multiple children. If conn_type is NOT, then group children with AND. We&#39;ll add the NOT later
            elem = self._conn_to_xml(self.AND if self.conn_type == self.NOT else self.conn_type)
            # Sort children by field name so we get stable output (for easier testing). Children should never be empty
            for c in sorted(self.children, key=lambda i: i.field_path or &#39;&#39;):
                elem.append(c.xml_elem(folders=folders, version=version, applies_to=applies_to))
        if elem is None:
            return None  # Should not be necessary, but play safe
        if self.conn_type == self.NOT:
            # Encapsulate everything in the NOT element
            not_elem = self._conn_to_xml(self.conn_type)
            not_elem.append(elem)
            return not_elem
        return elem

    def __and__(self, other):
        # &amp; operator. Return a new Q with two children and conn_type AND
        return self.__class__(self, other, conn_type=self.AND)

    def __or__(self, other):
        # | operator. Return a new Q with two children and conn_type OR
        return self.__class__(self, other, conn_type=self.OR)

    def __invert__(self):
        # ~ operator. If op has an inverse, change op. Else return a new Q with conn_type NOT
        if self.conn_type == self.NOT:
            # This is NOT NOT. Change to AND
            new = copy(self)
            new.conn_type = self.AND
            new.reduce()
            return new
        if self.is_leaf():
            inverse_ops = {
                self.EQ: self.NE,
                self.NE: self.EQ,
                self.GT: self.LTE,
                self.GTE: self.LT,
                self.LT: self.GTE,
                self.LTE: self.GT,
            }
            try:
                new = copy(self)
                new.op = inverse_ops[self.op]
                new.reduce()
                return new
            except KeyError:
                pass
        return self.__class__(self, conn_type=self.NOT)

    def __eq__(self, other):
        return repr(self) == repr(other)

    def __hash__(self):
        return hash(repr(self))

    def __str__(self):
        return self.expr() or &#39;Q()&#39;

    def __repr__(self):
        if self.is_leaf():
            if self.query_string:
                return self.__class__.__name__ + &#39;(%r)&#39; % self.query_string
            if self.is_never():
                return self.__class__.__name__ + &#39;(conn_type=%r)&#39; % (self.conn_type)
            return self.__class__.__name__ + &#39;(%s %s %r)&#39; % (self.field_path, self.op, self.value)
        sorted_children = tuple(sorted(self.children, key=lambda i: i.field_path or &#39;&#39;))
        if self.conn_type == self.NOT or len(self.children) &gt; 1:
            return self.__class__.__name__ + repr((self.conn_type,) + sorted_children)
        return self.__class__.__name__ + repr(sorted_children)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Q.AND"><code class="name">var <span class="ident">AND</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.CONN_TYPES"><code class="name">var <span class="ident">CONN_TYPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.CONTAINS"><code class="name">var <span class="ident">CONTAINS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.CONTAINS_OPS"><code class="name">var <span class="ident">CONTAINS_OPS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.EQ"><code class="name">var <span class="ident">EQ</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.EXACT"><code class="name">var <span class="ident">EXACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.EXISTS"><code class="name">var <span class="ident">EXISTS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.GT"><code class="name">var <span class="ident">GT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.GTE"><code class="name">var <span class="ident">GTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.ICONTAINS"><code class="name">var <span class="ident">ICONTAINS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.IEXACT"><code class="name">var <span class="ident">IEXACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.ISTARTSWITH"><code class="name">var <span class="ident">ISTARTSWITH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_CONTAINS"><code class="name">var <span class="ident">LOOKUP_CONTAINS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_EXACT"><code class="name">var <span class="ident">LOOKUP_EXACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_EXISTS"><code class="name">var <span class="ident">LOOKUP_EXISTS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_GT"><code class="name">var <span class="ident">LOOKUP_GT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_GTE"><code class="name">var <span class="ident">LOOKUP_GTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_ICONTAINS"><code class="name">var <span class="ident">LOOKUP_ICONTAINS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_IEXACT"><code class="name">var <span class="ident">LOOKUP_IEXACT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_IN"><code class="name">var <span class="ident">LOOKUP_IN</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_ISTARTSWITH"><code class="name">var <span class="ident">LOOKUP_ISTARTSWITH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_LT"><code class="name">var <span class="ident">LOOKUP_LT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_LTE"><code class="name">var <span class="ident">LOOKUP_LTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_NOT"><code class="name">var <span class="ident">LOOKUP_NOT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_RANGE"><code class="name">var <span class="ident">LOOKUP_RANGE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_STARTSWITH"><code class="name">var <span class="ident">LOOKUP_STARTSWITH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LOOKUP_TYPES"><code class="name">var <span class="ident">LOOKUP_TYPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LT"><code class="name">var <span class="ident">LT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.LTE"><code class="name">var <span class="ident">LTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.NE"><code class="name">var <span class="ident">NE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.NEVER"><code class="name">var <span class="ident">NEVER</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.NOT"><code class="name">var <span class="ident">NOT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.OP_TYPES"><code class="name">var <span class="ident">OP_TYPES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.OR"><code class="name">var <span class="ident">OR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Q.STARTSWITH"><code class="name">var <span class="ident">STARTSWITH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Q.children"><code class="name">var <span class="ident">children</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Q.conn_type"><code class="name">var <span class="ident">conn_type</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Q.field_path"><code class="name">var <span class="ident">field_path</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Q.op"><code class="name">var <span class="ident">op</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Q.query_string"><code class="name">var <span class="ident">query_string</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Q.value"><code class="name">var <span class="ident">value</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Q.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, version)</span>
</code></dt>
<dd>
<div class="desc"><p>Do some basic checks on the attributes, using a generic folder. to_xml() does a really good job of
validating. There's no reason to replicate much of that here.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, version):
    &#34;&#34;&#34;Do some basic checks on the attributes, using a generic folder. to_xml() does a really good job of
    validating. There&#39;s no reason to replicate much of that here.
    &#34;&#34;&#34;
    from .folders import Folder
    self.to_xml(folders=[Folder()], version=version, applies_to=Restriction.ITEMS)</code></pre>
</details>
</dd>
<dt id="exchangelib.Q.expr"><code class="name flex">
<span>def <span class="ident">expr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expr(self):
    if self.is_empty():
        return None
    if self.is_never():
        return self.NEVER
    if self.query_string:
        return self.query_string
    if self.is_leaf():
        expr = &#39;%s %s %r&#39; % (self.field_path, self.op, self.value)
    else:
        # Sort children by field name so we get stable output (for easier testing). Children should never be empty.
        expr = (&#39; %s &#39; % (self.AND if self.conn_type == self.NOT else self.conn_type)).join(
            (c.expr() if c.is_leaf() or c.conn_type == self.NOT else &#39;(%s)&#39; % c.expr())
            for c in sorted(self.children, key=lambda i: i.field_path or &#39;&#39;)
        )
    if self.conn_type == self.NOT:
        # Add the NOT operator. Put children in parens if there is more than one child.
        if self.is_leaf() or len(self.children) == 1:
            return self.conn_type + &#39; %s&#39; % expr
        return self.conn_type + &#39; (%s)&#39; % expr
    return expr</code></pre>
</details>
</dd>
<dt id="exchangelib.Q.is_empty"><code class="name flex">
<span>def <span class="ident">is_empty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if this object is without any restrictions at all.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_empty(self):
    &#34;&#34;&#34;Return True if this object is without any restrictions at all.&#34;&#34;&#34;
    return self.is_leaf() and self.field_path is None and self.query_string is None and self.conn_type != self.NEVER</code></pre>
</details>
</dd>
<dt id="exchangelib.Q.is_leaf"><code class="name flex">
<span>def <span class="ident">is_leaf</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_leaf(self):
    return not self.children</code></pre>
</details>
</dd>
<dt id="exchangelib.Q.is_never"><code class="name flex">
<span>def <span class="ident">is_never</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return True if this object has a restriction that will never match anything.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_never(self):
    &#34;&#34;&#34;Return True if this object has a restriction that will never match anything.&#34;&#34;&#34;
    return self.conn_type == self.NEVER</code></pre>
</details>
</dd>
<dt id="exchangelib.Q.reduce"><code class="name flex">
<span>def <span class="ident">reduce</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Simplify this object, if possible.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce(self):
    &#34;&#34;&#34;Simplify this object, if possible.&#34;&#34;&#34;
    self._reduce_children()
    self._promote()</code></pre>
</details>
</dd>
<dt id="exchangelib.Q.to_xml"><code class="name flex">
<span>def <span class="ident">to_xml</span></span>(<span>self, folders, version, applies_to)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_xml(self, folders, version, applies_to):
    if self.query_string:
        self._check_integrity()
        if version.build &lt; EXCHANGE_2010:
            raise NotImplementedError(&#39;QueryString filtering is only supported for Exchange 2010 servers and later&#39;)
        elem = create_element(&#39;m:QueryString&#39;)
        elem.text = self.query_string
        return elem
    # Translate this Q object to a valid Restriction XML tree
    elem = self.xml_elem(folders=folders, version=version, applies_to=applies_to)
    if elem is None:
        return None
    restriction = create_element(&#39;m:Restriction&#39;)
    restriction.append(elem)
    return restriction</code></pre>
</details>
</dd>
<dt id="exchangelib.Q.xml_elem"><code class="name flex">
<span>def <span class="ident">xml_elem</span></span>(<span>self, folders, version, applies_to)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def xml_elem(self, folders, version, applies_to):
    # Recursively build an XML tree structure of this Q object. If this is an empty leaf (the equivalent of Q()),
    # return None.
    from .indexed_properties import SingleFieldIndexedElement
    # Don&#39;t check self.value just yet. We want to return error messages on the field path first, and then the value.
    # This is done in _get_field_path() and _get_clean_value(), respectively.
    self._check_integrity()
    if self.is_empty():
        return None
    if self.is_never():
        raise ValueError(&#34;EWS does not support &#39;never&#39; queries&#34;)
    if self.is_leaf():
        elem = self._op_to_xml(self.op)
        field_path = self._get_field_path(folders, applies_to=applies_to, version=version)
        clean_value = self._get_clean_value(field_path=field_path, version=version)
        if issubclass(field_path.field.value_cls, SingleFieldIndexedElement) and not field_path.label:
            # We allow a filter shortcut of e.g. email_addresses__contains=EmailAddress(label=&#39;Foo&#39;, ...) instead of
            # email_addresses__Foo_email_address=.... Set FieldPath label now so we can generate the field_uri.
            field_path.label = clean_value.label
        elif isinstance(field_path.field, DateTimeBackedDateField):
            # We need to convert to datetime
            clean_value = field_path.field.date_to_datetime(clean_value)
        elem.append(field_path.to_xml())
        constant = create_element(&#39;t:Constant&#39;)
        if self.op != self.EXISTS:
            # Use .set() to not fill up the create_element() cache with unique values
            constant.set(&#39;Value&#39;, value_to_xml_text(clean_value))
            if self.op in self.CONTAINS_OPS:
                elem.append(constant)
            else:
                uriorconst = create_element(&#39;t:FieldURIOrConstant&#39;)
                uriorconst.append(constant)
                elem.append(uriorconst)
    elif len(self.children) == 1:
        # We have only one child
        elem = self.children[0].xml_elem(folders=folders, version=version, applies_to=applies_to)
    else:
        # We have multiple children. If conn_type is NOT, then group children with AND. We&#39;ll add the NOT later
        elem = self._conn_to_xml(self.AND if self.conn_type == self.NOT else self.conn_type)
        # Sort children by field name so we get stable output (for easier testing). Children should never be empty
        for c in sorted(self.children, key=lambda i: i.field_path or &#39;&#39;):
            elem.append(c.xml_elem(folders=folders, version=version, applies_to=applies_to))
    if elem is None:
        return None  # Should not be necessary, but play safe
    if self.conn_type == self.NOT:
        # Encapsulate everything in the NOT element
        not_elem = self._conn_to_xml(self.conn_type)
        not_elem.append(elem)
        return not_elem
    return elem</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.ReplyAllToItem"><code class="flex name class">
<span>class <span class="ident">ReplyAllToItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/replyalltoitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/replyalltoitem</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplyAllToItem(BaseReplyItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/replyalltoitem&#34;&#34;&#34;

    ELEMENT_NAME = &#39;ReplyAllToItem&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.ReplyAllToItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.base.BaseReplyItem.account" href="items/base.html#exchangelib.items.base.BaseReplyItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.save" href="items/base.html#exchangelib.items.base.BaseReplyItem.save">save</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.ReplyToItem"><code class="flex name class">
<span>class <span class="ident">ReplyToItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/replytoitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/replytoitem</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReplyToItem(BaseReplyItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/replytoitem&#34;&#34;&#34;

    ELEMENT_NAME = &#39;ReplyToItem&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.ReplyToItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.base.BaseReplyItem" href="items/base.html#exchangelib.items.base.BaseReplyItem">BaseReplyItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.base.BaseReplyItem.account" href="items/base.html#exchangelib.items.base.BaseReplyItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.save" href="items/base.html#exchangelib.items.base.BaseReplyItem.save">save</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.base.BaseReplyItem.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.Room"><code class="flex name class">
<span>class <span class="ident">Room</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/room">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/room</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Room(Mailbox):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/room&#34;&#34;&#34;

    ELEMENT_NAME = &#39;Room&#39;

    @classmethod
    def from_xml(cls, elem, account):
        id_elem = elem.find(&#39;{%s}Id&#39; % TNS)
        item_id_elem = id_elem.find(ItemId.response_tag())
        kwargs = dict(
            name=get_xml_attr(id_elem, &#39;{%s}Name&#39; % TNS),
            email_address=get_xml_attr(id_elem, &#39;{%s}EmailAddress&#39; % TNS),
            mailbox_type=get_xml_attr(id_elem, &#39;{%s}MailboxType&#39; % TNS),
            item_id=ItemId.from_xml(elem=item_id_elem, account=account) if item_id_elem else None,
        )
        cls._clear(elem)
        return cls(**kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.Mailbox" href="properties.html#exchangelib.properties.Mailbox">Mailbox</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Room.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.Room.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem, account):
    id_elem = elem.find(&#39;{%s}Id&#39; % TNS)
    item_id_elem = id_elem.find(ItemId.response_tag())
    kwargs = dict(
        name=get_xml_attr(id_elem, &#39;{%s}Name&#39; % TNS),
        email_address=get_xml_attr(id_elem, &#39;{%s}EmailAddress&#39; % TNS),
        mailbox_type=get_xml_attr(id_elem, &#39;{%s}MailboxType&#39; % TNS),
        item_id=ItemId.from_xml(elem=item_id_elem, account=account) if item_id_elem else None,
    )
    cls._clear(elem)
    return cls(**kwargs)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.Mailbox" href="properties.html#exchangelib.properties.Mailbox">Mailbox</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.Mailbox.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.RoomList"><code class="flex name class">
<span>class <span class="ident">RoomList</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/roomlist">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/roomlist</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RoomList(Mailbox):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/roomlist&#34;&#34;&#34;

    ELEMENT_NAME = &#39;RoomList&#39;
    NAMESPACE = MNS

    @classmethod
    def response_tag(cls):
        # In a GetRoomLists response, room lists are delivered as Address elements. See
        # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/address-emailaddresstype
        return &#39;{%s}Address&#39; % TNS</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.properties.Mailbox" href="properties.html#exchangelib.properties.Mailbox">Mailbox</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.RoomList.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.RoomList.NAMESPACE"><code class="name">var <span class="ident">NAMESPACE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.RoomList.response_tag"><code class="name flex">
<span>def <span class="ident">response_tag</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def response_tag(cls):
    # In a GetRoomLists response, room lists are delivered as Address elements. See
    # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/address-emailaddresstype
    return &#39;{%s}Address&#39; % TNS</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.properties.Mailbox" href="properties.html#exchangelib.properties.Mailbox">Mailbox</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.properties.Mailbox.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.properties.Mailbox.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.RootOfHierarchy"><code class="flex name class">
<span>class <span class="ident">RootOfHierarchy</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for folders that implement the root of a folder hierarchy.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RootOfHierarchy(BaseFolder, metaclass=EWSMeta):
    &#34;&#34;&#34;Base class for folders that implement the root of a folder hierarchy.&#34;&#34;&#34;

    # A list of wellknown, or &#34;distinguished&#34;, folders that are belong in this folder hierarchy. See
    # https://docs.microsoft.com/en-us/dotnet/api/microsoft.exchange.webservices.data.wellknownfoldername
    # and https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/distinguishedfolderid
    # &#39;RootOfHierarchy&#39; subclasses must not be in this list.
    WELLKNOWN_FOLDERS = []

    _subfolders_lock = Lock()

    # This folder type also has &#39;folder:PermissionSet&#39; on some server versions, but requesting it sometimes causes
    # &#39;ErrorAccessDenied&#39;, as reported by some users. Ignore it entirely for root folders - it&#39;s usefulness is
    # deemed minimal at best.
    effective_rights = EffectiveRightsField(field_uri=&#39;folder:EffectiveRights&#39;, is_read_only=True,
                                            supported_from=EXCHANGE_2007_SP1)

    __slots__ = &#39;_account&#39;, &#39;_subfolders&#39;

    # A special folder that acts as the top of a folder hierarchy. Finds and caches subfolders at arbitrary depth.
    def __init__(self, **kwargs):
        self._account = kwargs.pop(&#39;account&#39;, None)  # A pointer back to the account holding the folder hierarchy
        super().__init__(**kwargs)
        self._subfolders = None  # See self._folders_map()

    @property
    def account(self):
        return self._account

    @property
    def root(self):
        return self

    @property
    def parent(self):
        return None

    @classmethod
    def register(cls, *args, **kwargs):
        if cls is not RootOfHierarchy:
            raise TypeError(&#39;For folder roots, custom fields must be registered on the RootOfHierarchy class&#39;)
        return super().register(*args, **kwargs)

    @classmethod
    def deregister(cls, *args, **kwargs):
        if cls is not RootOfHierarchy:
            raise TypeError(&#39;For folder roots, custom fields must be registered on the RootOfHierarchy class&#39;)
        return super().deregister(*args, **kwargs)

    def get_folder(self, folder):
        if not folder.id:
            raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
        return self._folders_map.get(folder.id, None)

    def add_folder(self, folder):
        if not folder.id:
            raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
        self._folders_map[folder.id] = folder

    def update_folder(self, folder):
        if not folder.id:
            raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
        self._folders_map[folder.id] = folder

    def remove_folder(self, folder):
        if not folder.id:
            raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
        try:
            del self._folders_map[folder.id]
        except KeyError:
            pass

    def clear_cache(self):
        with self._subfolders_lock:
            self._subfolders = None

    def get_children(self, folder):
        for f in self._folders_map.values():
            if not f.parent:
                continue
            if f.parent.id == folder.id:
                yield f

    @classmethod
    def get_distinguished(cls, account):
        &#34;&#34;&#34;Get the distinguished folder for this folder class.

        :param account:
        &#34;&#34;&#34;
        if not cls.DISTINGUISHED_FOLDER_ID:
            raise ValueError(&#39;Class %s must have a DISTINGUISHED_FOLDER_ID value&#39; % cls)
        try:
            return cls.resolve(
                account=account,
                folder=cls(account=account, name=cls.DISTINGUISHED_FOLDER_ID, is_distinguished=True)
            )
        except MISSING_FOLDER_ERRORS:
            raise ErrorFolderNotFound(&#39;Could not find distinguished folder %s&#39; % cls.DISTINGUISHED_FOLDER_ID)

    def get_default_folder(self, folder_cls):
        &#34;&#34;&#34;Return the distinguished folder instance of type folder_cls belonging to this account. If no distinguished
        folder was found, try as best we can to return the default folder of type &#39;folder_cls&#39;
        &#34;&#34;&#34;
        if not folder_cls.DISTINGUISHED_FOLDER_ID:
            raise ValueError(&#34;&#39;folder_cls&#39; %s must have a DISTINGUISHED_FOLDER_ID value&#34; % folder_cls)
        # Use cached distinguished folder instance, but only if cache has already been prepped. This is an optimization
        # for accessing e.g. &#39;account.contacts&#39; without fetching all folders of the account.
        if self._subfolders is not None:
            for f in self._folders_map.values():
                # Require exact class, to not match subclasses, e.g. RecipientCache instead of Contacts
                if f.__class__ == folder_cls and f.is_distinguished:
                    log.debug(&#39;Found cached distinguished %s folder&#39;, folder_cls)
                    return f
        try:
            log.debug(&#39;Requesting distinguished %s folder explicitly&#39;, folder_cls)
            return folder_cls.get_distinguished(root=self)
        except ErrorAccessDenied:
            # Maybe we just don&#39;t have GetFolder access? Try FindItems instead
            log.debug(&#39;Testing default %s folder with FindItem&#39;, folder_cls)
            fld = folder_cls(root=self, name=folder_cls.DISTINGUISHED_FOLDER_ID, is_distinguished=True)
            fld.test_access()
            return self._folders_map.get(fld.id, fld)  # Use cached instance if available
        except MISSING_FOLDER_ERRORS:
            # The Exchange server does not return a distinguished folder of this type
            pass
        raise ErrorFolderNotFound(&#39;No usable default %s folders&#39; % folder_cls)

    @property
    def _folders_map(self):
        if self._subfolders is not None:
            return self._subfolders

        with self._subfolders_lock:
            # Map root, and all subfolders of root, at arbitrary depth by folder ID. First get distinguished folders,
            # so we are sure to apply the correct Folder class, then fetch all subfolders of this root.
            folders_map = {self.id: self}
            distinguished_folders = [
                cls(root=self, name=cls.DISTINGUISHED_FOLDER_ID, is_distinguished=True)
                for cls in self.WELLKNOWN_FOLDERS
                if cls.get_folder_allowed and cls.supports_version(self.account.version)
            ]
            for f in FolderCollection(account=self.account, folders=distinguished_folders).resolve():
                if isinstance(f, MISSING_FOLDER_ERRORS):
                    # This is just a distinguished folder the server does not have
                    continue
                if isinstance(f, ErrorInvalidOperation):
                    # This is probably a distinguished folder the server does not have. We previously tested the exact
                    # error message (f.value), but some Exchange servers return localized error messages, so that&#39;s not
                    # possible to do reliably.
                    continue
                if isinstance(f, ErrorAccessDenied):
                    # We may not have GetFolder access, either to this folder or at all
                    continue
                if isinstance(f, Exception):
                    raise f
                folders_map[f.id] = f
            for f in SingleFolderQuerySet(account=self.account, folder=self).depth(
                    self.DEFAULT_FOLDER_TRAVERSAL_DEPTH
            ).all():
                if isinstance(f, ErrorAccessDenied):
                    # We may not have FindFolder access, or GetFolder access, either to this folder or at all
                    continue
                if isinstance(f, Exception):
                    raise f
                if f.id in folders_map:
                    # Already exists. Probably a distinguished folder
                    continue
                folders_map[f.id] = f
            self._subfolders = folders_map
            return folders_map

    @classmethod
    def from_xml(cls, elem, account):
        kwargs = cls._kwargs_from_elem(elem=elem, account=account)
        cls._clear(elem)
        return cls(account=account, **kwargs)

    @classmethod
    def folder_cls_from_folder_name(cls, folder_name, locale):
        &#34;&#34;&#34;Return the folder class that matches a localized folder name.

        :param folder_name:
        :param locale: a string, e.g. &#39;da_DK&#39;
        &#34;&#34;&#34;
        for folder_cls in cls.WELLKNOWN_FOLDERS + NON_DELETABLE_FOLDERS:
            if folder_name.lower() in folder_cls.localized_names(locale):
                return folder_cls
        raise KeyError()

    def __repr__(self):
        # Let&#39;s not create an infinite loop when printing self.root
        return self.__class__.__name__ + \
               repr((self.account, &#39;[self]&#39;, self.name, self.total_count, self.unread_count, self.child_folder_count,
                     self.folder_class, self.id, self.changekey))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.folders.base.BaseFolder" href="folders/base.html#exchangelib.folders.base.BaseFolder">BaseFolder</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
<li><a title="exchangelib.queryset.SearchableMixIn" href="queryset.html#exchangelib.queryset.SearchableMixIn">SearchableMixIn</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.folders.roots.ArchiveRoot" href="folders/roots.html#exchangelib.folders.roots.ArchiveRoot">ArchiveRoot</a></li>
<li><a title="exchangelib.folders.roots.PublicFoldersRoot" href="folders/roots.html#exchangelib.folders.roots.PublicFoldersRoot">PublicFoldersRoot</a></li>
<li><a title="exchangelib.folders.roots.Root" href="folders/roots.html#exchangelib.folders.roots.Root">Root</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.RootOfHierarchy.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.RootOfHierarchy.WELLKNOWN_FOLDERS"><code class="name">var <span class="ident">WELLKNOWN_FOLDERS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.RootOfHierarchy.folder_cls_from_folder_name"><code class="name flex">
<span>def <span class="ident">folder_cls_from_folder_name</span></span>(<span>folder_name, locale)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the folder class that matches a localized folder name.</p>
<p>:param folder_name:
:param locale: a string, e.g. 'da_DK'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def folder_cls_from_folder_name(cls, folder_name, locale):
    &#34;&#34;&#34;Return the folder class that matches a localized folder name.

    :param folder_name:
    :param locale: a string, e.g. &#39;da_DK&#39;
    &#34;&#34;&#34;
    for folder_cls in cls.WELLKNOWN_FOLDERS + NON_DELETABLE_FOLDERS:
        if folder_name.lower() in folder_cls.localized_names(locale):
            return folder_cls
    raise KeyError()</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.from_xml"><code class="name flex">
<span>def <span class="ident">from_xml</span></span>(<span>elem, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_xml(cls, elem, account):
    kwargs = cls._kwargs_from_elem(elem=elem, account=account)
    cls._clear(elem)
    return cls(account=account, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.get_distinguished"><code class="name flex">
<span>def <span class="ident">get_distinguished</span></span>(<span>account)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the distinguished folder for this folder class.</p>
<p>:param account:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_distinguished(cls, account):
    &#34;&#34;&#34;Get the distinguished folder for this folder class.

    :param account:
    &#34;&#34;&#34;
    if not cls.DISTINGUISHED_FOLDER_ID:
        raise ValueError(&#39;Class %s must have a DISTINGUISHED_FOLDER_ID value&#39; % cls)
    try:
        return cls.resolve(
            account=account,
            folder=cls(account=account, name=cls.DISTINGUISHED_FOLDER_ID, is_distinguished=True)
        )
    except MISSING_FOLDER_ERRORS:
        raise ErrorFolderNotFound(&#39;Could not find distinguished folder %s&#39; % cls.DISTINGUISHED_FOLDER_ID)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.RootOfHierarchy.account"><code class="name">var <span class="ident">account</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def account(self):
    return self._account</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.effective_rights"><code class="name">var <span class="ident">effective_rights</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.RootOfHierarchy.parent"><code class="name">var <span class="ident">parent</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def parent(self):
    return None</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.root"><code class="name">var <span class="ident">root</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def root(self):
    return self</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.RootOfHierarchy.add_folder"><code class="name flex">
<span>def <span class="ident">add_folder</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_folder(self, folder):
    if not folder.id:
        raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
    self._folders_map[folder.id] = folder</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.clear_cache"><code class="name flex">
<span>def <span class="ident">clear_cache</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_cache(self):
    with self._subfolders_lock:
        self._subfolders = None</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.get_children"><code class="name flex">
<span>def <span class="ident">get_children</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_children(self, folder):
    for f in self._folders_map.values():
        if not f.parent:
            continue
        if f.parent.id == folder.id:
            yield f</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.get_default_folder"><code class="name flex">
<span>def <span class="ident">get_default_folder</span></span>(<span>self, folder_cls)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the distinguished folder instance of type folder_cls belonging to this account. If no distinguished
folder was found, try as best we can to return the default folder of type 'folder_cls'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_default_folder(self, folder_cls):
    &#34;&#34;&#34;Return the distinguished folder instance of type folder_cls belonging to this account. If no distinguished
    folder was found, try as best we can to return the default folder of type &#39;folder_cls&#39;
    &#34;&#34;&#34;
    if not folder_cls.DISTINGUISHED_FOLDER_ID:
        raise ValueError(&#34;&#39;folder_cls&#39; %s must have a DISTINGUISHED_FOLDER_ID value&#34; % folder_cls)
    # Use cached distinguished folder instance, but only if cache has already been prepped. This is an optimization
    # for accessing e.g. &#39;account.contacts&#39; without fetching all folders of the account.
    if self._subfolders is not None:
        for f in self._folders_map.values():
            # Require exact class, to not match subclasses, e.g. RecipientCache instead of Contacts
            if f.__class__ == folder_cls and f.is_distinguished:
                log.debug(&#39;Found cached distinguished %s folder&#39;, folder_cls)
                return f
    try:
        log.debug(&#39;Requesting distinguished %s folder explicitly&#39;, folder_cls)
        return folder_cls.get_distinguished(root=self)
    except ErrorAccessDenied:
        # Maybe we just don&#39;t have GetFolder access? Try FindItems instead
        log.debug(&#39;Testing default %s folder with FindItem&#39;, folder_cls)
        fld = folder_cls(root=self, name=folder_cls.DISTINGUISHED_FOLDER_ID, is_distinguished=True)
        fld.test_access()
        return self._folders_map.get(fld.id, fld)  # Use cached instance if available
    except MISSING_FOLDER_ERRORS:
        # The Exchange server does not return a distinguished folder of this type
        pass
    raise ErrorFolderNotFound(&#39;No usable default %s folders&#39; % folder_cls)</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.get_folder"><code class="name flex">
<span>def <span class="ident">get_folder</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_folder(self, folder):
    if not folder.id:
        raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
    return self._folders_map.get(folder.id, None)</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.remove_folder"><code class="name flex">
<span>def <span class="ident">remove_folder</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_folder(self, folder):
    if not folder.id:
        raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
    try:
        del self._folders_map[folder.id]
    except KeyError:
        pass</code></pre>
</details>
</dd>
<dt id="exchangelib.RootOfHierarchy.update_folder"><code class="name flex">
<span>def <span class="ident">update_folder</span></span>(<span>self, folder)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_folder(self, folder):
    if not folder.id:
        raise ValueError(&#34;&#39;folder&#39; must have an ID&#34;)
    self._folders_map[folder.id] = folder</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.folders.base.BaseFolder" href="folders/base.html#exchangelib.folders.base.BaseFolder">BaseFolder</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.folders.base.BaseFolder.ID_ELEMENT_CLS" href="folders/base.html#exchangelib.folders.base.BaseFolder.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.folder_cls_from_container_class" href="folders/base.html#exchangelib.folders.base.BaseFolder.folder_cls_from_container_class">folder_cls_from_container_class</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.folder_sync_state" href="folders/base.html#exchangelib.folders.base.BaseFolder.folder_sync_state">folder_sync_state</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.get_events" href="folders/base.html#exchangelib.folders.base.BaseFolder.get_events">get_events</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.get_streaming_events" href="folders/base.html#exchangelib.folders.base.BaseFolder.get_streaming_events">get_streaming_events</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.is_distinguished" href="folders/base.html#exchangelib.folders.base.BaseFolder.is_distinguished">is_distinguished</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.item_sync_state" href="folders/base.html#exchangelib.folders.base.BaseFolder.item_sync_state">item_sync_state</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.subscribe_to_pull" href="folders/base.html#exchangelib.folders.base.BaseFolder.subscribe_to_pull">subscribe_to_pull</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.subscribe_to_push" href="folders/base.html#exchangelib.folders.base.BaseFolder.subscribe_to_push">subscribe_to_push</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.subscribe_to_streaming" href="folders/base.html#exchangelib.folders.base.BaseFolder.subscribe_to_streaming">subscribe_to_streaming</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.sync_hierarchy" href="folders/base.html#exchangelib.folders.base.BaseFolder.sync_hierarchy">sync_hierarchy</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.sync_items" href="folders/base.html#exchangelib.folders.base.BaseFolder.sync_items">sync_items</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.test_access" href="folders/base.html#exchangelib.folders.base.BaseFolder.test_access">test_access</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.tree" href="folders/base.html#exchangelib.folders.base.BaseFolder.tree">tree</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.unsubscribe" href="folders/base.html#exchangelib.folders.base.BaseFolder.unsubscribe">unsubscribe</a></code></li>
<li><code><a title="exchangelib.folders.base.BaseFolder.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.TLSClientAuth"><code class="flex name class">
<span>class <span class="ident">TLSClientAuth</span></span>
<span>(</span><span>pool_connections=10, pool_maxsize=10, max_retries=0, pool_block=False)</span>
</code></dt>
<dd>
<div class="desc"><p>An HTTP adapter that implements Certificate Based Authentication (CBA).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TLSClientAuth(requests.adapters.HTTPAdapter):
    &#34;&#34;&#34;An HTTP adapter that implements Certificate Based Authentication (CBA).&#34;&#34;&#34;

    cert_file = None

    def init_poolmanager(self, *args, **kwargs):
        kwargs[&#39;cert_file&#39;] = self.cert_file
        return super().init_poolmanager(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>requests.adapters.HTTPAdapter</li>
<li>requests.adapters.BaseAdapter</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.TLSClientAuth.cert_file"><code class="name">var <span class="ident">cert_file</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.TLSClientAuth.init_poolmanager"><code class="name flex">
<span>def <span class="ident">init_poolmanager</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes a urllib3 PoolManager.</p>
<p>This method should not be called from user code, and is only
exposed for use when subclassing the
:class:<code>HTTPAdapter &lt;requests.adapters.HTTPAdapter&gt;</code>.</p>
<p>:param connections: The number of urllib3 connection pools to cache.
:param maxsize: The maximum number of connections to save in the pool.
:param block: Block when no free connections are available.
:param pool_kwargs: Extra keyword arguments used to initialize the Pool Manager.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_poolmanager(self, *args, **kwargs):
    kwargs[&#39;cert_file&#39;] = self.cert_file
    return super().init_poolmanager(*args, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.Task"><code class="flex name class">
<span>class <span class="ident">Task</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/task">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/task</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Task(Item):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/task&#34;&#34;&#34;

    ELEMENT_NAME = &#39;Task&#39;
    NOT_STARTED = &#39;NotStarted&#39;
    COMPLETED = &#39;Completed&#39;

    actual_work = IntegerField(field_uri=&#39;task:ActualWork&#39;, min=0)
    assigned_time = DateTimeField(field_uri=&#39;task:AssignedTime&#39;, is_read_only=True)
    billing_information = TextField(field_uri=&#39;task:BillingInformation&#39;)
    change_count = IntegerField(field_uri=&#39;task:ChangeCount&#39;, is_read_only=True, min=0)
    companies = TextListField(field_uri=&#39;task:Companies&#39;)
    # &#39;complete_date&#39; can be set, but is ignored by the server, which sets it to now()
    complete_date = DateTimeField(field_uri=&#39;task:CompleteDate&#39;, is_read_only=True)
    contacts = TextListField(field_uri=&#39;task:Contacts&#39;)
    delegation_state = ChoiceField(field_uri=&#39;task:DelegationState&#39;, choices={
        Choice(&#39;NoMatch&#39;), Choice(&#39;OwnNew&#39;), Choice(&#39;Owned&#39;), Choice(&#39;Accepted&#39;), Choice(&#39;Declined&#39;), Choice(&#39;Max&#39;)
    }, is_read_only=True)
    delegator = CharField(field_uri=&#39;task:Delegator&#39;, is_read_only=True)
    due_date = DateTimeBackedDateField(field_uri=&#39;task:DueDate&#39;)
    is_editable = BooleanField(field_uri=&#39;task:IsAssignmentEditable&#39;, is_read_only=True)
    is_complete = BooleanField(field_uri=&#39;task:IsComplete&#39;, is_read_only=True)
    is_recurring = BooleanField(field_uri=&#39;task:IsRecurring&#39;, is_read_only=True)
    is_team_task = BooleanField(field_uri=&#39;task:IsTeamTask&#39;, is_read_only=True)
    mileage = TextField(field_uri=&#39;task:Mileage&#39;)
    owner = CharField(field_uri=&#39;task:Owner&#39;, is_read_only=True)
    percent_complete = DecimalField(field_uri=&#39;task:PercentComplete&#39;, is_required=True, default=Decimal(0.0),
                                    min=Decimal(0), max=Decimal(100), is_searchable=False)
    recurrence = TaskRecurrenceField(field_uri=&#39;task:Recurrence&#39;, is_searchable=False)
    start_date = DateTimeBackedDateField(field_uri=&#39;task:StartDate&#39;)
    status = ChoiceField(field_uri=&#39;task:Status&#39;, choices={
        Choice(NOT_STARTED), Choice(&#39;InProgress&#39;), Choice(COMPLETED), Choice(&#39;WaitingOnOthers&#39;), Choice(&#39;Deferred&#39;)
    }, is_required=True, is_searchable=False, default=NOT_STARTED)
    status_description = CharField(field_uri=&#39;task:StatusDescription&#39;, is_read_only=True)
    total_work = IntegerField(field_uri=&#39;task:TotalWork&#39;, min=0)

    def clean(self, version=None):
        super().clean(version=version)
        if self.due_date and self.start_date and self.due_date &lt; self.start_date:
            log.warning(&#34;&#39;due_date&#39; must be greater than &#39;start_date&#39; (%s vs %s). Resetting &#39;due_date&#39;&#34;,
                        self.due_date, self.start_date)
            self.due_date = self.start_date
        if self.complete_date:
            if self.status != self.COMPLETED:
                log.warning(&#34;&#39;status&#39; must be &#39;%s&#39; when &#39;complete_date&#39; is set (%s). Resetting&#34;,
                            self.COMPLETED, self.status)
                self.status = self.COMPLETED
            now = datetime.datetime.now(tz=UTC)
            if (self.complete_date - now).total_seconds() &gt; 120:
                # Reset complete_date values that are in the future
                # &#39;complete_date&#39; can be set automatically by the server. Allow some grace between local and server time
                log.warning(&#34;&#39;complete_date&#39; must be in the past (%s vs %s). Resetting&#34;, self.complete_date, now)
                self.complete_date = now
            if self.start_date and self.complete_date.date() &lt; self.start_date:
                log.warning(&#34;&#39;complete_date&#39; must be greater than &#39;start_date&#39; (%s vs %s). Resetting&#34;,
                            self.complete_date, self.start_date)
                self.complete_date = EWSDateTime.combine(self.start_date, datetime.time(0, 0)).replace(tzinfo=UTC)
        if self.percent_complete is not None:
            if self.status == self.COMPLETED and self.percent_complete != Decimal(100):
                # percent_complete must be 100% if task is complete
                log.warning(&#34;&#39;percent_complete&#39; must be 100 when &#39;status&#39; is &#39;%s&#39; (%s). Resetting&#34;,
                            self.COMPLETED, self.percent_complete)
                self.percent_complete = Decimal(100)
            elif self.status == self.NOT_STARTED and self.percent_complete != Decimal(0):
                # percent_complete must be 0% if task is not started
                log.warning(&#34;&#39;percent_complete&#39; must be 0 when &#39;status&#39; is &#39;%s&#39; (%s). Resetting&#34;,
                            self.NOT_STARTED, self.percent_complete)
                self.percent_complete = Decimal(0)

    def complete(self):
        # A helper method to mark a task as complete on the server
        self.status = Task.COMPLETED
        self.percent_complete = Decimal(100)
        self.save()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.Task.COMPLETED"><code class="name">var <span class="ident">COMPLETED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.FIELDS"><code class="name">var <span class="ident">FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.NOT_STARTED"><code class="name">var <span class="ident">NOT_STARTED</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Task.actual_work"><code class="name">var <span class="ident">actual_work</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.assigned_time"><code class="name">var <span class="ident">assigned_time</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.billing_information"><code class="name">var <span class="ident">billing_information</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.change_count"><code class="name">var <span class="ident">change_count</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.companies"><code class="name">var <span class="ident">companies</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.complete_date"><code class="name">var <span class="ident">complete_date</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.contacts"><code class="name">var <span class="ident">contacts</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.delegation_state"><code class="name">var <span class="ident">delegation_state</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.delegator"><code class="name">var <span class="ident">delegator</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.due_date"><code class="name">var <span class="ident">due_date</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.is_complete"><code class="name">var <span class="ident">is_complete</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.is_editable"><code class="name">var <span class="ident">is_editable</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.is_recurring"><code class="name">var <span class="ident">is_recurring</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.is_team_task"><code class="name">var <span class="ident">is_team_task</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.mileage"><code class="name">var <span class="ident">mileage</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.owner"><code class="name">var <span class="ident">owner</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.percent_complete"><code class="name">var <span class="ident">percent_complete</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.recurrence"><code class="name">var <span class="ident">recurrence</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.start_date"><code class="name">var <span class="ident">start_date</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.status"><code class="name">var <span class="ident">status</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.status_description"><code class="name">var <span class="ident">status_description</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.Task.total_work"><code class="name">var <span class="ident">total_work</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.Task.clean"><code class="name flex">
<span>def <span class="ident">clean</span></span>(<span>self, version=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean(self, version=None):
    super().clean(version=version)
    if self.due_date and self.start_date and self.due_date &lt; self.start_date:
        log.warning(&#34;&#39;due_date&#39; must be greater than &#39;start_date&#39; (%s vs %s). Resetting &#39;due_date&#39;&#34;,
                    self.due_date, self.start_date)
        self.due_date = self.start_date
    if self.complete_date:
        if self.status != self.COMPLETED:
            log.warning(&#34;&#39;status&#39; must be &#39;%s&#39; when &#39;complete_date&#39; is set (%s). Resetting&#34;,
                        self.COMPLETED, self.status)
            self.status = self.COMPLETED
        now = datetime.datetime.now(tz=UTC)
        if (self.complete_date - now).total_seconds() &gt; 120:
            # Reset complete_date values that are in the future
            # &#39;complete_date&#39; can be set automatically by the server. Allow some grace between local and server time
            log.warning(&#34;&#39;complete_date&#39; must be in the past (%s vs %s). Resetting&#34;, self.complete_date, now)
            self.complete_date = now
        if self.start_date and self.complete_date.date() &lt; self.start_date:
            log.warning(&#34;&#39;complete_date&#39; must be greater than &#39;start_date&#39; (%s vs %s). Resetting&#34;,
                        self.complete_date, self.start_date)
            self.complete_date = EWSDateTime.combine(self.start_date, datetime.time(0, 0)).replace(tzinfo=UTC)
    if self.percent_complete is not None:
        if self.status == self.COMPLETED and self.percent_complete != Decimal(100):
            # percent_complete must be 100% if task is complete
            log.warning(&#34;&#39;percent_complete&#39; must be 100 when &#39;status&#39; is &#39;%s&#39; (%s). Resetting&#34;,
                        self.COMPLETED, self.percent_complete)
            self.percent_complete = Decimal(100)
        elif self.status == self.NOT_STARTED and self.percent_complete != Decimal(0):
            # percent_complete must be 0% if task is not started
            log.warning(&#34;&#39;percent_complete&#39; must be 0 when &#39;status&#39; is &#39;%s&#39; (%s). Resetting&#34;,
                        self.NOT_STARTED, self.percent_complete)
            self.percent_complete = Decimal(0)</code></pre>
</details>
</dd>
<dt id="exchangelib.Task.complete"><code class="name flex">
<span>def <span class="ident">complete</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def complete(self):
    # A helper method to mark a task as complete on the server
    self.status = Task.COMPLETED
    self.percent_complete = Decimal(100)
    self.save()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.item.Item" href="items/item.html#exchangelib.items.item.Item">Item</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.item.Item.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.item.Item.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.item.Item.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.attach" href="items/item.html#exchangelib.items.item.Item.attach">attach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.item.Item.detach" href="items/item.html#exchangelib.items.item.Item.detach">detach</a></code></li>
<li><code><a title="exchangelib.items.item.Item.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.item.Item.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.item.Item.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.item.Item.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.item.Item.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.TentativelyAcceptItem"><code class="flex name class">
<span>class <span class="ident">TentativelyAcceptItem</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>MSDN: <a href="https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/tentativelyacceptitem">https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/tentativelyacceptitem</a></p>
<p>Pick out optional 'account' and 'folder' kwargs, and pass the rest to the parent class.</p>
<p>:param kwargs:
'account' is optional but allows calling 'send()' and 'delete()'
'folder' is optional but allows calling 'save()'. If 'folder' has an account, and 'account' is not set,
we use folder.account.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TentativelyAcceptItem(BaseMeetingReplyItem):
    &#34;&#34;&#34;MSDN: https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/tentativelyacceptitem&#34;&#34;&#34;

    ELEMENT_NAME = &#39;TentativelyAcceptItem&#39;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem" href="items/calendar_item.html#exchangelib.items.calendar_item.BaseMeetingReplyItem">BaseMeetingReplyItem</a></li>
<li><a title="exchangelib.items.base.BaseItem" href="items/base.html#exchangelib.items.base.BaseItem">BaseItem</a></li>
<li><a title="exchangelib.items.base.RegisterMixIn" href="items/base.html#exchangelib.items.base.RegisterMixIn">RegisterMixIn</a></li>
<li><a title="exchangelib.properties.IdChangeKeyMixIn" href="properties.html#exchangelib.properties.IdChangeKeyMixIn">IdChangeKeyMixIn</a></li>
<li><a title="exchangelib.properties.EWSElement" href="properties.html#exchangelib.properties.EWSElement">EWSElement</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.TentativelyAcceptItem.ELEMENT_NAME"><code class="name">var <span class="ident">ELEMENT_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem" href="items/calendar_item.html#exchangelib.items.calendar_item.BaseMeetingReplyItem">BaseMeetingReplyItem</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.ID_ELEMENT_CLS" href="items/base.html#exchangelib.items.base.BaseItem.ID_ELEMENT_CLS">ID_ELEMENT_CLS</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.account" href="items/base.html#exchangelib.items.base.BaseItem.account">account</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.add_field" href="properties.html#exchangelib.properties.EWSElement.add_field">add_field</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.deregister" href="items/base.html#exchangelib.items.base.RegisterMixIn.deregister">deregister</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.folder" href="items/base.html#exchangelib.items.base.BaseItem.folder">folder</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.register" href="items/base.html#exchangelib.items.base.RegisterMixIn.register">register</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.remove_field" href="properties.html#exchangelib.properties.EWSElement.remove_field">remove_field</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.supported_fields" href="properties.html#exchangelib.properties.EWSElement.supported_fields">supported_fields</a></code></li>
<li><code><a title="exchangelib.items.calendar_item.BaseMeetingReplyItem.validate_field" href="properties.html#exchangelib.properties.EWSElement.validate_field">validate_field</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.UID"><code class="flex name class">
<span>class <span class="ident">UID</span></span>
<span>(</span><span>uid)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class to encode Calendar UIDs. See issue #453. Example:</p>
<p>class GlobalObjectId(ExtendedProperty):
distinguished_property_set_id = 'Meeting'
property_id = 3
property_type = 'Binary'</p>
<p>CalendarItem.register('global_object_id', GlobalObjectId)
account.calendar.filter(global_object_id=UID('261cbc18-1f65-5a0a-bd11-23b1e224cc2f'))</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UID(bytes):
    &#34;&#34;&#34;Helper class to encode Calendar UIDs. See issue #453. Example:

    class GlobalObjectId(ExtendedProperty):
        distinguished_property_set_id = &#39;Meeting&#39;
        property_id = 3
        property_type = &#39;Binary&#39;

    CalendarItem.register(&#39;global_object_id&#39;, GlobalObjectId)
    account.calendar.filter(global_object_id=UID(&#39;261cbc18-1f65-5a0a-bd11-23b1e224cc2f&#39;))
    &#34;&#34;&#34;

    _HEADER = binascii.hexlify(bytearray((
        0x04, 0x00, 0x00, 0x00,
        0x82, 0x00, 0xE0, 0x00,
        0x74, 0xC5, 0xB7, 0x10,
        0x1A, 0x82, 0xE0, 0x08)))

    _EXCEPTION_REPLACEMENT_TIME = binascii.hexlify(bytearray((
        0, 0, 0, 0)))

    _CREATION_TIME = binascii.hexlify(bytearray((
        0, 0, 0, 0,
        0, 0, 0, 0)))

    _RESERVED = binascii.hexlify(bytearray((
        0, 0, 0, 0,
        0, 0, 0, 0)))

    # https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-oxocal/1d3aac05-a7b9-45cc-a213-47f0a0a2c5c1
    # https://docs.microsoft.com/en-us/openspecs/exchange_server_protocols/ms-asemail/e7424ddc-dd10-431e-a0b7-5c794863370e
    # https://stackoverflow.com/questions/42259122
    # https://stackoverflow.com/questions/33757805

    def __new__(cls, uid):
        payload = binascii.hexlify(bytearray(&#39;vCal-Uid\x01\x00\x00\x00{}\x00&#39;.format(uid).encode(&#39;ascii&#39;)))
        length = binascii.hexlify(bytearray(struct.pack(&#39;&lt;I&#39;, int(len(payload)/2))))
        encoding = b&#39;&#39;.join([
            cls._HEADER, cls._EXCEPTION_REPLACEMENT_TIME, cls._CREATION_TIME, cls._RESERVED, length, payload
        ])
        return super().__new__(cls, codecs.decode(encoding, &#39;hex&#39;))

    @classmethod
    def to_global_object_id(cls, uid):
        &#34;&#34;&#34;Converts a UID as returned by EWS to GlobalObjectId format&#34;&#34;&#34;
        return binascii.unhexlify(uid)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.bytes</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.UID.to_global_object_id"><code class="name flex">
<span>def <span class="ident">to_global_object_id</span></span>(<span>uid)</span>
</code></dt>
<dd>
<div class="desc"><p>Converts a UID as returned by EWS to GlobalObjectId format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def to_global_object_id(cls, uid):
    &#34;&#34;&#34;Converts a UID as returned by EWS to GlobalObjectId format&#34;&#34;&#34;
    return binascii.unhexlify(uid)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="exchangelib.Version"><code class="flex name class">
<span>class <span class="ident">Version</span></span>
<span>(</span><span>build, api_version=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Holds information about the server version.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Version:
    &#34;&#34;&#34;Holds information about the server version.&#34;&#34;&#34;

    __slots__ = &#39;build&#39;, &#39;api_version&#39;

    def __init__(self, build, api_version=None):
        if not isinstance(build, (Build, type(None))):
            raise ValueError(&#34;&#39;build&#39; must be a Build instance&#34;)
        self.build = build
        if api_version is None:
            self.api_version = build.api_version()
        else:
            if not isinstance(api_version, str):
                raise ValueError(&#34;&#39;api_version&#39; must be a string&#34;)
            self.api_version = api_version

    @property
    def fullname(self):
        return VERSIONS[self.api_version][1]

    @classmethod
    def guess(cls, protocol, api_version_hint=None):
        &#34;&#34;&#34;Ask the server which version it has. We haven&#39;t set up an Account object yet, so we generate requests
        by hand. We only need a response header containing a ServerVersionInfo element.

        To get API version and build numbers from the server, we need to send a valid SOAP request. We can&#39;t do that
        without a valid API version. To solve this chicken-and-egg problem, we try all possible API versions that this
        package supports, until we get a valid response.

        :param protocol:
        :param api_version_hint:  (Default value = None)
        &#34;&#34;&#34;
        from .services import ResolveNames
        # The protocol doesn&#39;t have a version yet, so default to latest supported version if we don&#39;t have a hint.
        api_version = api_version_hint or API_VERSIONS[0]
        log.debug(&#39;Asking server for version info using API version %s&#39;, api_version)
        # We don&#39;t know the build version yet. Hopefully, the server will report it in the SOAP header. Lots of
        # places expect a version to have a build, so this is a bit dangerous, but passing a fake build around is also
        # dangerous. Make sure the call to ResolveNames does not require a version build.
        protocol.config.version = Version(build=None, api_version=api_version)
        # Use ResolveNames as a minimal request to the server to test if the version is correct. If not, ResolveNames
        # will try to guess the version automatically.
        name = str(protocol.credentials) if protocol.credentials and str(protocol.credentials) else &#39;DUMMY&#39;
        try:
            list(ResolveNames(protocol=protocol).call(unresolved_entries=[name]))
        except ResponseMessageError as e:
            # We may have survived long enough to get a new version
            if not protocol.config.version.build:
                raise TransportError(&#39;No valid version headers found in response (%r)&#39; % e)
        if not protocol.config.version.build:
            raise TransportError(&#39;No valid version headers found in response&#39;)
        return protocol.version

    @staticmethod
    def _is_invalid_version_string(version):
        # Check if a version string is bogus, e.g. V2_, V2015_ or V2018_
        return re.match(r&#39;V[0-9]{1,4}_.*&#39;, version)

    @classmethod
    def from_soap_header(cls, requested_api_version, header):
        info = header.find(&#39;{%s}ServerVersionInfo&#39; % TNS)
        if info is None:
            raise TransportError(&#39;No ServerVersionInfo in header: %r&#39; % xml_to_str(header))
        try:
            build = Build.from_xml(elem=info)
        except ValueError:
            raise TransportError(&#39;Bad ServerVersionInfo in response: %r&#39; % xml_to_str(header))
        # Not all Exchange servers send the Version element
        api_version_from_server = info.get(&#39;Version&#39;) or build.api_version()
        if api_version_from_server != requested_api_version:
            if cls._is_invalid_version_string(api_version_from_server):
                # For unknown reasons, Office 365 may respond with an API version strings that is invalid in a request.
                # Detect these so we can fallback to a valid version string.
                log.debug(&#39;API version &#34;%s&#34; worked but server reports version &#34;%s&#34;. Using &#34;%s&#34;&#39;, requested_api_version,
                          api_version_from_server, requested_api_version)
                api_version_from_server = requested_api_version
            else:
                # Trust API version from server response
                log.debug(&#39;API version &#34;%s&#34; worked but server reports version &#34;%s&#34;. Using &#34;%s&#34;&#39;, requested_api_version,
                          api_version_from_server, api_version_from_server)
        return cls(build=build, api_version=api_version_from_server)

    def __eq__(self, other):
        if self.api_version != other.api_version:
            return False
        if self.build and not other.build:
            return False
        if other.build and not self.build:
            return False
        return self.build == other.build

    def __repr__(self):
        return self.__class__.__name__ + repr((self.build, self.api_version))

    def __str__(self):
        return &#39;Build=%s, API=%s, Fullname=%s&#39; % (self.build, self.api_version, self.fullname)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="exchangelib.Version.from_soap_header"><code class="name flex">
<span>def <span class="ident">from_soap_header</span></span>(<span>requested_api_version, header)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def from_soap_header(cls, requested_api_version, header):
    info = header.find(&#39;{%s}ServerVersionInfo&#39; % TNS)
    if info is None:
        raise TransportError(&#39;No ServerVersionInfo in header: %r&#39; % xml_to_str(header))
    try:
        build = Build.from_xml(elem=info)
    except ValueError:
        raise TransportError(&#39;Bad ServerVersionInfo in response: %r&#39; % xml_to_str(header))
    # Not all Exchange servers send the Version element
    api_version_from_server = info.get(&#39;Version&#39;) or build.api_version()
    if api_version_from_server != requested_api_version:
        if cls._is_invalid_version_string(api_version_from_server):
            # For unknown reasons, Office 365 may respond with an API version strings that is invalid in a request.
            # Detect these so we can fallback to a valid version string.
            log.debug(&#39;API version &#34;%s&#34; worked but server reports version &#34;%s&#34;. Using &#34;%s&#34;&#39;, requested_api_version,
                      api_version_from_server, requested_api_version)
            api_version_from_server = requested_api_version
        else:
            # Trust API version from server response
            log.debug(&#39;API version &#34;%s&#34; worked but server reports version &#34;%s&#34;. Using &#34;%s&#34;&#39;, requested_api_version,
                      api_version_from_server, api_version_from_server)
    return cls(build=build, api_version=api_version_from_server)</code></pre>
</details>
</dd>
<dt id="exchangelib.Version.guess"><code class="name flex">
<span>def <span class="ident">guess</span></span>(<span>protocol, api_version_hint=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Ask the server which version it has. We haven't set up an Account object yet, so we generate requests
by hand. We only need a response header containing a ServerVersionInfo element.</p>
<p>To get API version and build numbers from the server, we need to send a valid SOAP request. We can't do that
without a valid API version. To solve this chicken-and-egg problem, we try all possible API versions that this
package supports, until we get a valid response.</p>
<p>:param protocol:
:param api_version_hint:
(Default value = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def guess(cls, protocol, api_version_hint=None):
    &#34;&#34;&#34;Ask the server which version it has. We haven&#39;t set up an Account object yet, so we generate requests
    by hand. We only need a response header containing a ServerVersionInfo element.

    To get API version and build numbers from the server, we need to send a valid SOAP request. We can&#39;t do that
    without a valid API version. To solve this chicken-and-egg problem, we try all possible API versions that this
    package supports, until we get a valid response.

    :param protocol:
    :param api_version_hint:  (Default value = None)
    &#34;&#34;&#34;
    from .services import ResolveNames
    # The protocol doesn&#39;t have a version yet, so default to latest supported version if we don&#39;t have a hint.
    api_version = api_version_hint or API_VERSIONS[0]
    log.debug(&#39;Asking server for version info using API version %s&#39;, api_version)
    # We don&#39;t know the build version yet. Hopefully, the server will report it in the SOAP header. Lots of
    # places expect a version to have a build, so this is a bit dangerous, but passing a fake build around is also
    # dangerous. Make sure the call to ResolveNames does not require a version build.
    protocol.config.version = Version(build=None, api_version=api_version)
    # Use ResolveNames as a minimal request to the server to test if the version is correct. If not, ResolveNames
    # will try to guess the version automatically.
    name = str(protocol.credentials) if protocol.credentials and str(protocol.credentials) else &#39;DUMMY&#39;
    try:
        list(ResolveNames(protocol=protocol).call(unresolved_entries=[name]))
    except ResponseMessageError as e:
        # We may have survived long enough to get a new version
        if not protocol.config.version.build:
            raise TransportError(&#39;No valid version headers found in response (%r)&#39; % e)
    if not protocol.config.version.build:
        raise TransportError(&#39;No valid version headers found in response&#39;)
    return protocol.version</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.Version.api_version"><code class="name">var <span class="ident">api_version</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Version.build"><code class="name">var <span class="ident">build</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="exchangelib.Version.fullname"><code class="name">var <span class="ident">fullname</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def fullname(self):
    return VERSIONS[self.api_version][1]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="exchangelib.account" href="account.html">exchangelib.account</a></code></li>
<li><code><a title="exchangelib.attachments" href="attachments.html">exchangelib.attachments</a></code></li>
<li><code><a title="exchangelib.autodiscover" href="autodiscover/index.html">exchangelib.autodiscover</a></code></li>
<li><code><a title="exchangelib.configuration" href="configuration.html">exchangelib.configuration</a></code></li>
<li><code><a title="exchangelib.credentials" href="credentials.html">exchangelib.credentials</a></code></li>
<li><code><a title="exchangelib.errors" href="errors.html">exchangelib.errors</a></code></li>
<li><code><a title="exchangelib.ewsdatetime" href="ewsdatetime.html">exchangelib.ewsdatetime</a></code></li>
<li><code><a title="exchangelib.extended_properties" href="extended_properties.html">exchangelib.extended_properties</a></code></li>
<li><code><a title="exchangelib.fields" href="fields.html">exchangelib.fields</a></code></li>
<li><code><a title="exchangelib.folders" href="folders/index.html">exchangelib.folders</a></code></li>
<li><code><a title="exchangelib.indexed_properties" href="indexed_properties.html">exchangelib.indexed_properties</a></code></li>
<li><code><a title="exchangelib.items" href="items/index.html">exchangelib.items</a></code></li>
<li><code><a title="exchangelib.properties" href="properties.html">exchangelib.properties</a></code></li>
<li><code><a title="exchangelib.protocol" href="protocol.html">exchangelib.protocol</a></code></li>
<li><code><a title="exchangelib.queryset" href="queryset.html">exchangelib.queryset</a></code></li>
<li><code><a title="exchangelib.recurrence" href="recurrence.html">exchangelib.recurrence</a></code></li>
<li><code><a title="exchangelib.restriction" href="restriction.html">exchangelib.restriction</a></code></li>
<li><code><a title="exchangelib.services" href="services/index.html">exchangelib.services</a></code></li>
<li><code><a title="exchangelib.settings" href="settings.html">exchangelib.settings</a></code></li>
<li><code><a title="exchangelib.transport" href="transport.html">exchangelib.transport</a></code></li>
<li><code><a title="exchangelib.util" href="util.html">exchangelib.util</a></code></li>
<li><code><a title="exchangelib.version" href="version.html">exchangelib.version</a></code></li>
<li><code><a title="exchangelib.winzone" href="winzone.html">exchangelib.winzone</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="exchangelib.UTC_NOW" href="#exchangelib.UTC_NOW">UTC_NOW</a></code></li>
<li><code><a title="exchangelib.discover" href="#exchangelib.discover">discover</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exchangelib.AcceptItem" href="#exchangelib.AcceptItem">AcceptItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.AcceptItem.ELEMENT_NAME" href="#exchangelib.AcceptItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Account" href="#exchangelib.Account">Account</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Account.admin_audit_logs" href="#exchangelib.Account.admin_audit_logs">admin_audit_logs</a></code></li>
<li><code><a title="exchangelib.Account.archive_deleted_items" href="#exchangelib.Account.archive_deleted_items">archive_deleted_items</a></code></li>
<li><code><a title="exchangelib.Account.archive_inbox" href="#exchangelib.Account.archive_inbox">archive_inbox</a></code></li>
<li><code><a title="exchangelib.Account.archive_msg_folder_root" href="#exchangelib.Account.archive_msg_folder_root">archive_msg_folder_root</a></code></li>
<li><code><a title="exchangelib.Account.archive_recoverable_items_deletions" href="#exchangelib.Account.archive_recoverable_items_deletions">archive_recoverable_items_deletions</a></code></li>
<li><code><a title="exchangelib.Account.archive_recoverable_items_purges" href="#exchangelib.Account.archive_recoverable_items_purges">archive_recoverable_items_purges</a></code></li>
<li><code><a title="exchangelib.Account.archive_recoverable_items_root" href="#exchangelib.Account.archive_recoverable_items_root">archive_recoverable_items_root</a></code></li>
<li><code><a title="exchangelib.Account.archive_recoverable_items_versions" href="#exchangelib.Account.archive_recoverable_items_versions">archive_recoverable_items_versions</a></code></li>
<li><code><a title="exchangelib.Account.archive_root" href="#exchangelib.Account.archive_root">archive_root</a></code></li>
<li><code><a title="exchangelib.Account.bulk_archive" href="#exchangelib.Account.bulk_archive">bulk_archive</a></code></li>
<li><code><a title="exchangelib.Account.bulk_copy" href="#exchangelib.Account.bulk_copy">bulk_copy</a></code></li>
<li><code><a title="exchangelib.Account.bulk_create" href="#exchangelib.Account.bulk_create">bulk_create</a></code></li>
<li><code><a title="exchangelib.Account.bulk_delete" href="#exchangelib.Account.bulk_delete">bulk_delete</a></code></li>
<li><code><a title="exchangelib.Account.bulk_mark_as_junk" href="#exchangelib.Account.bulk_mark_as_junk">bulk_mark_as_junk</a></code></li>
<li><code><a title="exchangelib.Account.bulk_move" href="#exchangelib.Account.bulk_move">bulk_move</a></code></li>
<li><code><a title="exchangelib.Account.bulk_send" href="#exchangelib.Account.bulk_send">bulk_send</a></code></li>
<li><code><a title="exchangelib.Account.bulk_update" href="#exchangelib.Account.bulk_update">bulk_update</a></code></li>
<li><code><a title="exchangelib.Account.calendar" href="#exchangelib.Account.calendar">calendar</a></code></li>
<li><code><a title="exchangelib.Account.conflicts" href="#exchangelib.Account.conflicts">conflicts</a></code></li>
<li><code><a title="exchangelib.Account.contacts" href="#exchangelib.Account.contacts">contacts</a></code></li>
<li><code><a title="exchangelib.Account.conversation_history" href="#exchangelib.Account.conversation_history">conversation_history</a></code></li>
<li><code><a title="exchangelib.Account.delegates" href="#exchangelib.Account.delegates">delegates</a></code></li>
<li><code><a title="exchangelib.Account.directory" href="#exchangelib.Account.directory">directory</a></code></li>
<li><code><a title="exchangelib.Account.domain" href="#exchangelib.Account.domain">domain</a></code></li>
<li><code><a title="exchangelib.Account.drafts" href="#exchangelib.Account.drafts">drafts</a></code></li>
<li><code><a title="exchangelib.Account.export" href="#exchangelib.Account.export">export</a></code></li>
<li><code><a title="exchangelib.Account.favorites" href="#exchangelib.Account.favorites">favorites</a></code></li>
<li><code><a title="exchangelib.Account.fetch" href="#exchangelib.Account.fetch">fetch</a></code></li>
<li><code><a title="exchangelib.Account.fetch_personas" href="#exchangelib.Account.fetch_personas">fetch_personas</a></code></li>
<li><code><a title="exchangelib.Account.im_contact_list" href="#exchangelib.Account.im_contact_list">im_contact_list</a></code></li>
<li><code><a title="exchangelib.Account.inbox" href="#exchangelib.Account.inbox">inbox</a></code></li>
<li><code><a title="exchangelib.Account.journal" href="#exchangelib.Account.journal">journal</a></code></li>
<li><code><a title="exchangelib.Account.junk" href="#exchangelib.Account.junk">junk</a></code></li>
<li><code><a title="exchangelib.Account.local_failures" href="#exchangelib.Account.local_failures">local_failures</a></code></li>
<li><code><a title="exchangelib.Account.mail_tips" href="#exchangelib.Account.mail_tips">mail_tips</a></code></li>
<li><code><a title="exchangelib.Account.msg_folder_root" href="#exchangelib.Account.msg_folder_root">msg_folder_root</a></code></li>
<li><code><a title="exchangelib.Account.my_contacts" href="#exchangelib.Account.my_contacts">my_contacts</a></code></li>
<li><code><a title="exchangelib.Account.notes" href="#exchangelib.Account.notes">notes</a></code></li>
<li><code><a title="exchangelib.Account.oof_settings" href="#exchangelib.Account.oof_settings">oof_settings</a></code></li>
<li><code><a title="exchangelib.Account.outbox" href="#exchangelib.Account.outbox">outbox</a></code></li>
<li><code><a title="exchangelib.Account.people_connect" href="#exchangelib.Account.people_connect">people_connect</a></code></li>
<li><code><a title="exchangelib.Account.primary_smtp_address" href="#exchangelib.Account.primary_smtp_address">primary_smtp_address</a></code></li>
<li><code><a title="exchangelib.Account.public_folders_root" href="#exchangelib.Account.public_folders_root">public_folders_root</a></code></li>
<li><code><a title="exchangelib.Account.quick_contacts" href="#exchangelib.Account.quick_contacts">quick_contacts</a></code></li>
<li><code><a title="exchangelib.Account.recipient_cache" href="#exchangelib.Account.recipient_cache">recipient_cache</a></code></li>
<li><code><a title="exchangelib.Account.recoverable_items_deletions" href="#exchangelib.Account.recoverable_items_deletions">recoverable_items_deletions</a></code></li>
<li><code><a title="exchangelib.Account.recoverable_items_purges" href="#exchangelib.Account.recoverable_items_purges">recoverable_items_purges</a></code></li>
<li><code><a title="exchangelib.Account.recoverable_items_root" href="#exchangelib.Account.recoverable_items_root">recoverable_items_root</a></code></li>
<li><code><a title="exchangelib.Account.recoverable_items_versions" href="#exchangelib.Account.recoverable_items_versions">recoverable_items_versions</a></code></li>
<li><code><a title="exchangelib.Account.root" href="#exchangelib.Account.root">root</a></code></li>
<li><code><a title="exchangelib.Account.search_folders" href="#exchangelib.Account.search_folders">search_folders</a></code></li>
<li><code><a title="exchangelib.Account.sent" href="#exchangelib.Account.sent">sent</a></code></li>
<li><code><a title="exchangelib.Account.server_failures" href="#exchangelib.Account.server_failures">server_failures</a></code></li>
<li><code><a title="exchangelib.Account.sync_issues" href="#exchangelib.Account.sync_issues">sync_issues</a></code></li>
<li><code><a title="exchangelib.Account.tasks" href="#exchangelib.Account.tasks">tasks</a></code></li>
<li><code><a title="exchangelib.Account.todo_search" href="#exchangelib.Account.todo_search">todo_search</a></code></li>
<li><code><a title="exchangelib.Account.trash" href="#exchangelib.Account.trash">trash</a></code></li>
<li><code><a title="exchangelib.Account.upload" href="#exchangelib.Account.upload">upload</a></code></li>
<li><code><a title="exchangelib.Account.voice_mail" href="#exchangelib.Account.voice_mail">voice_mail</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Attendee" href="#exchangelib.Attendee">Attendee</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.Attendee.ELEMENT_NAME" href="#exchangelib.Attendee.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.Attendee.FIELDS" href="#exchangelib.Attendee.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.Attendee.RESPONSE_TYPES" href="#exchangelib.Attendee.RESPONSE_TYPES">RESPONSE_TYPES</a></code></li>
<li><code><a title="exchangelib.Attendee.last_response_time" href="#exchangelib.Attendee.last_response_time">last_response_time</a></code></li>
<li><code><a title="exchangelib.Attendee.mailbox" href="#exchangelib.Attendee.mailbox">mailbox</a></code></li>
<li><code><a title="exchangelib.Attendee.response_type" href="#exchangelib.Attendee.response_type">response_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.BaseProtocol" href="#exchangelib.BaseProtocol">BaseProtocol</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.BaseProtocol.CONNECTIONS_PER_SESSION" href="#exchangelib.BaseProtocol.CONNECTIONS_PER_SESSION">CONNECTIONS_PER_SESSION</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.HTTP_ADAPTER_CLS" href="#exchangelib.BaseProtocol.HTTP_ADAPTER_CLS">HTTP_ADAPTER_CLS</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.MAX_SESSION_USAGE_COUNT" href="#exchangelib.BaseProtocol.MAX_SESSION_USAGE_COUNT">MAX_SESSION_USAGE_COUNT</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.SESSION_POOLSIZE" href="#exchangelib.BaseProtocol.SESSION_POOLSIZE">SESSION_POOLSIZE</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.TIMEOUT" href="#exchangelib.BaseProtocol.TIMEOUT">TIMEOUT</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.USERAGENT" href="#exchangelib.BaseProtocol.USERAGENT">USERAGENT</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.auth_type" href="#exchangelib.BaseProtocol.auth_type">auth_type</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.close" href="#exchangelib.BaseProtocol.close">close</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.close_session" href="#exchangelib.BaseProtocol.close_session">close_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.create_oauth2_session" href="#exchangelib.BaseProtocol.create_oauth2_session">create_oauth2_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.create_session" href="#exchangelib.BaseProtocol.create_session">create_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.credentials" href="#exchangelib.BaseProtocol.credentials">credentials</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.decrease_poolsize" href="#exchangelib.BaseProtocol.decrease_poolsize">decrease_poolsize</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.get_adapter" href="#exchangelib.BaseProtocol.get_adapter">get_adapter</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.get_session" href="#exchangelib.BaseProtocol.get_session">get_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.increase_poolsize" href="#exchangelib.BaseProtocol.increase_poolsize">increase_poolsize</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.raw_session" href="#exchangelib.BaseProtocol.raw_session">raw_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.refresh_credentials" href="#exchangelib.BaseProtocol.refresh_credentials">refresh_credentials</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.release_session" href="#exchangelib.BaseProtocol.release_session">release_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.renew_session" href="#exchangelib.BaseProtocol.renew_session">renew_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.retire_session" href="#exchangelib.BaseProtocol.retire_session">retire_session</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.retry_policy" href="#exchangelib.BaseProtocol.retry_policy">retry_policy</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.server" href="#exchangelib.BaseProtocol.server">server</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.service_endpoint" href="#exchangelib.BaseProtocol.service_endpoint">service_endpoint</a></code></li>
<li><code><a title="exchangelib.BaseProtocol.session_pool_size" href="#exchangelib.BaseProtocol.session_pool_size">session_pool_size</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Body" href="#exchangelib.Body">Body</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Body.body_type" href="#exchangelib.Body.body_type">body_type</a></code></li>
<li><code><a title="exchangelib.Body.format" href="#exchangelib.Body.format">format</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Build" href="#exchangelib.Build">Build</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.Build.API_VERSION_MAP" href="#exchangelib.Build.API_VERSION_MAP">API_VERSION_MAP</a></code></li>
<li><code><a title="exchangelib.Build.api_version" href="#exchangelib.Build.api_version">api_version</a></code></li>
<li><code><a title="exchangelib.Build.from_hex_string" href="#exchangelib.Build.from_hex_string">from_hex_string</a></code></li>
<li><code><a title="exchangelib.Build.from_xml" href="#exchangelib.Build.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.Build.fullname" href="#exchangelib.Build.fullname">fullname</a></code></li>
<li><code><a title="exchangelib.Build.major_build" href="#exchangelib.Build.major_build">major_build</a></code></li>
<li><code><a title="exchangelib.Build.major_version" href="#exchangelib.Build.major_version">major_version</a></code></li>
<li><code><a title="exchangelib.Build.minor_build" href="#exchangelib.Build.minor_build">minor_build</a></code></li>
<li><code><a title="exchangelib.Build.minor_version" href="#exchangelib.Build.minor_version">minor_version</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.CalendarItem" href="#exchangelib.CalendarItem">CalendarItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.CalendarItem.ELEMENT_NAME" href="#exchangelib.CalendarItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.CalendarItem.FIELDS" href="#exchangelib.CalendarItem.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.CalendarItem.adjacent_meeting_count" href="#exchangelib.CalendarItem.adjacent_meeting_count">adjacent_meeting_count</a></code></li>
<li><code><a title="exchangelib.CalendarItem.adjacent_meetings" href="#exchangelib.CalendarItem.adjacent_meetings">adjacent_meetings</a></code></li>
<li><code><a title="exchangelib.CalendarItem.allow_new_time_proposal" href="#exchangelib.CalendarItem.allow_new_time_proposal">allow_new_time_proposal</a></code></li>
<li><code><a title="exchangelib.CalendarItem.appointment_reply_time" href="#exchangelib.CalendarItem.appointment_reply_time">appointment_reply_time</a></code></li>
<li><code><a title="exchangelib.CalendarItem.appointment_sequence_number" href="#exchangelib.CalendarItem.appointment_sequence_number">appointment_sequence_number</a></code></li>
<li><code><a title="exchangelib.CalendarItem.appointment_state" href="#exchangelib.CalendarItem.appointment_state">appointment_state</a></code></li>
<li><code><a title="exchangelib.CalendarItem.cancel" href="#exchangelib.CalendarItem.cancel">cancel</a></code></li>
<li><code><a title="exchangelib.CalendarItem.clean" href="#exchangelib.CalendarItem.clean">clean</a></code></li>
<li><code><a title="exchangelib.CalendarItem.clean_timezone_fields" href="#exchangelib.CalendarItem.clean_timezone_fields">clean_timezone_fields</a></code></li>
<li><code><a title="exchangelib.CalendarItem.conference_type" href="#exchangelib.CalendarItem.conference_type">conference_type</a></code></li>
<li><code><a title="exchangelib.CalendarItem.conflicting_meeting_count" href="#exchangelib.CalendarItem.conflicting_meeting_count">conflicting_meeting_count</a></code></li>
<li><code><a title="exchangelib.CalendarItem.conflicting_meetings" href="#exchangelib.CalendarItem.conflicting_meetings">conflicting_meetings</a></code></li>
<li><code><a title="exchangelib.CalendarItem.date_to_datetime" href="#exchangelib.CalendarItem.date_to_datetime">date_to_datetime</a></code></li>
<li><code><a title="exchangelib.CalendarItem.deleted_occurrences" href="#exchangelib.CalendarItem.deleted_occurrences">deleted_occurrences</a></code></li>
<li><code><a title="exchangelib.CalendarItem.duration" href="#exchangelib.CalendarItem.duration">duration</a></code></li>
<li><code><a title="exchangelib.CalendarItem.end" href="#exchangelib.CalendarItem.end">end</a></code></li>
<li><code><a title="exchangelib.CalendarItem.first_occurrence" href="#exchangelib.CalendarItem.first_occurrence">first_occurrence</a></code></li>
<li><code><a title="exchangelib.CalendarItem.from_xml" href="#exchangelib.CalendarItem.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.CalendarItem.is_all_day" href="#exchangelib.CalendarItem.is_all_day">is_all_day</a></code></li>
<li><code><a title="exchangelib.CalendarItem.is_cancelled" href="#exchangelib.CalendarItem.is_cancelled">is_cancelled</a></code></li>
<li><code><a title="exchangelib.CalendarItem.is_meeting" href="#exchangelib.CalendarItem.is_meeting">is_meeting</a></code></li>
<li><code><a title="exchangelib.CalendarItem.is_online_meeting" href="#exchangelib.CalendarItem.is_online_meeting">is_online_meeting</a></code></li>
<li><code><a title="exchangelib.CalendarItem.is_recurring" href="#exchangelib.CalendarItem.is_recurring">is_recurring</a></code></li>
<li><code><a title="exchangelib.CalendarItem.is_response_requested" href="#exchangelib.CalendarItem.is_response_requested">is_response_requested</a></code></li>
<li><code><a title="exchangelib.CalendarItem.last_occurrence" href="#exchangelib.CalendarItem.last_occurrence">last_occurrence</a></code></li>
<li><code><a title="exchangelib.CalendarItem.legacy_free_busy_status" href="#exchangelib.CalendarItem.legacy_free_busy_status">legacy_free_busy_status</a></code></li>
<li><code><a title="exchangelib.CalendarItem.location" href="#exchangelib.CalendarItem.location">location</a></code></li>
<li><code><a title="exchangelib.CalendarItem.meeting_request_was_sent" href="#exchangelib.CalendarItem.meeting_request_was_sent">meeting_request_was_sent</a></code></li>
<li><code><a title="exchangelib.CalendarItem.meeting_workspace_url" href="#exchangelib.CalendarItem.meeting_workspace_url">meeting_workspace_url</a></code></li>
<li><code><a title="exchangelib.CalendarItem.modified_occurrences" href="#exchangelib.CalendarItem.modified_occurrences">modified_occurrences</a></code></li>
<li><code><a title="exchangelib.CalendarItem.my_response_type" href="#exchangelib.CalendarItem.my_response_type">my_response_type</a></code></li>
<li><code><a title="exchangelib.CalendarItem.net_show_url" href="#exchangelib.CalendarItem.net_show_url">net_show_url</a></code></li>
<li><code><a title="exchangelib.CalendarItem.occurrence" href="#exchangelib.CalendarItem.occurrence">occurrence</a></code></li>
<li><code><a title="exchangelib.CalendarItem.optional_attendees" href="#exchangelib.CalendarItem.optional_attendees">optional_attendees</a></code></li>
<li><code><a title="exchangelib.CalendarItem.organizer" href="#exchangelib.CalendarItem.organizer">organizer</a></code></li>
<li><code><a title="exchangelib.CalendarItem.original_start" href="#exchangelib.CalendarItem.original_start">original_start</a></code></li>
<li><code><a title="exchangelib.CalendarItem.recurrence" href="#exchangelib.CalendarItem.recurrence">recurrence</a></code></li>
<li><code><a title="exchangelib.CalendarItem.recurrence_id" href="#exchangelib.CalendarItem.recurrence_id">recurrence_id</a></code></li>
<li><code><a title="exchangelib.CalendarItem.recurring_master" href="#exchangelib.CalendarItem.recurring_master">recurring_master</a></code></li>
<li><code><a title="exchangelib.CalendarItem.required_attendees" href="#exchangelib.CalendarItem.required_attendees">required_attendees</a></code></li>
<li><code><a title="exchangelib.CalendarItem.resources" href="#exchangelib.CalendarItem.resources">resources</a></code></li>
<li><code><a title="exchangelib.CalendarItem.start" href="#exchangelib.CalendarItem.start">start</a></code></li>
<li><code><a title="exchangelib.CalendarItem.timezone_fields" href="#exchangelib.CalendarItem.timezone_fields">timezone_fields</a></code></li>
<li><code><a title="exchangelib.CalendarItem.to_xml" href="#exchangelib.CalendarItem.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.CalendarItem.type" href="#exchangelib.CalendarItem.type">type</a></code></li>
<li><code><a title="exchangelib.CalendarItem.tz_field_for_field_name" href="#exchangelib.CalendarItem.tz_field_for_field_name">tz_field_for_field_name</a></code></li>
<li><code><a title="exchangelib.CalendarItem.uid" href="#exchangelib.CalendarItem.uid">uid</a></code></li>
<li><code><a title="exchangelib.CalendarItem.when" href="#exchangelib.CalendarItem.when">when</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.CancelCalendarItem" href="#exchangelib.CancelCalendarItem">CancelCalendarItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.CancelCalendarItem.ELEMENT_NAME" href="#exchangelib.CancelCalendarItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.CancelCalendarItem.FIELDS" href="#exchangelib.CancelCalendarItem.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.CancelCalendarItem.author_idx" href="#exchangelib.CancelCalendarItem.author_idx">author_idx</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Configuration" href="#exchangelib.Configuration">Configuration</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Configuration.credentials" href="#exchangelib.Configuration.credentials">credentials</a></code></li>
<li><code><a title="exchangelib.Configuration.server" href="#exchangelib.Configuration.server">server</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Contact" href="#exchangelib.Contact">Contact</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Contact.ELEMENT_NAME" href="#exchangelib.Contact.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.Contact.FIELDS" href="#exchangelib.Contact.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.Contact.assistant_name" href="#exchangelib.Contact.assistant_name">assistant_name</a></code></li>
<li><code><a title="exchangelib.Contact.birthday" href="#exchangelib.Contact.birthday">birthday</a></code></li>
<li><code><a title="exchangelib.Contact.business_homepage" href="#exchangelib.Contact.business_homepage">business_homepage</a></code></li>
<li><code><a title="exchangelib.Contact.children" href="#exchangelib.Contact.children">children</a></code></li>
<li><code><a title="exchangelib.Contact.companies" href="#exchangelib.Contact.companies">companies</a></code></li>
<li><code><a title="exchangelib.Contact.company_name" href="#exchangelib.Contact.company_name">company_name</a></code></li>
<li><code><a title="exchangelib.Contact.complete_name" href="#exchangelib.Contact.complete_name">complete_name</a></code></li>
<li><code><a title="exchangelib.Contact.contact_source" href="#exchangelib.Contact.contact_source">contact_source</a></code></li>
<li><code><a title="exchangelib.Contact.department" href="#exchangelib.Contact.department">department</a></code></li>
<li><code><a title="exchangelib.Contact.direct_reports" href="#exchangelib.Contact.direct_reports">direct_reports</a></code></li>
<li><code><a title="exchangelib.Contact.directory_id" href="#exchangelib.Contact.directory_id">directory_id</a></code></li>
<li><code><a title="exchangelib.Contact.display_name" href="#exchangelib.Contact.display_name">display_name</a></code></li>
<li><code><a title="exchangelib.Contact.email_addresses" href="#exchangelib.Contact.email_addresses">email_addresses</a></code></li>
<li><code><a title="exchangelib.Contact.email_alias" href="#exchangelib.Contact.email_alias">email_alias</a></code></li>
<li><code><a title="exchangelib.Contact.file_as" href="#exchangelib.Contact.file_as">file_as</a></code></li>
<li><code><a title="exchangelib.Contact.file_as_mapping" href="#exchangelib.Contact.file_as_mapping">file_as_mapping</a></code></li>
<li><code><a title="exchangelib.Contact.generation" href="#exchangelib.Contact.generation">generation</a></code></li>
<li><code><a title="exchangelib.Contact.given_name" href="#exchangelib.Contact.given_name">given_name</a></code></li>
<li><code><a title="exchangelib.Contact.has_picture" href="#exchangelib.Contact.has_picture">has_picture</a></code></li>
<li><code><a title="exchangelib.Contact.im_addresses" href="#exchangelib.Contact.im_addresses">im_addresses</a></code></li>
<li><code><a title="exchangelib.Contact.initials" href="#exchangelib.Contact.initials">initials</a></code></li>
<li><code><a title="exchangelib.Contact.job_title" href="#exchangelib.Contact.job_title">job_title</a></code></li>
<li><code><a title="exchangelib.Contact.manager" href="#exchangelib.Contact.manager">manager</a></code></li>
<li><code><a title="exchangelib.Contact.manager_mailbox" href="#exchangelib.Contact.manager_mailbox">manager_mailbox</a></code></li>
<li><code><a title="exchangelib.Contact.middle_name" href="#exchangelib.Contact.middle_name">middle_name</a></code></li>
<li><code><a title="exchangelib.Contact.mileage" href="#exchangelib.Contact.mileage">mileage</a></code></li>
<li><code><a title="exchangelib.Contact.ms_exchange_certificate" href="#exchangelib.Contact.ms_exchange_certificate">ms_exchange_certificate</a></code></li>
<li><code><a title="exchangelib.Contact.nickname" href="#exchangelib.Contact.nickname">nickname</a></code></li>
<li><code><a title="exchangelib.Contact.notes" href="#exchangelib.Contact.notes">notes</a></code></li>
<li><code><a title="exchangelib.Contact.office" href="#exchangelib.Contact.office">office</a></code></li>
<li><code><a title="exchangelib.Contact.phone_numbers" href="#exchangelib.Contact.phone_numbers">phone_numbers</a></code></li>
<li><code><a title="exchangelib.Contact.phonetic_first_name" href="#exchangelib.Contact.phonetic_first_name">phonetic_first_name</a></code></li>
<li><code><a title="exchangelib.Contact.phonetic_full_name" href="#exchangelib.Contact.phonetic_full_name">phonetic_full_name</a></code></li>
<li><code><a title="exchangelib.Contact.phonetic_last_name" href="#exchangelib.Contact.phonetic_last_name">phonetic_last_name</a></code></li>
<li><code><a title="exchangelib.Contact.photo" href="#exchangelib.Contact.photo">photo</a></code></li>
<li><code><a title="exchangelib.Contact.physical_addresses" href="#exchangelib.Contact.physical_addresses">physical_addresses</a></code></li>
<li><code><a title="exchangelib.Contact.postal_address_index" href="#exchangelib.Contact.postal_address_index">postal_address_index</a></code></li>
<li><code><a title="exchangelib.Contact.profession" href="#exchangelib.Contact.profession">profession</a></code></li>
<li><code><a title="exchangelib.Contact.spouse_name" href="#exchangelib.Contact.spouse_name">spouse_name</a></code></li>
<li><code><a title="exchangelib.Contact.surname" href="#exchangelib.Contact.surname">surname</a></code></li>
<li><code><a title="exchangelib.Contact.user_smime_certificate" href="#exchangelib.Contact.user_smime_certificate">user_smime_certificate</a></code></li>
<li><code><a title="exchangelib.Contact.wedding_anniversary" href="#exchangelib.Contact.wedding_anniversary">wedding_anniversary</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Credentials" href="#exchangelib.Credentials">Credentials</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Credentials.DOMAIN" href="#exchangelib.Credentials.DOMAIN">DOMAIN</a></code></li>
<li><code><a title="exchangelib.Credentials.EMAIL" href="#exchangelib.Credentials.EMAIL">EMAIL</a></code></li>
<li><code><a title="exchangelib.Credentials.UPN" href="#exchangelib.Credentials.UPN">UPN</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.DLMailbox" href="#exchangelib.DLMailbox">DLMailbox</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.DLMailbox.NAMESPACE" href="#exchangelib.DLMailbox.NAMESPACE">NAMESPACE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.DeclineItem" href="#exchangelib.DeclineItem">DeclineItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.DeclineItem.ELEMENT_NAME" href="#exchangelib.DeclineItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.DistributionList" href="#exchangelib.DistributionList">DistributionList</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.DistributionList.ELEMENT_NAME" href="#exchangelib.DistributionList.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.DistributionList.FIELDS" href="#exchangelib.DistributionList.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.DistributionList.contact_source" href="#exchangelib.DistributionList.contact_source">contact_source</a></code></li>
<li><code><a title="exchangelib.DistributionList.display_name" href="#exchangelib.DistributionList.display_name">display_name</a></code></li>
<li><code><a title="exchangelib.DistributionList.file_as" href="#exchangelib.DistributionList.file_as">file_as</a></code></li>
<li><code><a title="exchangelib.DistributionList.members" href="#exchangelib.DistributionList.members">members</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.EWSDate" href="#exchangelib.EWSDate">EWSDate</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.EWSDate.ewsformat" href="#exchangelib.EWSDate.ewsformat">ewsformat</a></code></li>
<li><code><a title="exchangelib.EWSDate.from_date" href="#exchangelib.EWSDate.from_date">from_date</a></code></li>
<li><code><a title="exchangelib.EWSDate.from_string" href="#exchangelib.EWSDate.from_string">from_string</a></code></li>
<li><code><a title="exchangelib.EWSDate.fromordinal" href="#exchangelib.EWSDate.fromordinal">fromordinal</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.EWSDateTime" href="#exchangelib.EWSDateTime">EWSDateTime</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.EWSDateTime.astimezone" href="#exchangelib.EWSDateTime.astimezone">astimezone</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.date" href="#exchangelib.EWSDateTime.date">date</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.ewsformat" href="#exchangelib.EWSDateTime.ewsformat">ewsformat</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.from_datetime" href="#exchangelib.EWSDateTime.from_datetime">from_datetime</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.from_string" href="#exchangelib.EWSDateTime.from_string">from_string</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.fromtimestamp" href="#exchangelib.EWSDateTime.fromtimestamp">fromtimestamp</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.now" href="#exchangelib.EWSDateTime.now">now</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.utcfromtimestamp" href="#exchangelib.EWSDateTime.utcfromtimestamp">utcfromtimestamp</a></code></li>
<li><code><a title="exchangelib.EWSDateTime.utcnow" href="#exchangelib.EWSDateTime.utcnow">utcnow</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.EWSTimeZone" href="#exchangelib.EWSTimeZone">EWSTimeZone</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.EWSTimeZone.IANA_TO_MS_MAP" href="#exchangelib.EWSTimeZone.IANA_TO_MS_MAP">IANA_TO_MS_MAP</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.MS_TO_IANA_MAP" href="#exchangelib.EWSTimeZone.MS_TO_IANA_MAP">MS_TO_IANA_MAP</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.from_dateutil" href="#exchangelib.EWSTimeZone.from_dateutil">from_dateutil</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.from_ms_id" href="#exchangelib.EWSTimeZone.from_ms_id">from_ms_id</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.from_pytz" href="#exchangelib.EWSTimeZone.from_pytz">from_pytz</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.from_timezone" href="#exchangelib.EWSTimeZone.from_timezone">from_timezone</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.from_zoneinfo" href="#exchangelib.EWSTimeZone.from_zoneinfo">from_zoneinfo</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.fromutc" href="#exchangelib.EWSTimeZone.fromutc">fromutc</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.localize" href="#exchangelib.EWSTimeZone.localize">localize</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.localzone" href="#exchangelib.EWSTimeZone.localzone">localzone</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.normalize" href="#exchangelib.EWSTimeZone.normalize">normalize</a></code></li>
<li><code><a title="exchangelib.EWSTimeZone.timezone" href="#exchangelib.EWSTimeZone.timezone">timezone</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.ExtendedProperty" href="#exchangelib.ExtendedProperty">ExtendedProperty</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.ExtendedProperty.DISTINGUISHED_SETS" href="#exchangelib.ExtendedProperty.DISTINGUISHED_SETS">DISTINGUISHED_SETS</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.DISTINGUISHED_SET_ID_TO_NAME_MAP" href="#exchangelib.ExtendedProperty.DISTINGUISHED_SET_ID_TO_NAME_MAP">DISTINGUISHED_SET_ID_TO_NAME_MAP</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.DISTINGUISHED_SET_NAME_TO_ID_MAP" href="#exchangelib.ExtendedProperty.DISTINGUISHED_SET_NAME_TO_ID_MAP">DISTINGUISHED_SET_NAME_TO_ID_MAP</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.ELEMENT_NAME" href="#exchangelib.ExtendedProperty.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.PROPERTY_TYPES" href="#exchangelib.ExtendedProperty.PROPERTY_TYPES">PROPERTY_TYPES</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.as_object" href="#exchangelib.ExtendedProperty.as_object">as_object</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.clean" href="#exchangelib.ExtendedProperty.clean">clean</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.distinguished_property_set_id" href="#exchangelib.ExtendedProperty.distinguished_property_set_id">distinguished_property_set_id</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.from_xml" href="#exchangelib.ExtendedProperty.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.is_array_type" href="#exchangelib.ExtendedProperty.is_array_type">is_array_type</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.is_property_instance" href="#exchangelib.ExtendedProperty.is_property_instance">is_property_instance</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.property_id" href="#exchangelib.ExtendedProperty.property_id">property_id</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.property_name" href="#exchangelib.ExtendedProperty.property_name">property_name</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.property_set_id" href="#exchangelib.ExtendedProperty.property_set_id">property_set_id</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.property_tag" href="#exchangelib.ExtendedProperty.property_tag">property_tag</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.property_tag_as_hex" href="#exchangelib.ExtendedProperty.property_tag_as_hex">property_tag_as_hex</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.property_tag_as_int" href="#exchangelib.ExtendedProperty.property_tag_as_int">property_tag_as_int</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.property_type" href="#exchangelib.ExtendedProperty.property_type">property_type</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.python_type" href="#exchangelib.ExtendedProperty.python_type">python_type</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.to_xml" href="#exchangelib.ExtendedProperty.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.validate_cls" href="#exchangelib.ExtendedProperty.validate_cls">validate_cls</a></code></li>
<li><code><a title="exchangelib.ExtendedProperty.value" href="#exchangelib.ExtendedProperty.value">value</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.FailFast" href="#exchangelib.FailFast">FailFast</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.FailFast.back_off" href="#exchangelib.FailFast.back_off">back_off</a></code></li>
<li><code><a title="exchangelib.FailFast.back_off_until" href="#exchangelib.FailFast.back_off_until">back_off_until</a></code></li>
<li><code><a title="exchangelib.FailFast.fail_fast" href="#exchangelib.FailFast.fail_fast">fail_fast</a></code></li>
<li><code><a title="exchangelib.FailFast.may_retry_on_error" href="#exchangelib.FailFast.may_retry_on_error">may_retry_on_error</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.FaultTolerance" href="#exchangelib.FaultTolerance">FaultTolerance</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.FaultTolerance.DEFAULT_BACKOFF" href="#exchangelib.FaultTolerance.DEFAULT_BACKOFF">DEFAULT_BACKOFF</a></code></li>
<li><code><a title="exchangelib.FaultTolerance.back_off" href="#exchangelib.FaultTolerance.back_off">back_off</a></code></li>
<li><code><a title="exchangelib.FaultTolerance.back_off_until" href="#exchangelib.FaultTolerance.back_off_until">back_off_until</a></code></li>
<li><code><a title="exchangelib.FaultTolerance.fail_fast" href="#exchangelib.FaultTolerance.fail_fast">fail_fast</a></code></li>
<li><code><a title="exchangelib.FaultTolerance.may_retry_on_error" href="#exchangelib.FaultTolerance.may_retry_on_error">may_retry_on_error</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.FileAttachment" href="#exchangelib.FileAttachment">FileAttachment</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.FileAttachment.ELEMENT_NAME" href="#exchangelib.FileAttachment.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.FileAttachment.FIELDS" href="#exchangelib.FileAttachment.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.FileAttachment.content" href="#exchangelib.FileAttachment.content">content</a></code></li>
<li><code><a title="exchangelib.FileAttachment.fp" href="#exchangelib.FileAttachment.fp">fp</a></code></li>
<li><code><a title="exchangelib.FileAttachment.from_xml" href="#exchangelib.FileAttachment.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.FileAttachment.is_contact_photo" href="#exchangelib.FileAttachment.is_contact_photo">is_contact_photo</a></code></li>
<li><code><a title="exchangelib.FileAttachment.to_xml" href="#exchangelib.FileAttachment.to_xml">to_xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Folder" href="#exchangelib.Folder">Folder</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.Folder.FIELDS" href="#exchangelib.Folder.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.Folder.account" href="#exchangelib.Folder.account">account</a></code></li>
<li><code><a title="exchangelib.Folder.clean" href="#exchangelib.Folder.clean">clean</a></code></li>
<li><code><a title="exchangelib.Folder.effective_rights" href="#exchangelib.Folder.effective_rights">effective_rights</a></code></li>
<li><code><a title="exchangelib.Folder.from_xml_with_root" href="#exchangelib.Folder.from_xml_with_root">from_xml_with_root</a></code></li>
<li><code><a title="exchangelib.Folder.get_distinguished" href="#exchangelib.Folder.get_distinguished">get_distinguished</a></code></li>
<li><code><a title="exchangelib.Folder.parent" href="#exchangelib.Folder.parent">parent</a></code></li>
<li><code><a title="exchangelib.Folder.permission_set" href="#exchangelib.Folder.permission_set">permission_set</a></code></li>
<li><code><a title="exchangelib.Folder.root" href="#exchangelib.Folder.root">root</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.FolderCollection" href="#exchangelib.FolderCollection">FolderCollection</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.FolderCollection.REQUIRED_FOLDER_FIELDS" href="#exchangelib.FolderCollection.REQUIRED_FOLDER_FIELDS">REQUIRED_FOLDER_FIELDS</a></code></li>
<li><code><a title="exchangelib.FolderCollection.all" href="#exchangelib.FolderCollection.all">all</a></code></li>
<li><code><a title="exchangelib.FolderCollection.allowed_item_fields" href="#exchangelib.FolderCollection.allowed_item_fields">allowed_item_fields</a></code></li>
<li><code><a title="exchangelib.FolderCollection.exclude" href="#exchangelib.FolderCollection.exclude">exclude</a></code></li>
<li><code><a title="exchangelib.FolderCollection.filter" href="#exchangelib.FolderCollection.filter">filter</a></code></li>
<li><code><a title="exchangelib.FolderCollection.find_folders" href="#exchangelib.FolderCollection.find_folders">find_folders</a></code></li>
<li><code><a title="exchangelib.FolderCollection.find_items" href="#exchangelib.FolderCollection.find_items">find_items</a></code></li>
<li><code><a title="exchangelib.FolderCollection.find_people" href="#exchangelib.FolderCollection.find_people">find_people</a></code></li>
<li><code><a title="exchangelib.FolderCollection.folders" href="#exchangelib.FolderCollection.folders">folders</a></code></li>
<li><code><a title="exchangelib.FolderCollection.get" href="#exchangelib.FolderCollection.get">get</a></code></li>
<li><code><a title="exchangelib.FolderCollection.get_folder_fields" href="#exchangelib.FolderCollection.get_folder_fields">get_folder_fields</a></code></li>
<li><code><a title="exchangelib.FolderCollection.get_folders" href="#exchangelib.FolderCollection.get_folders">get_folders</a></code></li>
<li><code><a title="exchangelib.FolderCollection.none" href="#exchangelib.FolderCollection.none">none</a></code></li>
<li><code><a title="exchangelib.FolderCollection.people" href="#exchangelib.FolderCollection.people">people</a></code></li>
<li><code><a title="exchangelib.FolderCollection.resolve" href="#exchangelib.FolderCollection.resolve">resolve</a></code></li>
<li><code><a title="exchangelib.FolderCollection.subscribe_to_pull" href="#exchangelib.FolderCollection.subscribe_to_pull">subscribe_to_pull</a></code></li>
<li><code><a title="exchangelib.FolderCollection.subscribe_to_push" href="#exchangelib.FolderCollection.subscribe_to_push">subscribe_to_push</a></code></li>
<li><code><a title="exchangelib.FolderCollection.subscribe_to_streaming" href="#exchangelib.FolderCollection.subscribe_to_streaming">subscribe_to_streaming</a></code></li>
<li><code><a title="exchangelib.FolderCollection.supported_item_models" href="#exchangelib.FolderCollection.supported_item_models">supported_item_models</a></code></li>
<li><code><a title="exchangelib.FolderCollection.sync_hierarchy" href="#exchangelib.FolderCollection.sync_hierarchy">sync_hierarchy</a></code></li>
<li><code><a title="exchangelib.FolderCollection.sync_items" href="#exchangelib.FolderCollection.sync_items">sync_items</a></code></li>
<li><code><a title="exchangelib.FolderCollection.validate_item_field" href="#exchangelib.FolderCollection.validate_item_field">validate_item_field</a></code></li>
<li><code><a title="exchangelib.FolderCollection.view" href="#exchangelib.FolderCollection.view">view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.ForwardItem" href="#exchangelib.ForwardItem">ForwardItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.ForwardItem.ELEMENT_NAME" href="#exchangelib.ForwardItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.HTMLBody" href="#exchangelib.HTMLBody">HTMLBody</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.HTMLBody.body_type" href="#exchangelib.HTMLBody.body_type">body_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Identity" href="#exchangelib.Identity">Identity</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.ItemAttachment" href="#exchangelib.ItemAttachment">ItemAttachment</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.ItemAttachment.ELEMENT_NAME" href="#exchangelib.ItemAttachment.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.ItemAttachment.FIELDS" href="#exchangelib.ItemAttachment.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.ItemAttachment.from_xml" href="#exchangelib.ItemAttachment.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.ItemAttachment.item" href="#exchangelib.ItemAttachment.item">item</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.ItemId" href="#exchangelib.ItemId">ItemId</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.ItemId.CHANGEKEY_ATTR" href="#exchangelib.ItemId.CHANGEKEY_ATTR">CHANGEKEY_ATTR</a></code></li>
<li><code><a title="exchangelib.ItemId.ELEMENT_NAME" href="#exchangelib.ItemId.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.ItemId.FIELDS" href="#exchangelib.ItemId.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.ItemId.ID_ATTR" href="#exchangelib.ItemId.ID_ATTR">ID_ATTR</a></code></li>
<li><code><a title="exchangelib.ItemId.changekey" href="#exchangelib.ItemId.changekey">changekey</a></code></li>
<li><code><a title="exchangelib.ItemId.id" href="#exchangelib.ItemId.id">id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Mailbox" href="#exchangelib.Mailbox">Mailbox</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Mailbox.ELEMENT_NAME" href="#exchangelib.Mailbox.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.Mailbox.FIELDS" href="#exchangelib.Mailbox.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.Mailbox.MAILBOX" href="#exchangelib.Mailbox.MAILBOX">MAILBOX</a></code></li>
<li><code><a title="exchangelib.Mailbox.MAILBOX_TYPE_CHOICES" href="#exchangelib.Mailbox.MAILBOX_TYPE_CHOICES">MAILBOX_TYPE_CHOICES</a></code></li>
<li><code><a title="exchangelib.Mailbox.ONE_OFF" href="#exchangelib.Mailbox.ONE_OFF">ONE_OFF</a></code></li>
<li><code><a title="exchangelib.Mailbox.clean" href="#exchangelib.Mailbox.clean">clean</a></code></li>
<li><code><a title="exchangelib.Mailbox.email_address" href="#exchangelib.Mailbox.email_address">email_address</a></code></li>
<li><code><a title="exchangelib.Mailbox.item_id" href="#exchangelib.Mailbox.item_id">item_id</a></code></li>
<li><code><a title="exchangelib.Mailbox.mailbox_type" href="#exchangelib.Mailbox.mailbox_type">mailbox_type</a></code></li>
<li><code><a title="exchangelib.Mailbox.name" href="#exchangelib.Mailbox.name">name</a></code></li>
<li><code><a title="exchangelib.Mailbox.routing_type" href="#exchangelib.Mailbox.routing_type">routing_type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Message" href="#exchangelib.Message">Message</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Message.ELEMENT_NAME" href="#exchangelib.Message.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.Message.FIELDS" href="#exchangelib.Message.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.Message.author" href="#exchangelib.Message.author">author</a></code></li>
<li><code><a title="exchangelib.Message.bcc_recipients" href="#exchangelib.Message.bcc_recipients">bcc_recipients</a></code></li>
<li><code><a title="exchangelib.Message.cc_recipients" href="#exchangelib.Message.cc_recipients">cc_recipients</a></code></li>
<li><code><a title="exchangelib.Message.conversation_index" href="#exchangelib.Message.conversation_index">conversation_index</a></code></li>
<li><code><a title="exchangelib.Message.conversation_topic" href="#exchangelib.Message.conversation_topic">conversation_topic</a></code></li>
<li><code><a title="exchangelib.Message.create_reply" href="#exchangelib.Message.create_reply">create_reply</a></code></li>
<li><code><a title="exchangelib.Message.create_reply_all" href="#exchangelib.Message.create_reply_all">create_reply_all</a></code></li>
<li><code><a title="exchangelib.Message.is_delivery_receipt_requested" href="#exchangelib.Message.is_delivery_receipt_requested">is_delivery_receipt_requested</a></code></li>
<li><code><a title="exchangelib.Message.is_read" href="#exchangelib.Message.is_read">is_read</a></code></li>
<li><code><a title="exchangelib.Message.is_read_receipt_requested" href="#exchangelib.Message.is_read_receipt_requested">is_read_receipt_requested</a></code></li>
<li><code><a title="exchangelib.Message.is_response_requested" href="#exchangelib.Message.is_response_requested">is_response_requested</a></code></li>
<li><code><a title="exchangelib.Message.mark_as_junk" href="#exchangelib.Message.mark_as_junk">mark_as_junk</a></code></li>
<li><code><a title="exchangelib.Message.message_id" href="#exchangelib.Message.message_id">message_id</a></code></li>
<li><code><a title="exchangelib.Message.received_by" href="#exchangelib.Message.received_by">received_by</a></code></li>
<li><code><a title="exchangelib.Message.received_representing" href="#exchangelib.Message.received_representing">received_representing</a></code></li>
<li><code><a title="exchangelib.Message.references" href="#exchangelib.Message.references">references</a></code></li>
<li><code><a title="exchangelib.Message.reminder_message_data" href="#exchangelib.Message.reminder_message_data">reminder_message_data</a></code></li>
<li><code><a title="exchangelib.Message.reply" href="#exchangelib.Message.reply">reply</a></code></li>
<li><code><a title="exchangelib.Message.reply_all" href="#exchangelib.Message.reply_all">reply_all</a></code></li>
<li><code><a title="exchangelib.Message.reply_to" href="#exchangelib.Message.reply_to">reply_to</a></code></li>
<li><code><a title="exchangelib.Message.send" href="#exchangelib.Message.send">send</a></code></li>
<li><code><a title="exchangelib.Message.send_and_save" href="#exchangelib.Message.send_and_save">send_and_save</a></code></li>
<li><code><a title="exchangelib.Message.sender" href="#exchangelib.Message.sender">sender</a></code></li>
<li><code><a title="exchangelib.Message.to_recipients" href="#exchangelib.Message.to_recipients">to_recipients</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.NoVerifyHTTPAdapter" href="#exchangelib.NoVerifyHTTPAdapter">NoVerifyHTTPAdapter</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.NoVerifyHTTPAdapter.cert_verify" href="#exchangelib.NoVerifyHTTPAdapter.cert_verify">cert_verify</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.OAuth2AuthorizationCodeCredentials" href="#exchangelib.OAuth2AuthorizationCodeCredentials">OAuth2AuthorizationCodeCredentials</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.OAuth2Credentials" href="#exchangelib.OAuth2Credentials">OAuth2Credentials</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.OAuth2Credentials.on_token_auto_refreshed" href="#exchangelib.OAuth2Credentials.on_token_auto_refreshed">on_token_auto_refreshed</a></code></li>
<li><code><a title="exchangelib.OAuth2Credentials.sig" href="#exchangelib.OAuth2Credentials.sig">sig</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.OofSettings" href="#exchangelib.OofSettings">OofSettings</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.OofSettings.DISABLED" href="#exchangelib.OofSettings.DISABLED">DISABLED</a></code></li>
<li><code><a title="exchangelib.OofSettings.ELEMENT_NAME" href="#exchangelib.OofSettings.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.OofSettings.ENABLED" href="#exchangelib.OofSettings.ENABLED">ENABLED</a></code></li>
<li><code><a title="exchangelib.OofSettings.FIELDS" href="#exchangelib.OofSettings.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.OofSettings.REQUEST_ELEMENT_NAME" href="#exchangelib.OofSettings.REQUEST_ELEMENT_NAME">REQUEST_ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.OofSettings.SCHEDULED" href="#exchangelib.OofSettings.SCHEDULED">SCHEDULED</a></code></li>
<li><code><a title="exchangelib.OofSettings.STATE_CHOICES" href="#exchangelib.OofSettings.STATE_CHOICES">STATE_CHOICES</a></code></li>
<li><code><a title="exchangelib.OofSettings.clean" href="#exchangelib.OofSettings.clean">clean</a></code></li>
<li><code><a title="exchangelib.OofSettings.end" href="#exchangelib.OofSettings.end">end</a></code></li>
<li><code><a title="exchangelib.OofSettings.external_audience" href="#exchangelib.OofSettings.external_audience">external_audience</a></code></li>
<li><code><a title="exchangelib.OofSettings.external_reply" href="#exchangelib.OofSettings.external_reply">external_reply</a></code></li>
<li><code><a title="exchangelib.OofSettings.from_xml" href="#exchangelib.OofSettings.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.OofSettings.internal_reply" href="#exchangelib.OofSettings.internal_reply">internal_reply</a></code></li>
<li><code><a title="exchangelib.OofSettings.start" href="#exchangelib.OofSettings.start">start</a></code></li>
<li><code><a title="exchangelib.OofSettings.state" href="#exchangelib.OofSettings.state">state</a></code></li>
<li><code><a title="exchangelib.OofSettings.to_xml" href="#exchangelib.OofSettings.to_xml">to_xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.PostItem" href="#exchangelib.PostItem">PostItem</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.PostItem.ELEMENT_NAME" href="#exchangelib.PostItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.PostItem.FIELDS" href="#exchangelib.PostItem.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.PostItem.author" href="#exchangelib.PostItem.author">author</a></code></li>
<li><code><a title="exchangelib.PostItem.conversation_index" href="#exchangelib.PostItem.conversation_index">conversation_index</a></code></li>
<li><code><a title="exchangelib.PostItem.conversation_topic" href="#exchangelib.PostItem.conversation_topic">conversation_topic</a></code></li>
<li><code><a title="exchangelib.PostItem.is_read" href="#exchangelib.PostItem.is_read">is_read</a></code></li>
<li><code><a title="exchangelib.PostItem.message_id" href="#exchangelib.PostItem.message_id">message_id</a></code></li>
<li><code><a title="exchangelib.PostItem.posted_time" href="#exchangelib.PostItem.posted_time">posted_time</a></code></li>
<li><code><a title="exchangelib.PostItem.references" href="#exchangelib.PostItem.references">references</a></code></li>
<li><code><a title="exchangelib.PostItem.sender" href="#exchangelib.PostItem.sender">sender</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Q" href="#exchangelib.Q">Q</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.Q.AND" href="#exchangelib.Q.AND">AND</a></code></li>
<li><code><a title="exchangelib.Q.CONN_TYPES" href="#exchangelib.Q.CONN_TYPES">CONN_TYPES</a></code></li>
<li><code><a title="exchangelib.Q.CONTAINS" href="#exchangelib.Q.CONTAINS">CONTAINS</a></code></li>
<li><code><a title="exchangelib.Q.CONTAINS_OPS" href="#exchangelib.Q.CONTAINS_OPS">CONTAINS_OPS</a></code></li>
<li><code><a title="exchangelib.Q.EQ" href="#exchangelib.Q.EQ">EQ</a></code></li>
<li><code><a title="exchangelib.Q.EXACT" href="#exchangelib.Q.EXACT">EXACT</a></code></li>
<li><code><a title="exchangelib.Q.EXISTS" href="#exchangelib.Q.EXISTS">EXISTS</a></code></li>
<li><code><a title="exchangelib.Q.GT" href="#exchangelib.Q.GT">GT</a></code></li>
<li><code><a title="exchangelib.Q.GTE" href="#exchangelib.Q.GTE">GTE</a></code></li>
<li><code><a title="exchangelib.Q.ICONTAINS" href="#exchangelib.Q.ICONTAINS">ICONTAINS</a></code></li>
<li><code><a title="exchangelib.Q.IEXACT" href="#exchangelib.Q.IEXACT">IEXACT</a></code></li>
<li><code><a title="exchangelib.Q.ISTARTSWITH" href="#exchangelib.Q.ISTARTSWITH">ISTARTSWITH</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_CONTAINS" href="#exchangelib.Q.LOOKUP_CONTAINS">LOOKUP_CONTAINS</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_EXACT" href="#exchangelib.Q.LOOKUP_EXACT">LOOKUP_EXACT</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_EXISTS" href="#exchangelib.Q.LOOKUP_EXISTS">LOOKUP_EXISTS</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_GT" href="#exchangelib.Q.LOOKUP_GT">LOOKUP_GT</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_GTE" href="#exchangelib.Q.LOOKUP_GTE">LOOKUP_GTE</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_ICONTAINS" href="#exchangelib.Q.LOOKUP_ICONTAINS">LOOKUP_ICONTAINS</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_IEXACT" href="#exchangelib.Q.LOOKUP_IEXACT">LOOKUP_IEXACT</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_IN" href="#exchangelib.Q.LOOKUP_IN">LOOKUP_IN</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_ISTARTSWITH" href="#exchangelib.Q.LOOKUP_ISTARTSWITH">LOOKUP_ISTARTSWITH</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_LT" href="#exchangelib.Q.LOOKUP_LT">LOOKUP_LT</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_LTE" href="#exchangelib.Q.LOOKUP_LTE">LOOKUP_LTE</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_NOT" href="#exchangelib.Q.LOOKUP_NOT">LOOKUP_NOT</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_RANGE" href="#exchangelib.Q.LOOKUP_RANGE">LOOKUP_RANGE</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_STARTSWITH" href="#exchangelib.Q.LOOKUP_STARTSWITH">LOOKUP_STARTSWITH</a></code></li>
<li><code><a title="exchangelib.Q.LOOKUP_TYPES" href="#exchangelib.Q.LOOKUP_TYPES">LOOKUP_TYPES</a></code></li>
<li><code><a title="exchangelib.Q.LT" href="#exchangelib.Q.LT">LT</a></code></li>
<li><code><a title="exchangelib.Q.LTE" href="#exchangelib.Q.LTE">LTE</a></code></li>
<li><code><a title="exchangelib.Q.NE" href="#exchangelib.Q.NE">NE</a></code></li>
<li><code><a title="exchangelib.Q.NEVER" href="#exchangelib.Q.NEVER">NEVER</a></code></li>
<li><code><a title="exchangelib.Q.NOT" href="#exchangelib.Q.NOT">NOT</a></code></li>
<li><code><a title="exchangelib.Q.OP_TYPES" href="#exchangelib.Q.OP_TYPES">OP_TYPES</a></code></li>
<li><code><a title="exchangelib.Q.OR" href="#exchangelib.Q.OR">OR</a></code></li>
<li><code><a title="exchangelib.Q.STARTSWITH" href="#exchangelib.Q.STARTSWITH">STARTSWITH</a></code></li>
<li><code><a title="exchangelib.Q.children" href="#exchangelib.Q.children">children</a></code></li>
<li><code><a title="exchangelib.Q.clean" href="#exchangelib.Q.clean">clean</a></code></li>
<li><code><a title="exchangelib.Q.conn_type" href="#exchangelib.Q.conn_type">conn_type</a></code></li>
<li><code><a title="exchangelib.Q.expr" href="#exchangelib.Q.expr">expr</a></code></li>
<li><code><a title="exchangelib.Q.field_path" href="#exchangelib.Q.field_path">field_path</a></code></li>
<li><code><a title="exchangelib.Q.is_empty" href="#exchangelib.Q.is_empty">is_empty</a></code></li>
<li><code><a title="exchangelib.Q.is_leaf" href="#exchangelib.Q.is_leaf">is_leaf</a></code></li>
<li><code><a title="exchangelib.Q.is_never" href="#exchangelib.Q.is_never">is_never</a></code></li>
<li><code><a title="exchangelib.Q.op" href="#exchangelib.Q.op">op</a></code></li>
<li><code><a title="exchangelib.Q.query_string" href="#exchangelib.Q.query_string">query_string</a></code></li>
<li><code><a title="exchangelib.Q.reduce" href="#exchangelib.Q.reduce">reduce</a></code></li>
<li><code><a title="exchangelib.Q.to_xml" href="#exchangelib.Q.to_xml">to_xml</a></code></li>
<li><code><a title="exchangelib.Q.value" href="#exchangelib.Q.value">value</a></code></li>
<li><code><a title="exchangelib.Q.xml_elem" href="#exchangelib.Q.xml_elem">xml_elem</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.ReplyAllToItem" href="#exchangelib.ReplyAllToItem">ReplyAllToItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.ReplyAllToItem.ELEMENT_NAME" href="#exchangelib.ReplyAllToItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.ReplyToItem" href="#exchangelib.ReplyToItem">ReplyToItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.ReplyToItem.ELEMENT_NAME" href="#exchangelib.ReplyToItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Room" href="#exchangelib.Room">Room</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Room.ELEMENT_NAME" href="#exchangelib.Room.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.Room.from_xml" href="#exchangelib.Room.from_xml">from_xml</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.RoomList" href="#exchangelib.RoomList">RoomList</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.RoomList.ELEMENT_NAME" href="#exchangelib.RoomList.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.RoomList.NAMESPACE" href="#exchangelib.RoomList.NAMESPACE">NAMESPACE</a></code></li>
<li><code><a title="exchangelib.RoomList.response_tag" href="#exchangelib.RoomList.response_tag">response_tag</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.RootOfHierarchy" href="#exchangelib.RootOfHierarchy">RootOfHierarchy</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.RootOfHierarchy.FIELDS" href="#exchangelib.RootOfHierarchy.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.WELLKNOWN_FOLDERS" href="#exchangelib.RootOfHierarchy.WELLKNOWN_FOLDERS">WELLKNOWN_FOLDERS</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.account" href="#exchangelib.RootOfHierarchy.account">account</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.add_folder" href="#exchangelib.RootOfHierarchy.add_folder">add_folder</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.clear_cache" href="#exchangelib.RootOfHierarchy.clear_cache">clear_cache</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.effective_rights" href="#exchangelib.RootOfHierarchy.effective_rights">effective_rights</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.folder_cls_from_folder_name" href="#exchangelib.RootOfHierarchy.folder_cls_from_folder_name">folder_cls_from_folder_name</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.from_xml" href="#exchangelib.RootOfHierarchy.from_xml">from_xml</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.get_children" href="#exchangelib.RootOfHierarchy.get_children">get_children</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.get_default_folder" href="#exchangelib.RootOfHierarchy.get_default_folder">get_default_folder</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.get_distinguished" href="#exchangelib.RootOfHierarchy.get_distinguished">get_distinguished</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.get_folder" href="#exchangelib.RootOfHierarchy.get_folder">get_folder</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.parent" href="#exchangelib.RootOfHierarchy.parent">parent</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.remove_folder" href="#exchangelib.RootOfHierarchy.remove_folder">remove_folder</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.root" href="#exchangelib.RootOfHierarchy.root">root</a></code></li>
<li><code><a title="exchangelib.RootOfHierarchy.update_folder" href="#exchangelib.RootOfHierarchy.update_folder">update_folder</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.TLSClientAuth" href="#exchangelib.TLSClientAuth">TLSClientAuth</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.TLSClientAuth.cert_file" href="#exchangelib.TLSClientAuth.cert_file">cert_file</a></code></li>
<li><code><a title="exchangelib.TLSClientAuth.init_poolmanager" href="#exchangelib.TLSClientAuth.init_poolmanager">init_poolmanager</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Task" href="#exchangelib.Task">Task</a></code></h4>
<ul class="two-column">
<li><code><a title="exchangelib.Task.COMPLETED" href="#exchangelib.Task.COMPLETED">COMPLETED</a></code></li>
<li><code><a title="exchangelib.Task.ELEMENT_NAME" href="#exchangelib.Task.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
<li><code><a title="exchangelib.Task.FIELDS" href="#exchangelib.Task.FIELDS">FIELDS</a></code></li>
<li><code><a title="exchangelib.Task.NOT_STARTED" href="#exchangelib.Task.NOT_STARTED">NOT_STARTED</a></code></li>
<li><code><a title="exchangelib.Task.actual_work" href="#exchangelib.Task.actual_work">actual_work</a></code></li>
<li><code><a title="exchangelib.Task.assigned_time" href="#exchangelib.Task.assigned_time">assigned_time</a></code></li>
<li><code><a title="exchangelib.Task.billing_information" href="#exchangelib.Task.billing_information">billing_information</a></code></li>
<li><code><a title="exchangelib.Task.change_count" href="#exchangelib.Task.change_count">change_count</a></code></li>
<li><code><a title="exchangelib.Task.clean" href="#exchangelib.Task.clean">clean</a></code></li>
<li><code><a title="exchangelib.Task.companies" href="#exchangelib.Task.companies">companies</a></code></li>
<li><code><a title="exchangelib.Task.complete" href="#exchangelib.Task.complete">complete</a></code></li>
<li><code><a title="exchangelib.Task.complete_date" href="#exchangelib.Task.complete_date">complete_date</a></code></li>
<li><code><a title="exchangelib.Task.contacts" href="#exchangelib.Task.contacts">contacts</a></code></li>
<li><code><a title="exchangelib.Task.delegation_state" href="#exchangelib.Task.delegation_state">delegation_state</a></code></li>
<li><code><a title="exchangelib.Task.delegator" href="#exchangelib.Task.delegator">delegator</a></code></li>
<li><code><a title="exchangelib.Task.due_date" href="#exchangelib.Task.due_date">due_date</a></code></li>
<li><code><a title="exchangelib.Task.is_complete" href="#exchangelib.Task.is_complete">is_complete</a></code></li>
<li><code><a title="exchangelib.Task.is_editable" href="#exchangelib.Task.is_editable">is_editable</a></code></li>
<li><code><a title="exchangelib.Task.is_recurring" href="#exchangelib.Task.is_recurring">is_recurring</a></code></li>
<li><code><a title="exchangelib.Task.is_team_task" href="#exchangelib.Task.is_team_task">is_team_task</a></code></li>
<li><code><a title="exchangelib.Task.mileage" href="#exchangelib.Task.mileage">mileage</a></code></li>
<li><code><a title="exchangelib.Task.owner" href="#exchangelib.Task.owner">owner</a></code></li>
<li><code><a title="exchangelib.Task.percent_complete" href="#exchangelib.Task.percent_complete">percent_complete</a></code></li>
<li><code><a title="exchangelib.Task.recurrence" href="#exchangelib.Task.recurrence">recurrence</a></code></li>
<li><code><a title="exchangelib.Task.start_date" href="#exchangelib.Task.start_date">start_date</a></code></li>
<li><code><a title="exchangelib.Task.status" href="#exchangelib.Task.status">status</a></code></li>
<li><code><a title="exchangelib.Task.status_description" href="#exchangelib.Task.status_description">status_description</a></code></li>
<li><code><a title="exchangelib.Task.total_work" href="#exchangelib.Task.total_work">total_work</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.TentativelyAcceptItem" href="#exchangelib.TentativelyAcceptItem">TentativelyAcceptItem</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.TentativelyAcceptItem.ELEMENT_NAME" href="#exchangelib.TentativelyAcceptItem.ELEMENT_NAME">ELEMENT_NAME</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.UID" href="#exchangelib.UID">UID</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.UID.to_global_object_id" href="#exchangelib.UID.to_global_object_id">to_global_object_id</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.Version" href="#exchangelib.Version">Version</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.Version.api_version" href="#exchangelib.Version.api_version">api_version</a></code></li>
<li><code><a title="exchangelib.Version.build" href="#exchangelib.Version.build">build</a></code></li>
<li><code><a title="exchangelib.Version.from_soap_header" href="#exchangelib.Version.from_soap_header">from_soap_header</a></code></li>
<li><code><a title="exchangelib.Version.fullname" href="#exchangelib.Version.fullname">fullname</a></code></li>
<li><code><a title="exchangelib.Version.guess" href="#exchangelib.Version.guess">guess</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>