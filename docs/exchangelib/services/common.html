<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>exchangelib.services.common API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>exchangelib.services.common</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import abc
import logging
import traceback
from itertools import chain

from .. import errors
from ..credentials import IMPERSONATION, OAuth2Credentials
from ..errors import EWSWarning, TransportError, SOAPError, ErrorTimeoutExpired, ErrorBatchProcessingStopped, \
    ErrorQuotaExceeded, ErrorCannotDeleteObject, ErrorCreateItemAccessDenied, ErrorFolderNotFound, \
    ErrorNonExistentMailbox, ErrorMailboxStoreUnavailable, ErrorImpersonateUserDenied, ErrorInternalServerError, \
    ErrorInternalServerTransientError, ErrorNoRespondingCASInDestinationSite, ErrorImpersonationFailed, \
    ErrorMailboxMoveInProgress, ErrorAccessDenied, ErrorConnectionFailed, RateLimitError, ErrorServerBusy, \
    ErrorTooManyObjectsOpened, ErrorInvalidLicense, ErrorInvalidSchemaVersionForMailboxVersion, \
    ErrorInvalidServerVersion, ErrorItemNotFound, ErrorADUnavailable, ErrorInvalidChangeKey, \
    ErrorItemSave, ErrorInvalidIdMalformed, ErrorMessageSizeExceeded, UnauthorizedError, \
    ErrorCannotDeleteTaskOccurrence, ErrorMimeContentConversionFailed, ErrorRecurrenceHasNoOccurrence, \
    ErrorNoPublicFolderReplicaAvailable, MalformedResponseError, ErrorExceededConnectionCount, \
    SessionPoolMinSizeReached, ErrorIncorrectSchemaVersion, ErrorInvalidRequest, ErrorCorruptData, \
    ErrorCannotEmptyFolder, ErrorDeleteDistinguishedFolder, ErrorInvalidSubscription, ErrorInvalidWatermark, \
    ErrorInvalidSyncStateData, ErrorNameResolutionNoResults, ErrorNameResolutionMultipleResults, \
    ErrorConnectionFailedTransientError
from ..properties import FieldURI, IndexedFieldURI, ExtendedFieldURI, ExceptionFieldURI, ItemId
from ..transport import wrap
from ..util import chunkify, create_element, add_xml_child, get_xml_attr, to_xml, post_ratelimited, \
    xml_to_str, set_xml_value, SOAPNS, TNS, MNS, ENS, ParseError, DummyResponse
from ..version import API_VERSIONS, Version

log = logging.getLogger(__name__)

CHUNK_SIZE = 100  # A default chunk size for all services

KNOWN_EXCEPTIONS = (
    ErrorAccessDenied,
    ErrorADUnavailable,
    ErrorBatchProcessingStopped,
    ErrorCannotDeleteObject,
    ErrorCannotEmptyFolder,
    ErrorConnectionFailed,
    ErrorConnectionFailedTransientError,
    ErrorCreateItemAccessDenied,
    ErrorDeleteDistinguishedFolder,
    ErrorExceededConnectionCount,
    ErrorFolderNotFound,
    ErrorImpersonateUserDenied,
    ErrorImpersonationFailed,
    ErrorInternalServerError,
    ErrorInternalServerTransientError,
    ErrorInvalidChangeKey,
    ErrorInvalidLicense,
    ErrorInvalidSubscription,
    ErrorInvalidSyncStateData,
    ErrorInvalidWatermark,
    ErrorItemNotFound,
    ErrorMailboxMoveInProgress,
    ErrorMailboxStoreUnavailable,
    ErrorNameResolutionMultipleResults,
    ErrorNameResolutionNoResults,
    ErrorNonExistentMailbox,
    ErrorNoPublicFolderReplicaAvailable,
    ErrorNoRespondingCASInDestinationSite,
    ErrorQuotaExceeded,
    ErrorTimeoutExpired,
    RateLimitError,
    UnauthorizedError,
)


class EWSService(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Base class for all EWS services.&#34;&#34;&#34;

    SERVICE_NAME = None  # The name of the SOAP service
    element_container_name = None  # The name of the XML element wrapping the collection of returned items
    paging_container_name = None  # The name of the element that contains paging information and the paged results
    returns_elements = True  # If False, the service does not return response elements, just the RsponseCode status
    # Return exception instance instead of raising exceptions for the following errors when contained in an element
    ERRORS_TO_CATCH_IN_RESPONSE = (
        EWSWarning, ErrorCannotDeleteObject, ErrorInvalidChangeKey, ErrorItemNotFound, ErrorItemSave,
        ErrorInvalidIdMalformed, ErrorMessageSizeExceeded, ErrorCannotDeleteTaskOccurrence,
        ErrorMimeContentConversionFailed, ErrorRecurrenceHasNoOccurrence, ErrorCorruptData
    )
    # Similarly, define the warnings we want to return unraised
    WARNINGS_TO_CATCH_IN_RESPONSE = ErrorBatchProcessingStopped
    # Define the warnings we want to ignore, to let response processing proceed
    WARNINGS_TO_IGNORE_IN_RESPONSE = ()
    # The exception type to raise when all attempted API versions failed
    NO_VALID_SERVER_VERSIONS = ErrorInvalidServerVersion
    # Marks the version from which the service was introduced
    supported_from = None
    # Marks services that support paging of requested items
    supports_paging = False
    # Marks services that need affinity to the backend server
    prefer_affinity = False

    def __init__(self, protocol, chunk_size=None, timeout=None):
        self.chunk_size = chunk_size or CHUNK_SIZE  # The number of items to send in a single request
        if not isinstance(self.chunk_size, int):
            raise ValueError(&#34;&#39;chunk_size&#39; %r must be an integer&#34; % chunk_size)
        if self.chunk_size &lt; 1:
            raise ValueError(&#34;&#39;chunk_size&#39; must be a positive number&#34;)
        if self.supported_from and protocol.version.build &lt; self.supported_from:
            raise NotImplementedError(
                &#39;%r is only supported on %r and later&#39; % (self.SERVICE_NAME, self.supported_from.fullname())
            )
        self.protocol = protocol
        # Allow a service to override the default protocol timeout. Useful for streaming services
        self.timeout = timeout
        # Controls whether the HTTP request should be streaming or fetch everything at once
        self.streaming = False
        # Streaming connection variables
        self._streaming_session = None
        self._streaming_response = None

    # The following two methods are the minimum required to be implemented by subclasses, but the name and number of
    # kwargs differs between services. Therefore, we cannot make these methods abstract.

    # @abc.abstractmethod
    # def call(self, **kwargs):
    #     &#34;&#34;&#34;Defines the arguments required by the service. Arguments are basic Python types or EWSElement objects.
    #     Returns either XML objects or EWSElement objects.
    #     &#34;&#34;&#34;&#34;
    #     pass

    # @abc.abstractmethod
    # def get_payload(self, **kwargs):
    #     &#34;&#34;&#34;Using the arguments from .call(), return the payload expected by the service, as an XML object. The XML
    #     object should consist of a SERVICE_NAME element and everything within that.
    #     &#34;&#34;&#34;
    #     pass

    def get(self, expect_result=True, **kwargs):
        &#34;&#34;&#34;Like .call(), but expects exactly one result from the server, or zero when expect_result=False, or either
        zero or one when expect_result=None. Returns either one object or None.

        :param expect_result: None, True, or False
        :param kwargs: Same as arguments for .call()
        :return: Same as .call(), but returns either None or exactly one item
        &#34;&#34;&#34;
        res = list(self.call(**kwargs))
        # Raise any errors
        for r in res:
            if isinstance(r, Exception):
                raise r
        if expect_result is None and not res:
            # Allow empty result
            return None
        if expect_result is False:
            if res:
                raise ValueError(&#39;Expected result length 0, but got %r&#39; % res)
            return None
        if len(res) != 1:
            raise ValueError(&#39;Expected result length 1, but got %r&#39; % res)
        return res[0]

    def parse(self, xml):
        &#34;&#34;&#34;Used mostly for testing, when we want to parse static XML data.&#34;&#34;&#34;
        resp = DummyResponse(url=None, headers=None, request_headers=None, content=xml)
        _, body = self._get_soap_parts(response=resp)
        return self._elems_to_objs(self._get_elements_in_response(response=self._get_soap_messages(body=body)))

    def _elems_to_objs(self, elems):
        &#34;&#34;&#34;Takes a generator of XML elements and exceptions. Returns the equivalent Python objects (or exceptions).&#34;&#34;&#34;
        raise NotImplementedError()

    @property
    def _version_hint(self):
        # We may be here due to version guessing in Protocol.version, so we can&#39;t use the self.protocol.version property
        return self.protocol.config.version

    @_version_hint.setter
    def _version_hint(self, value):
        self.protocol.config.version = value

    def _extra_headers(self, session):
        headers = {}
        if self.prefer_affinity:
            headers[&#39;X-PreferServerAffinity&#39;] = &#39;True&#39;
        for cookie in session.cookies:
            if cookie.name == &#39;X-BackEndCookie&#39;:
                headers[&#39;X-BackEndOverrideCookie&#39;] = cookie.value
        return headers

    @property
    def _account_to_impersonate(self):
        if isinstance(self.protocol.credentials, OAuth2Credentials):
            return self.protocol.credentials.identity
        return None

    @property
    def _timezone(self):
        return None

    def _response_generator(self, payload):
        &#34;&#34;&#34;Send the payload to the server, and return the response.

        :param payload: payload as an XML object
        :return: the response, as XML objects
        &#34;&#34;&#34;
        response = self._get_response_xml(payload=payload)
        if self.supports_paging:
            return (self._get_page(message) for message in response)
        return self._get_elements_in_response(response=response)

    def _chunked_get_elements(self, payload_func, items, **kwargs):
        &#34;&#34;&#34;Yield elements in a response. Like ._get_elements(), but chop items into suitable chunks and send multiple
        requests.

        :param payload_func: A reference to .payload()
        :param items: An iterable of items (messages, folders, etc.) to process
        :param kwargs: Same as arguments for .call(), except for the &#39;items&#39; argument
        :return: Same as ._get_elements()
        &#34;&#34;&#34;
        for i, chunk in enumerate(chunkify(items, self.chunk_size), start=1):
            log.debug(&#39;Processing chunk %s containing %s items&#39;, i, len(chunk))
            yield from self._get_elements(payload=payload_func(chunk, **kwargs))

    def stop_streaming(self):
        if self._streaming_response:
            self._streaming_response.close()  # Release memory
            self._streaming_response = None
        if self._streaming_session:
            self.protocol.release_session(self._streaming_session)
            self._streaming_session = None

    def _get_elements(self, payload):
        &#34;&#34;&#34;Send the payload to be sent and parsed. Handles and re-raise exceptions that are not meant to be returned
        to the caller as exception objects. Retry the request according to the retry policy.
        &#34;&#34;&#34;
        while True:
            try:
                # Create a generator over the response elements so exceptions in response elements are also raised
                # here and can be handled.
                yield from self._response_generator(payload=payload)
                return
            except ErrorServerBusy as e:
                self._handle_backoff(e)
                continue
            except KNOWN_EXCEPTIONS:
                # These are known and understood, and don&#39;t require a backtrace.
                raise
            except (ErrorTooManyObjectsOpened, ErrorTimeoutExpired) as e:
                # ErrorTooManyObjectsOpened means there are too many connections to the Exchange database. This is very
                # often a symptom of sending too many requests.
                #
                # ErrorTimeoutExpired can be caused by a busy server, or by overly large requests. Start by lowering the
                # session count. This is done by downstream code.
                if isinstance(e, ErrorTimeoutExpired) and self.protocol.session_pool_size &lt;= 1:
                    # We&#39;re already as low as we can go, so downstream cannot limit the session count to put less load
                    # on the server. We don&#39;t have a way of lowering the page size of requests from
                    # this part of the code yet. Let the user handle this.
                    raise e

                # Re-raise as an ErrorServerBusy with a default delay of 5 minutes
                raise ErrorServerBusy(&#39;Reraised from %s(%s)&#39; % (e.__class__.__name__, e))
            except Exception:
                # This may run from a thread pool, which obfuscates the stack trace. Print trace immediately.
                account = self.account if isinstance(self, EWSAccountService) else None
                log.warning(&#39;Account %s: Exception in _get_elements: %s&#39;, account, traceback.format_exc(20))
                raise
            finally:
                if self.streaming:
                    self.stop_streaming()

    def _get_response(self, payload, api_version):
        &#34;&#34;&#34;Send the actual HTTP request and get the response.&#34;&#34;&#34;
        session = self.protocol.get_session()
        self._streaming_session, self._streaming_response = None, None
        r, session = post_ratelimited(
            protocol=self.protocol,
            session=session,
            url=self.protocol.service_endpoint,
            headers=self._extra_headers(session),
            data=wrap(
                content=payload,
                api_version=api_version,
                account_to_impersonate=self._account_to_impersonate,
                timezone=self._timezone,
            ),
            allow_redirects=False,
            stream=self.streaming,
            timeout=self.timeout or self.protocol.TIMEOUT,
        )
        if self.streaming:
            # We con only release the session when we have fully consumed the response. Save session and response
            # objects for later.
            self._streaming_session, self._streaming_response = session, r
        else:
            self.protocol.release_session(session)
        return r

    @property
    def _api_versions_to_try(self):
        # Put the hint first in the list, and then all other versions except the hint, from newest to oldest
        return [self._version_hint.api_version] + [v for v in API_VERSIONS if v != self._version_hint.api_version]

    def _get_response_xml(self, payload, **parse_opts):
        &#34;&#34;&#34;Send the payload to the server and return relevant elements from the result. Several things happen here:
          * The payload is wrapped in SOAP headers and sent to the server
          * The Exchange API version is negotiated and stored in the protocol object
          * Connection errors are handled and possibly reraised as ErrorServerBusy
          * SOAP errors are raised
          * EWS errors are raised, or passed on to the caller

        :param payload: The request payload, as an XML object
        :return: A generator of XML objects or None if the service does not return a result
        &#34;&#34;&#34;
        # Microsoft really doesn&#39;t want to make our lives easy. The server may report one version in our initial version
        # guessing tango, but then the server may decide that any arbitrary legacy backend server may actually process
        # the request for an account. Prepare to handle version-related errors and set the server version per-account.
        log.debug(&#39;Calling service %s&#39;, self.SERVICE_NAME)
        for api_version in self._api_versions_to_try:
            log.debug(&#39;Trying API version %s&#39;, api_version)
            r = self._get_response(payload=payload, api_version=api_version)
            if self.streaming:
                # Let &#39;requests&#39; decode raw data automatically
                r.raw.decode_content = True
            try:
                header, body = self._get_soap_parts(response=r, **parse_opts)
            except Exception:
                r.close()  # Release memory
                raise
            # The body may contain error messages from Exchange, but we still want to collect version info
            if header is not None:
                self._update_api_version(api_version=api_version, header=header, **parse_opts)
            try:
                return self._get_soap_messages(body=body, **parse_opts)
            except (ErrorInvalidServerVersion, ErrorIncorrectSchemaVersion, ErrorInvalidRequest,
                    ErrorInvalidSchemaVersionForMailboxVersion):
                # The guessed server version is wrong. Try the next version
                log.debug(&#39;API version %s was invalid&#39;, api_version)
                continue
            except ErrorExceededConnectionCount as e:
                # This indicates that the connecting user has too many open TCP connections to the server. Decrease
                # our session pool size.
                try:
                    self.protocol.decrease_poolsize()
                    continue
                except SessionPoolMinSizeReached:
                    # We&#39;re already as low as we can go. Let the user handle this.
                    raise e
            finally:
                if not self.streaming:
                    # In streaming mode, we may not have accessed the raw stream yet. Caller must handle this.
                    r.close()  # Release memory

        raise self.NO_VALID_SERVER_VERSIONS(&#39;Tried versions %s but all were invalid&#39; % self._api_versions_to_try)

    def _handle_backoff(self, e):
        &#34;&#34;&#34;Take a request from the server to back off and checks the retry policy for what to do. Re-raise the
        exception if conditions are not met.

        :param e: An ErrorServerBusy instance
        :return:
        &#34;&#34;&#34;
        log.debug(&#39;Got ErrorServerBusy (back off %s seconds)&#39;, e.back_off)
        # ErrorServerBusy is very often a symptom of sending too many requests. Scale back connections if possible.
        try:
            self.protocol.decrease_poolsize()
        except SessionPoolMinSizeReached:
            pass
        if self.protocol.retry_policy.fail_fast:
            raise e
        self.protocol.retry_policy.back_off(e.back_off)
        # We&#39;ll warn about this later if we actually need to sleep

    def _update_api_version(self, api_version, header, **parse_opts):
        &#34;&#34;&#34;Parse the server version contained in SOAP headers and update the version hint stored by the caller, if
        necessary.
        &#34;&#34;&#34;
        try:
            head_version = Version.from_soap_header(requested_api_version=api_version, header=header)
        except TransportError as te:
            log.debug(&#39;Failed to update version info (%s)&#39;, te)
            return
        if self._version_hint == head_version:
            # Nothing to do
            return
        log.debug(&#39;Found new version (%s -&gt; %s)&#39;, self._version_hint, head_version)
        # The api_version that worked was different than our hint, or we never got a build version. Store the working
        # version.
        self._version_hint = head_version

    @classmethod
    def _response_tag(cls):
        &#34;&#34;&#34;Return the name of the element containing the service response.&#34;&#34;&#34;
        return &#39;{%s}%sResponse&#39; % (MNS, cls.SERVICE_NAME)

    @staticmethod
    def _response_messages_tag():
        &#34;&#34;&#34;Return the name of the element containing service response messages.&#34;&#34;&#34;
        return &#39;{%s}ResponseMessages&#39; % MNS

    @classmethod
    def _response_message_tag(cls):
        &#34;&#34;&#34;Return the name of the element of a single response message.&#34;&#34;&#34;
        return &#39;{%s}%sResponseMessage&#39; % (MNS, cls.SERVICE_NAME)

    @classmethod
    def _get_soap_parts(cls, response, **parse_opts):
        &#34;&#34;&#34;Split the SOAP response into its headers an body elements.&#34;&#34;&#34;
        try:
            root = to_xml(response.iter_content())
        except ParseError as e:
            raise SOAPError(&#39;Bad SOAP response: %s&#39; % e)
        header = root.find(&#39;{%s}Header&#39; % SOAPNS)
        if header is None:
            # This is normal when the response contains SOAP-level errors
            log.debug(&#39;No header in XML response&#39;)
        body = root.find(&#39;{%s}Body&#39; % SOAPNS)
        if body is None:
            raise MalformedResponseError(&#39;No Body element in SOAP response&#39;)
        return header, body

    def _get_soap_messages(self, body, **parse_opts):
        &#34;&#34;&#34;Return the elements in the response containing the response messages. Raises any SOAP exceptions.&#34;&#34;&#34;
        response = body.find(self._response_tag())
        if response is None:
            fault = body.find(&#39;{%s}Fault&#39; % SOAPNS)
            if fault is None:
                raise SOAPError(
                    &#39;Unknown SOAP response (expected %s or Fault): %s&#39; % (self._response_tag(), xml_to_str(body))
                )
            self._raise_soap_errors(fault=fault)  # Will throw SOAPError or custom EWS error
        response_messages = response.find(self._response_messages_tag())
        if response_messages is None:
            # Result isn&#39;t delivered in a list of FooResponseMessages, but directly in the FooResponse. Consumers expect
            # a list, so return a list
            return [response]
        return response_messages.findall(self._response_message_tag())

    @classmethod
    def _raise_soap_errors(cls, fault):
        &#34;&#34;&#34;Parse error messages contained in SOAP headers and raise as exceptions defined in this package.&#34;&#34;&#34;
        # Fault: See http://www.w3.org/TR/2000/NOTE-SOAP-20000508/#_Toc478383507
        faultcode = get_xml_attr(fault, &#39;faultcode&#39;)
        faultstring = get_xml_attr(fault, &#39;faultstring&#39;)
        faultactor = get_xml_attr(fault, &#39;faultactor&#39;)
        detail = fault.find(&#39;detail&#39;)
        if detail is not None:
            code, msg = None, &#39;&#39;
            if detail.find(&#39;{%s}ResponseCode&#39; % ENS) is not None:
                code = get_xml_attr(detail, &#39;{%s}ResponseCode&#39; % ENS).strip()
            if detail.find(&#39;{%s}Message&#39; % ENS) is not None:
                msg = get_xml_attr(detail, &#39;{%s}Message&#39; % ENS).strip()
            msg_xml = detail.find(&#39;{%s}MessageXml&#39; % TNS)  # Crazy. Here, it&#39;s in the TNS namespace
            if code == &#39;ErrorServerBusy&#39;:
                back_off = None
                try:
                    value = msg_xml.find(&#39;{%s}Value&#39; % TNS)
                    if value.get(&#39;Name&#39;) == &#39;BackOffMilliseconds&#39;:
                        back_off = int(value.text) / 1000.0  # Convert to seconds
                except (TypeError, AttributeError):
                    pass
                raise ErrorServerBusy(msg, back_off=back_off)
            if code == &#39;ErrorSchemaValidation&#39; and msg_xml is not None:
                violation = get_xml_attr(msg_xml, &#39;{%s}Violation&#39; % TNS)
                if violation is not None:
                    msg = &#39;%s %s&#39; % (msg, violation)
            try:
                raise vars(errors)[code](msg)
            except KeyError:
                detail = &#39;%s: code: %s msg: %s (%s)&#39; % (cls.SERVICE_NAME, code, msg, xml_to_str(detail))
        try:
            raise vars(errors)[faultcode](faultstring)
        except KeyError:
            pass
        raise SOAPError(&#39;SOAP error code: %s string: %s actor: %s detail: %s&#39; % (
            faultcode, faultstring, faultactor, detail))

    def _get_element_container(self, message, name=None):
        &#34;&#34;&#34;Return the XML element in a response element that contains the elements we want the service to return. For
        example, in a GetFolder response, &#39;message&#39; is the GetFolderResponseMessage element, and we return the &#39;Folders&#39;
        element:

        &lt;m:GetFolderResponseMessage ResponseClass=&#34;Success&#34;&gt;
          &lt;m:ResponseCode&gt;NoError&lt;/m:ResponseCode&gt;
          &lt;m:Folders&gt;
            &lt;t:Folder&gt;
              &lt;t:FolderId Id=&#34;AQApA=&#34; ChangeKey=&#34;AQAAAB&#34; /&gt;
              [...]
            &lt;/t:Folder&gt;
          &lt;/m:Folders&gt;
        &lt;/m:GetFolderResponseMessage&gt;

        Some service responses don&#39;t have a containing element for the returned elements (&#39;name&#39; is None). In
        that case, we return the &#39;SomeServiceResponseMessage&#39; element.

        If the response contains a warning or an error message, we raise the relevant exception, unless the error class
        is contained in WARNINGS_TO_CATCH_IN_RESPONSE or ERRORS_TO_CATCH_IN_RESPONSE, in which case we return the
        exception instance.
        &#34;&#34;&#34;
        # ResponseClass is an XML attribute of various SomeServiceResponseMessage elements: Possible values are:
        # Success, Warning, Error. See e.g.
        # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/finditemresponsemessage
        response_class = message.get(&#39;ResponseClass&#39;)
        # ResponseCode, MessageText: See
        # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/responsecode
        response_code = get_xml_attr(message, &#39;{%s}ResponseCode&#39; % MNS)
        if response_class == &#39;Success&#39; and response_code == &#39;NoError&#39;:
            if not name:
                return message
            container = message.find(name)
            if container is None:
                raise MalformedResponseError(&#39;No %s elements in ResponseMessage (%s)&#39; % (name, xml_to_str(message)))
            return container
        if response_code == &#39;NoError&#39;:
            return True
        # Raise any non-acceptable errors in the container, or return the container or the acceptable exception instance
        msg_text = get_xml_attr(message, &#39;{%s}MessageText&#39; % MNS)
        msg_xml = message.find(&#39;{%s}MessageXml&#39; % MNS)
        if response_class == &#39;Warning&#39;:
            try:
                raise self._get_exception(code=response_code, text=msg_text, msg_xml=msg_xml)
            except self.WARNINGS_TO_CATCH_IN_RESPONSE as e:
                return e
            except self.WARNINGS_TO_IGNORE_IN_RESPONSE as e:
                log.warning(str(e))
                container = message.find(name)
                if container is None:
                    raise MalformedResponseError(&#39;No %s elements in ResponseMessage (%s)&#39; % (name, xml_to_str(message)))
                return container
        # rspclass == &#39;Error&#39;, or &#39;Success&#39; and not &#39;NoError&#39;
        try:
            raise self._get_exception(code=response_code, text=msg_text, msg_xml=msg_xml)
        except self.ERRORS_TO_CATCH_IN_RESPONSE as e:
            return e

    @staticmethod
    def _get_exception(code, text, msg_xml):
        &#34;&#34;&#34;Parse error messages contained in EWS responses and raise as exceptions defined in this package.&#34;&#34;&#34;
        if not code:
            return TransportError(&#39;Empty ResponseCode in ResponseMessage (MessageText: %s, MessageXml: %s)&#39; % (
                text, msg_xml))
        if msg_xml is not None:
            # If this is an ErrorInvalidPropertyRequest error, the xml may contain a specific FieldURI
            for elem_cls in (FieldURI, IndexedFieldURI, ExtendedFieldURI, ExceptionFieldURI):
                elem = msg_xml.find(elem_cls.response_tag())
                if elem is not None:
                    field_uri = elem_cls.from_xml(elem, account=None)
                    text += &#39; (field: %s)&#39; % field_uri
                    break

            # If this is an ErrorInvalidValueForProperty error, the xml may contain the name and value of the property
            if code == &#39;ErrorInvalidValueForProperty&#39;:
                msg_parts = {}
                for elem in msg_xml.findall(&#39;{%s}Value&#39; % TNS):
                    key, val = elem.get(&#39;Name&#39;), elem.text
                    if key:
                        msg_parts[key] = val
                if msg_parts:
                    text += &#39; (%s)&#39; % &#39;, &#39;.join(&#39;%s: %s&#39; % (k, v) for k, v in msg_parts.items())

            # If this is an ErrorInternalServerError error, the xml may contain a more specific error code
            inner_code, inner_text = None, None
            for value_elem in msg_xml.findall(&#39;{%s}Value&#39; % TNS):
                name = value_elem.get(&#39;Name&#39;)
                if name == &#39;InnerErrorResponseCode&#39;:
                    inner_code = value_elem.text
                elif name == &#39;InnerErrorMessageText&#39;:
                    inner_text = value_elem.text
            if inner_code:
                try:
                    # Raise the error as the inner error code
                    return vars(errors)[inner_code](&#39;%s (raised from: %s(%r))&#39; % (inner_text, code, text))
                except KeyError:
                    # Inner code is unknown to us. Just append to the original text
                    text += &#39; (inner error: %s(%r))&#39; % (inner_code, inner_text)
        try:
            # Raise the error corresponding to the ResponseCode
            return vars(errors)[code](text)
        except KeyError:
            # Should not happen
            return TransportError(&#39;Unknown ResponseCode in ResponseMessage: %s (MessageText: %s, MessageXml: %s)&#39; % (
                    code, text, msg_xml))

    def _get_elements_in_response(self, response):
        &#34;&#34;&#34;Take a list of &#39;SomeServiceResponseMessage&#39; elements and return the elements in each response message that
        we want the service to return. With e.g. &#39;CreateItem&#39;, we get a list of &#39;CreateItemResponseMessage&#39; elements
        and return the &#39;Message&#39; elements.

        &lt;m:CreateItemResponseMessage ResponseClass=&#34;Success&#34;&gt;
          &lt;m:ResponseCode&gt;NoError&lt;/m:ResponseCode&gt;
          &lt;m:Items&gt;
            &lt;t:Message&gt;
              &lt;t:ItemId Id=&#34;AQApA=&#34; ChangeKey=&#34;AQAAAB&#34;/&gt;
            &lt;/t:Message&gt;
          &lt;/m:Items&gt;
        &lt;/m:CreateItemResponseMessage&gt;
        &lt;m:CreateItemResponseMessage ResponseClass=&#34;Success&#34;&gt;
          &lt;m:ResponseCode&gt;NoError&lt;/m:ResponseCode&gt;
          &lt;m:Items&gt;
            &lt;t:Message&gt;
              &lt;t:ItemId Id=&#34;AQApB=&#34; ChangeKey=&#34;AQAAAC&#34;/&gt;
            &lt;/t:Message&gt;
          &lt;/m:Items&gt;
        &lt;/m:CreateItemResponseMessage&gt;

        :param response: a list of &#39;SomeServiceResponseMessage&#39; XML objects
        :return: a generator of items as returned by &#39;_get_elements_in_container()
        &#34;&#34;&#34;
        for msg in response:
            container_or_exc = self._get_element_container(message=msg, name=self.element_container_name)
            if isinstance(container_or_exc, (bool, Exception)):
                yield container_or_exc
            else:
                for c in self._get_elements_in_container(container=container_or_exc):
                    yield c

    @classmethod
    def _get_elements_in_container(cls, container):
        &#34;&#34;&#34;Return a list of response elements from an XML response element container. With e.g.
        &#39;CreateItem&#39;, &#39;Items&#39; is the container element and we return the &#39;Message&#39; child elements:

          &lt;m:Items&gt;
            &lt;t:Message&gt;
              &lt;t:ItemId Id=&#34;AQApA=&#34; ChangeKey=&#34;AQAAAB&#34;/&gt;
            &lt;/t:Message&gt;
          &lt;/m:Items&gt;

        If the service does not return response elements, return True to indicate the status. Errors have already been
        raised.
        &#34;&#34;&#34;
        if cls.returns_elements:
            return list(container)
        return [True]

    def _get_elems_from_page(self, elem, max_items, total_item_count):
        container = elem.find(self.element_container_name)
        if container is None:
            raise MalformedResponseError(&#39;No %s elements in ResponseMessage (%s)&#39; % (
                self.element_container_name, xml_to_str(elem)))
        for e in self._get_elements_in_container(container=container):
            if max_items and total_item_count &gt;= max_items:
                # No need to continue. Break out of elements loop
                log.debug(&#34;&#39;max_items&#39; count reached (elements)&#34;)
                break
            yield e

    def _get_pages(self, payload_func, kwargs, expected_message_count):
        &#34;&#34;&#34;Request a page, or a list of pages if multiple collections are pages in a single request. Return each
        page.
        &#34;&#34;&#34;
        payload = payload_func(**kwargs)
        page_elems = list(self._get_elements(payload=payload))
        if len(page_elems) != expected_message_count:
            raise MalformedResponseError(
                &#34;Expected %s items in &#39;response&#39;, got %s&#34; % (expected_message_count, len(page_elems))
            )
        return page_elems

    @staticmethod
    def _get_next_offset(paging_infos):
        next_offsets = {p[&#39;next_offset&#39;] for p in paging_infos if p[&#39;next_offset&#39;] is not None}
        if not next_offsets:
            # Paging is done for all messages
            return None
        # We cannot guarantee that all messages that have a next_offset also have the *same* next_offset. This is
        # because the collections that we are iterating may change while iterating. We&#39;ll do our best but we cannot
        # guarantee 100% consistency when large collections are simultaneously being changed on the server.
        #
        # It&#39;s not possible to supply a per-folder offset when iterating multiple folders, so we&#39;ll just have to
        # choose something that is most likely to work. Select the lowest of all the values to at least make sure
        # we don&#39;t miss any items, although we may then get duplicates ¯\_(ツ)_/¯
        if len(next_offsets) &gt; 1:
            log.warning(&#39;Inconsistent next_offset values: %r. Using lowest value&#39;, next_offsets)
        return min(next_offsets)

    def _paged_call(self, payload_func, max_items, expected_message_count, **kwargs):
        &#34;&#34;&#34;Call a service that supports paging requests. Return a generator over all response items. Keeps track of
        all paging-related counters.
        &#34;&#34;&#34;
        paging_infos = [dict(item_count=0, next_offset=None) for _ in range(expected_message_count)]
        common_next_offset = kwargs[&#39;offset&#39;]
        total_item_count = 0
        while True:
            log.debug(&#39;Getting page at offset %s (max_items %s)&#39;, common_next_offset, max_items)
            kwargs[&#39;offset&#39;] = common_next_offset
            pages = self._get_pages(payload_func, kwargs, expected_message_count)
            for (page, next_offset), paging_info in zip(pages, paging_infos):
                paging_info[&#39;next_offset&#39;] = next_offset
                if isinstance(page, Exception):
                    yield page
                    continue
                if page is not None:
                    for elem in self._get_elems_from_page(page, max_items, total_item_count):
                        paging_info[&#39;item_count&#39;] += 1
                        total_item_count += 1
                        yield elem
                    if max_items and total_item_count &gt;= max_items:
                        # No need to continue. Break out of inner loop
                        log.debug(&#34;&#39;max_items&#39; count reached (inner)&#34;)
                        break
                if not paging_info[&#39;next_offset&#39;]:
                    # Paging is done for this message
                    continue
                # Check sanity of paging offsets, but don&#39;t fail. When we are iterating huge collections that take a
                # long time to complete, the collection may change while we are iterating. This can affect the
                # &#39;next_offset&#39; value and make it inconsistent with the number of already collected items.
                # We may have a mismatch if we stopped early due to reaching &#39;max_items&#39;.
                if paging_info[&#39;next_offset&#39;] != paging_info[&#39;item_count&#39;] and (
                    not max_items or total_item_count &lt; max_items
                ):
                    log.warning(&#39;Unexpected next offset: %s -&gt; %s. Maybe the server-side collection has changed?&#39;,
                                paging_info[&#39;item_count&#39;], paging_info[&#39;next_offset&#39;])
            # Also break out of outer loop
            if max_items and total_item_count &gt;= max_items:
                log.debug(&#34;&#39;max_items&#39; count reached (outer)&#34;)
                break
            common_next_offset = self._get_next_offset(paging_infos)
            if common_next_offset is None:
                # Paging is done for all messages
                break

    @staticmethod
    def _get_paging_values(elem):
        &#34;&#34;&#34;Read paging information from the paging container element.&#34;&#34;&#34;
        is_last_page = elem.get(&#39;IncludesLastItemInRange&#39;).lower() in (&#39;true&#39;, &#39;0&#39;)
        offset = elem.get(&#39;IndexedPagingOffset&#39;)
        if offset is None and not is_last_page:
            log.debug(&#34;Not last page in range, but Exchange didn&#39;t send a page offset. Assuming first page&#34;)
            offset = &#39;1&#39;
        next_offset = None if is_last_page else int(offset)
        item_count = int(elem.get(&#39;TotalItemsInView&#39;))
        if not item_count and next_offset is not None:
            raise ValueError(&#34;Expected empty &#39;next_offset&#39; when &#39;item_count&#39; is 0&#34;)
        log.debug(&#39;Got page with next offset %s (last_page %s)&#39;, next_offset, is_last_page)
        return item_count, next_offset

    def _get_page(self, message):
        &#34;&#34;&#34;Get a single page from a request message, and return the container and next offset.&#34;&#34;&#34;
        paging_elem = self._get_element_container(message=message, name=self.paging_container_name)
        if isinstance(paging_elem, Exception):
            return paging_elem, None
        item_count, next_offset = self._get_paging_values(paging_elem)
        if not item_count:
            paging_elem = None
        return paging_elem, next_offset


class EWSAccountService(EWSService, metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Base class for services that act on items concerning a single Mailbox on the server.&#34;&#34;&#34;

    NO_VALID_SERVER_VERSIONS = ErrorInvalidSchemaVersionForMailboxVersion

    def __init__(self, *args, **kwargs):
        self.account = kwargs.pop(&#39;account&#39;)
        kwargs[&#39;protocol&#39;] = self.account.protocol
        super().__init__(*args, **kwargs)

    @property
    def _version_hint(self):
        return self.account.version

    @_version_hint.setter
    def _version_hint(self, value):
        self.account.version = value

    def _extra_headers(self, *args, **kwargs):
        headers = super()._extra_headers(*args, **kwargs)
        # See
        # https://blogs.msdn.microsoft.com/webdav_101/2015/05/11/best-practices-ews-authentication-and-access-issues/
        headers[&#39;X-AnchorMailbox&#39;] = self.account.primary_smtp_address
        return headers

    @property
    def _account_to_impersonate(self):
        if self.account.access_type == IMPERSONATION:
            return self.account.identity
        return None

    @property
    def _timezone(self):
        return self.account.default_timezone


def to_item_id(item, item_cls, version):
    # Coerce a tuple, dict or object to an &#39;item_cls&#39; instance. Used to create [Parent][Item|Folder]Id instances from a
    # variety of input.
    if isinstance(item, item_cls):
        # Allow any subclass of item_cls, e.g. OccurrenceItemId when ItemId is passed
        return item
    from ..folders import BaseFolder
    from ..items import BaseItem
    if isinstance(item, (BaseFolder, BaseItem)):
        return item.to_id_xml(version=version)
    if isinstance(item, (tuple, list)):
        return item_cls(*item)
    if isinstance(item, dict):
        return item_cls(**item)
    return item_cls(item.id, item.changekey)


def create_shape_element(tag, shape, additional_fields, version):
    shape_elem = create_element(tag)
    add_xml_child(shape_elem, &#39;t:BaseShape&#39;, shape)
    if additional_fields:
        additional_properties = create_element(&#39;t:AdditionalProperties&#39;)
        expanded_fields = chain(*(f.expand(version=version) for f in additional_fields))
        # &#39;path&#39; is insufficient to consistently sort additional properties. For example, we have both
        # &#39;contacts:Companies&#39; and &#39;task:Companies&#39; with path &#39;companies&#39;. Sort by both &#39;field_uri&#39; and &#39;path&#39;.
        # Extended properties do not have a &#39;field_uri&#39; value.
        set_xml_value(additional_properties, sorted(
            expanded_fields,
            key=lambda f: (getattr(f.field, &#39;field_uri&#39;, &#39;&#39;), f.path)
        ), version=version)
        shape_elem.append(additional_properties)
    return shape_elem


def create_folder_ids_element(tag, folders, version):
    from ..folders import FolderId
    folder_ids = create_element(tag)
    for folder in folders:
        if not isinstance(folder, FolderId):
            folder = to_item_id(folder, FolderId, version=version)
        set_xml_value(folder_ids, folder, version=version)
    if not len(folder_ids):
        raise ValueError(&#39;&#34;folders&#34; must not be empty&#39;)
    return folder_ids


def create_item_ids_element(items, version, tag=&#39;m:ItemIds&#39;):
    item_ids = create_element(tag)
    for item in items:
        set_xml_value(item_ids, to_item_id(item, ItemId, version=version), version=version)
    if not len(item_ids):
        raise ValueError(&#39;&#34;items&#34; must not be empty&#39;)
    return item_ids


def create_attachment_ids_element(items, version):
    from ..attachments import AttachmentId
    attachment_ids = create_element(&#39;m:AttachmentIds&#39;)
    for item in items:
        attachment_id = item if isinstance(item, AttachmentId) else AttachmentId(id=item)
        set_xml_value(attachment_ids, attachment_id, version=version)
    if not len(attachment_ids):
        raise ValueError(&#39;&#34;items&#34; must not be empty&#39;)
    return attachment_ids


def parse_folder_elem(elem, folder, account):
    from ..folders import BaseFolder, Folder, DistinguishedFolderId, RootOfHierarchy
    if isinstance(elem, Exception):
        return elem
    if isinstance(folder, RootOfHierarchy):
        f = folder.from_xml(elem=elem, account=folder.account)
    elif isinstance(folder, Folder):
        f = folder.from_xml_with_root(elem=elem, root=folder.root)
    elif isinstance(folder, DistinguishedFolderId):
        # We don&#39;t know the root, so assume account.root.
        folder_cls = None
        for cls in account.root.WELLKNOWN_FOLDERS:
            if cls.DISTINGUISHED_FOLDER_ID == folder.id:
                folder_cls = cls
                break
        if not folder_cls:
            raise ValueError(&#39;Unknown distinguished folder ID: %s&#39; % folder.id)
        f = folder_cls.from_xml_with_root(elem=elem, root=account.root)
    else:
        # &#39;folder&#39; is a generic FolderId instance. We don&#39;t know the root so assume account.root.
        f = Folder.from_xml_with_root(elem=elem, root=account.root)
    if isinstance(folder, DistinguishedFolderId):
        f.is_distinguished = True
    elif isinstance(folder, BaseFolder) and folder.is_distinguished:
        f.is_distinguished = True
    return f</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="exchangelib.services.common.create_attachment_ids_element"><code class="name flex">
<span>def <span class="ident">create_attachment_ids_element</span></span>(<span>items, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_attachment_ids_element(items, version):
    from ..attachments import AttachmentId
    attachment_ids = create_element(&#39;m:AttachmentIds&#39;)
    for item in items:
        attachment_id = item if isinstance(item, AttachmentId) else AttachmentId(id=item)
        set_xml_value(attachment_ids, attachment_id, version=version)
    if not len(attachment_ids):
        raise ValueError(&#39;&#34;items&#34; must not be empty&#39;)
    return attachment_ids</code></pre>
</details>
</dd>
<dt id="exchangelib.services.common.create_folder_ids_element"><code class="name flex">
<span>def <span class="ident">create_folder_ids_element</span></span>(<span>tag, folders, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_folder_ids_element(tag, folders, version):
    from ..folders import FolderId
    folder_ids = create_element(tag)
    for folder in folders:
        if not isinstance(folder, FolderId):
            folder = to_item_id(folder, FolderId, version=version)
        set_xml_value(folder_ids, folder, version=version)
    if not len(folder_ids):
        raise ValueError(&#39;&#34;folders&#34; must not be empty&#39;)
    return folder_ids</code></pre>
</details>
</dd>
<dt id="exchangelib.services.common.create_item_ids_element"><code class="name flex">
<span>def <span class="ident">create_item_ids_element</span></span>(<span>items, version, tag='m:ItemIds')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_item_ids_element(items, version, tag=&#39;m:ItemIds&#39;):
    item_ids = create_element(tag)
    for item in items:
        set_xml_value(item_ids, to_item_id(item, ItemId, version=version), version=version)
    if not len(item_ids):
        raise ValueError(&#39;&#34;items&#34; must not be empty&#39;)
    return item_ids</code></pre>
</details>
</dd>
<dt id="exchangelib.services.common.create_shape_element"><code class="name flex">
<span>def <span class="ident">create_shape_element</span></span>(<span>tag, shape, additional_fields, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_shape_element(tag, shape, additional_fields, version):
    shape_elem = create_element(tag)
    add_xml_child(shape_elem, &#39;t:BaseShape&#39;, shape)
    if additional_fields:
        additional_properties = create_element(&#39;t:AdditionalProperties&#39;)
        expanded_fields = chain(*(f.expand(version=version) for f in additional_fields))
        # &#39;path&#39; is insufficient to consistently sort additional properties. For example, we have both
        # &#39;contacts:Companies&#39; and &#39;task:Companies&#39; with path &#39;companies&#39;. Sort by both &#39;field_uri&#39; and &#39;path&#39;.
        # Extended properties do not have a &#39;field_uri&#39; value.
        set_xml_value(additional_properties, sorted(
            expanded_fields,
            key=lambda f: (getattr(f.field, &#39;field_uri&#39;, &#39;&#39;), f.path)
        ), version=version)
        shape_elem.append(additional_properties)
    return shape_elem</code></pre>
</details>
</dd>
<dt id="exchangelib.services.common.parse_folder_elem"><code class="name flex">
<span>def <span class="ident">parse_folder_elem</span></span>(<span>elem, folder, account)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse_folder_elem(elem, folder, account):
    from ..folders import BaseFolder, Folder, DistinguishedFolderId, RootOfHierarchy
    if isinstance(elem, Exception):
        return elem
    if isinstance(folder, RootOfHierarchy):
        f = folder.from_xml(elem=elem, account=folder.account)
    elif isinstance(folder, Folder):
        f = folder.from_xml_with_root(elem=elem, root=folder.root)
    elif isinstance(folder, DistinguishedFolderId):
        # We don&#39;t know the root, so assume account.root.
        folder_cls = None
        for cls in account.root.WELLKNOWN_FOLDERS:
            if cls.DISTINGUISHED_FOLDER_ID == folder.id:
                folder_cls = cls
                break
        if not folder_cls:
            raise ValueError(&#39;Unknown distinguished folder ID: %s&#39; % folder.id)
        f = folder_cls.from_xml_with_root(elem=elem, root=account.root)
    else:
        # &#39;folder&#39; is a generic FolderId instance. We don&#39;t know the root so assume account.root.
        f = Folder.from_xml_with_root(elem=elem, root=account.root)
    if isinstance(folder, DistinguishedFolderId):
        f.is_distinguished = True
    elif isinstance(folder, BaseFolder) and folder.is_distinguished:
        f.is_distinguished = True
    return f</code></pre>
</details>
</dd>
<dt id="exchangelib.services.common.to_item_id"><code class="name flex">
<span>def <span class="ident">to_item_id</span></span>(<span>item, item_cls, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_item_id(item, item_cls, version):
    # Coerce a tuple, dict or object to an &#39;item_cls&#39; instance. Used to create [Parent][Item|Folder]Id instances from a
    # variety of input.
    if isinstance(item, item_cls):
        # Allow any subclass of item_cls, e.g. OccurrenceItemId when ItemId is passed
        return item
    from ..folders import BaseFolder
    from ..items import BaseItem
    if isinstance(item, (BaseFolder, BaseItem)):
        return item.to_id_xml(version=version)
    if isinstance(item, (tuple, list)):
        return item_cls(*item)
    if isinstance(item, dict):
        return item_cls(**item)
    return item_cls(item.id, item.changekey)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exchangelib.services.common.EWSAccountService"><code class="flex name class">
<span>class <span class="ident">EWSAccountService</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for services that act on items concerning a single Mailbox on the server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EWSAccountService(EWSService, metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Base class for services that act on items concerning a single Mailbox on the server.&#34;&#34;&#34;

    NO_VALID_SERVER_VERSIONS = ErrorInvalidSchemaVersionForMailboxVersion

    def __init__(self, *args, **kwargs):
        self.account = kwargs.pop(&#39;account&#39;)
        kwargs[&#39;protocol&#39;] = self.account.protocol
        super().__init__(*args, **kwargs)

    @property
    def _version_hint(self):
        return self.account.version

    @_version_hint.setter
    def _version_hint(self, value):
        self.account.version = value

    def _extra_headers(self, *args, **kwargs):
        headers = super()._extra_headers(*args, **kwargs)
        # See
        # https://blogs.msdn.microsoft.com/webdav_101/2015/05/11/best-practices-ews-authentication-and-access-issues/
        headers[&#39;X-AnchorMailbox&#39;] = self.account.primary_smtp_address
        return headers

    @property
    def _account_to_impersonate(self):
        if self.account.access_type == IMPERSONATION:
            return self.account.identity
        return None

    @property
    def _timezone(self):
        return self.account.default_timezone</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSService" href="#exchangelib.services.common.EWSService">EWSService</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.services.archive_item.ArchiveItem" href="archive_item.html#exchangelib.services.archive_item.ArchiveItem">ArchiveItem</a></li>
<li><a title="exchangelib.services.create_attachment.CreateAttachment" href="create_attachment.html#exchangelib.services.create_attachment.CreateAttachment">CreateAttachment</a></li>
<li><a title="exchangelib.services.create_folder.CreateFolder" href="create_folder.html#exchangelib.services.create_folder.CreateFolder">CreateFolder</a></li>
<li><a title="exchangelib.services.create_item.CreateItem" href="create_item.html#exchangelib.services.create_item.CreateItem">CreateItem</a></li>
<li><a title="exchangelib.services.create_user_configuration.CreateUserConfiguration" href="create_user_configuration.html#exchangelib.services.create_user_configuration.CreateUserConfiguration">CreateUserConfiguration</a></li>
<li><a title="exchangelib.services.delete_attachment.DeleteAttachment" href="delete_attachment.html#exchangelib.services.delete_attachment.DeleteAttachment">DeleteAttachment</a></li>
<li><a title="exchangelib.services.delete_folder.DeleteFolder" href="delete_folder.html#exchangelib.services.delete_folder.DeleteFolder">DeleteFolder</a></li>
<li><a title="exchangelib.services.delete_item.DeleteItem" href="delete_item.html#exchangelib.services.delete_item.DeleteItem">DeleteItem</a></li>
<li><a title="exchangelib.services.delete_user_configuration.DeleteUserConfiguration" href="delete_user_configuration.html#exchangelib.services.delete_user_configuration.DeleteUserConfiguration">DeleteUserConfiguration</a></li>
<li><a title="exchangelib.services.empty_folder.EmptyFolder" href="empty_folder.html#exchangelib.services.empty_folder.EmptyFolder">EmptyFolder</a></li>
<li><a title="exchangelib.services.export_items.ExportItems" href="export_items.html#exchangelib.services.export_items.ExportItems">ExportItems</a></li>
<li><a title="exchangelib.services.find_folder.FindFolder" href="find_folder.html#exchangelib.services.find_folder.FindFolder">FindFolder</a></li>
<li><a title="exchangelib.services.find_item.FindItem" href="find_item.html#exchangelib.services.find_item.FindItem">FindItem</a></li>
<li><a title="exchangelib.services.find_people.FindPeople" href="find_people.html#exchangelib.services.find_people.FindPeople">FindPeople</a></li>
<li><a title="exchangelib.services.get_attachment.GetAttachment" href="get_attachment.html#exchangelib.services.get_attachment.GetAttachment">GetAttachment</a></li>
<li><a title="exchangelib.services.get_delegate.GetDelegate" href="get_delegate.html#exchangelib.services.get_delegate.GetDelegate">GetDelegate</a></li>
<li><a title="exchangelib.services.get_events.GetEvents" href="get_events.html#exchangelib.services.get_events.GetEvents">GetEvents</a></li>
<li><a title="exchangelib.services.get_folder.GetFolder" href="get_folder.html#exchangelib.services.get_folder.GetFolder">GetFolder</a></li>
<li><a title="exchangelib.services.get_item.GetItem" href="get_item.html#exchangelib.services.get_item.GetItem">GetItem</a></li>
<li><a title="exchangelib.services.get_persona.GetPersona" href="get_persona.html#exchangelib.services.get_persona.GetPersona">GetPersona</a></li>
<li><a title="exchangelib.services.get_streaming_events.GetStreamingEvents" href="get_streaming_events.html#exchangelib.services.get_streaming_events.GetStreamingEvents">GetStreamingEvents</a></li>
<li><a title="exchangelib.services.get_user_configuration.GetUserConfiguration" href="get_user_configuration.html#exchangelib.services.get_user_configuration.GetUserConfiguration">GetUserConfiguration</a></li>
<li><a title="exchangelib.services.get_user_oof_settings.GetUserOofSettings" href="get_user_oof_settings.html#exchangelib.services.get_user_oof_settings.GetUserOofSettings">GetUserOofSettings</a></li>
<li><a title="exchangelib.services.mark_as_junk.MarkAsJunk" href="mark_as_junk.html#exchangelib.services.mark_as_junk.MarkAsJunk">MarkAsJunk</a></li>
<li><a title="exchangelib.services.move_folder.MoveFolder" href="move_folder.html#exchangelib.services.move_folder.MoveFolder">MoveFolder</a></li>
<li><a title="exchangelib.services.move_item.MoveItem" href="move_item.html#exchangelib.services.move_item.MoveItem">MoveItem</a></li>
<li><a title="exchangelib.services.send_item.SendItem" href="send_item.html#exchangelib.services.send_item.SendItem">SendItem</a></li>
<li><a title="exchangelib.services.set_user_oof_settings.SetUserOofSettings" href="set_user_oof_settings.html#exchangelib.services.set_user_oof_settings.SetUserOofSettings">SetUserOofSettings</a></li>
<li><a title="exchangelib.services.subscribe.Subscribe" href="subscribe.html#exchangelib.services.subscribe.Subscribe">Subscribe</a></li>
<li><a title="exchangelib.services.sync_folder_hierarchy.SyncFolder" href="sync_folder_hierarchy.html#exchangelib.services.sync_folder_hierarchy.SyncFolder">SyncFolder</a></li>
<li><a title="exchangelib.services.unsubscribe.Unsubscribe" href="unsubscribe.html#exchangelib.services.unsubscribe.Unsubscribe">Unsubscribe</a></li>
<li><a title="exchangelib.services.update_folder.UpdateFolder" href="update_folder.html#exchangelib.services.update_folder.UpdateFolder">UpdateFolder</a></li>
<li><a title="exchangelib.services.update_item.UpdateItem" href="update_item.html#exchangelib.services.update_item.UpdateItem">UpdateItem</a></li>
<li><a title="exchangelib.services.update_user_configuration.UpdateUserConfiguration" href="update_user_configuration.html#exchangelib.services.update_user_configuration.UpdateUserConfiguration">UpdateUserConfiguration</a></li>
<li><a title="exchangelib.services.upload_items.UploadItems" href="upload_items.html#exchangelib.services.upload_items.UploadItems">UploadItems</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.services.common.EWSService" href="#exchangelib.services.common.EWSService">EWSService</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.services.common.EWSService.NO_VALID_SERVER_VERSIONS" href="#exchangelib.services.common.EWSService.NO_VALID_SERVER_VERSIONS">NO_VALID_SERVER_VERSIONS</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE" href="#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.get" href="#exchangelib.services.common.EWSService.get">get</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.parse" href="#exchangelib.services.common.EWSService.parse">parse</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.services.common.EWSService"><code class="flex name class">
<span>class <span class="ident">EWSService</span></span>
<span>(</span><span>protocol, chunk_size=None, timeout=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Base class for all EWS services.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EWSService(metaclass=abc.ABCMeta):
    &#34;&#34;&#34;Base class for all EWS services.&#34;&#34;&#34;

    SERVICE_NAME = None  # The name of the SOAP service
    element_container_name = None  # The name of the XML element wrapping the collection of returned items
    paging_container_name = None  # The name of the element that contains paging information and the paged results
    returns_elements = True  # If False, the service does not return response elements, just the RsponseCode status
    # Return exception instance instead of raising exceptions for the following errors when contained in an element
    ERRORS_TO_CATCH_IN_RESPONSE = (
        EWSWarning, ErrorCannotDeleteObject, ErrorInvalidChangeKey, ErrorItemNotFound, ErrorItemSave,
        ErrorInvalidIdMalformed, ErrorMessageSizeExceeded, ErrorCannotDeleteTaskOccurrence,
        ErrorMimeContentConversionFailed, ErrorRecurrenceHasNoOccurrence, ErrorCorruptData
    )
    # Similarly, define the warnings we want to return unraised
    WARNINGS_TO_CATCH_IN_RESPONSE = ErrorBatchProcessingStopped
    # Define the warnings we want to ignore, to let response processing proceed
    WARNINGS_TO_IGNORE_IN_RESPONSE = ()
    # The exception type to raise when all attempted API versions failed
    NO_VALID_SERVER_VERSIONS = ErrorInvalidServerVersion
    # Marks the version from which the service was introduced
    supported_from = None
    # Marks services that support paging of requested items
    supports_paging = False
    # Marks services that need affinity to the backend server
    prefer_affinity = False

    def __init__(self, protocol, chunk_size=None, timeout=None):
        self.chunk_size = chunk_size or CHUNK_SIZE  # The number of items to send in a single request
        if not isinstance(self.chunk_size, int):
            raise ValueError(&#34;&#39;chunk_size&#39; %r must be an integer&#34; % chunk_size)
        if self.chunk_size &lt; 1:
            raise ValueError(&#34;&#39;chunk_size&#39; must be a positive number&#34;)
        if self.supported_from and protocol.version.build &lt; self.supported_from:
            raise NotImplementedError(
                &#39;%r is only supported on %r and later&#39; % (self.SERVICE_NAME, self.supported_from.fullname())
            )
        self.protocol = protocol
        # Allow a service to override the default protocol timeout. Useful for streaming services
        self.timeout = timeout
        # Controls whether the HTTP request should be streaming or fetch everything at once
        self.streaming = False
        # Streaming connection variables
        self._streaming_session = None
        self._streaming_response = None

    # The following two methods are the minimum required to be implemented by subclasses, but the name and number of
    # kwargs differs between services. Therefore, we cannot make these methods abstract.

    # @abc.abstractmethod
    # def call(self, **kwargs):
    #     &#34;&#34;&#34;Defines the arguments required by the service. Arguments are basic Python types or EWSElement objects.
    #     Returns either XML objects or EWSElement objects.
    #     &#34;&#34;&#34;&#34;
    #     pass

    # @abc.abstractmethod
    # def get_payload(self, **kwargs):
    #     &#34;&#34;&#34;Using the arguments from .call(), return the payload expected by the service, as an XML object. The XML
    #     object should consist of a SERVICE_NAME element and everything within that.
    #     &#34;&#34;&#34;
    #     pass

    def get(self, expect_result=True, **kwargs):
        &#34;&#34;&#34;Like .call(), but expects exactly one result from the server, or zero when expect_result=False, or either
        zero or one when expect_result=None. Returns either one object or None.

        :param expect_result: None, True, or False
        :param kwargs: Same as arguments for .call()
        :return: Same as .call(), but returns either None or exactly one item
        &#34;&#34;&#34;
        res = list(self.call(**kwargs))
        # Raise any errors
        for r in res:
            if isinstance(r, Exception):
                raise r
        if expect_result is None and not res:
            # Allow empty result
            return None
        if expect_result is False:
            if res:
                raise ValueError(&#39;Expected result length 0, but got %r&#39; % res)
            return None
        if len(res) != 1:
            raise ValueError(&#39;Expected result length 1, but got %r&#39; % res)
        return res[0]

    def parse(self, xml):
        &#34;&#34;&#34;Used mostly for testing, when we want to parse static XML data.&#34;&#34;&#34;
        resp = DummyResponse(url=None, headers=None, request_headers=None, content=xml)
        _, body = self._get_soap_parts(response=resp)
        return self._elems_to_objs(self._get_elements_in_response(response=self._get_soap_messages(body=body)))

    def _elems_to_objs(self, elems):
        &#34;&#34;&#34;Takes a generator of XML elements and exceptions. Returns the equivalent Python objects (or exceptions).&#34;&#34;&#34;
        raise NotImplementedError()

    @property
    def _version_hint(self):
        # We may be here due to version guessing in Protocol.version, so we can&#39;t use the self.protocol.version property
        return self.protocol.config.version

    @_version_hint.setter
    def _version_hint(self, value):
        self.protocol.config.version = value

    def _extra_headers(self, session):
        headers = {}
        if self.prefer_affinity:
            headers[&#39;X-PreferServerAffinity&#39;] = &#39;True&#39;
        for cookie in session.cookies:
            if cookie.name == &#39;X-BackEndCookie&#39;:
                headers[&#39;X-BackEndOverrideCookie&#39;] = cookie.value
        return headers

    @property
    def _account_to_impersonate(self):
        if isinstance(self.protocol.credentials, OAuth2Credentials):
            return self.protocol.credentials.identity
        return None

    @property
    def _timezone(self):
        return None

    def _response_generator(self, payload):
        &#34;&#34;&#34;Send the payload to the server, and return the response.

        :param payload: payload as an XML object
        :return: the response, as XML objects
        &#34;&#34;&#34;
        response = self._get_response_xml(payload=payload)
        if self.supports_paging:
            return (self._get_page(message) for message in response)
        return self._get_elements_in_response(response=response)

    def _chunked_get_elements(self, payload_func, items, **kwargs):
        &#34;&#34;&#34;Yield elements in a response. Like ._get_elements(), but chop items into suitable chunks and send multiple
        requests.

        :param payload_func: A reference to .payload()
        :param items: An iterable of items (messages, folders, etc.) to process
        :param kwargs: Same as arguments for .call(), except for the &#39;items&#39; argument
        :return: Same as ._get_elements()
        &#34;&#34;&#34;
        for i, chunk in enumerate(chunkify(items, self.chunk_size), start=1):
            log.debug(&#39;Processing chunk %s containing %s items&#39;, i, len(chunk))
            yield from self._get_elements(payload=payload_func(chunk, **kwargs))

    def stop_streaming(self):
        if self._streaming_response:
            self._streaming_response.close()  # Release memory
            self._streaming_response = None
        if self._streaming_session:
            self.protocol.release_session(self._streaming_session)
            self._streaming_session = None

    def _get_elements(self, payload):
        &#34;&#34;&#34;Send the payload to be sent and parsed. Handles and re-raise exceptions that are not meant to be returned
        to the caller as exception objects. Retry the request according to the retry policy.
        &#34;&#34;&#34;
        while True:
            try:
                # Create a generator over the response elements so exceptions in response elements are also raised
                # here and can be handled.
                yield from self._response_generator(payload=payload)
                return
            except ErrorServerBusy as e:
                self._handle_backoff(e)
                continue
            except KNOWN_EXCEPTIONS:
                # These are known and understood, and don&#39;t require a backtrace.
                raise
            except (ErrorTooManyObjectsOpened, ErrorTimeoutExpired) as e:
                # ErrorTooManyObjectsOpened means there are too many connections to the Exchange database. This is very
                # often a symptom of sending too many requests.
                #
                # ErrorTimeoutExpired can be caused by a busy server, or by overly large requests. Start by lowering the
                # session count. This is done by downstream code.
                if isinstance(e, ErrorTimeoutExpired) and self.protocol.session_pool_size &lt;= 1:
                    # We&#39;re already as low as we can go, so downstream cannot limit the session count to put less load
                    # on the server. We don&#39;t have a way of lowering the page size of requests from
                    # this part of the code yet. Let the user handle this.
                    raise e

                # Re-raise as an ErrorServerBusy with a default delay of 5 minutes
                raise ErrorServerBusy(&#39;Reraised from %s(%s)&#39; % (e.__class__.__name__, e))
            except Exception:
                # This may run from a thread pool, which obfuscates the stack trace. Print trace immediately.
                account = self.account if isinstance(self, EWSAccountService) else None
                log.warning(&#39;Account %s: Exception in _get_elements: %s&#39;, account, traceback.format_exc(20))
                raise
            finally:
                if self.streaming:
                    self.stop_streaming()

    def _get_response(self, payload, api_version):
        &#34;&#34;&#34;Send the actual HTTP request and get the response.&#34;&#34;&#34;
        session = self.protocol.get_session()
        self._streaming_session, self._streaming_response = None, None
        r, session = post_ratelimited(
            protocol=self.protocol,
            session=session,
            url=self.protocol.service_endpoint,
            headers=self._extra_headers(session),
            data=wrap(
                content=payload,
                api_version=api_version,
                account_to_impersonate=self._account_to_impersonate,
                timezone=self._timezone,
            ),
            allow_redirects=False,
            stream=self.streaming,
            timeout=self.timeout or self.protocol.TIMEOUT,
        )
        if self.streaming:
            # We con only release the session when we have fully consumed the response. Save session and response
            # objects for later.
            self._streaming_session, self._streaming_response = session, r
        else:
            self.protocol.release_session(session)
        return r

    @property
    def _api_versions_to_try(self):
        # Put the hint first in the list, and then all other versions except the hint, from newest to oldest
        return [self._version_hint.api_version] + [v for v in API_VERSIONS if v != self._version_hint.api_version]

    def _get_response_xml(self, payload, **parse_opts):
        &#34;&#34;&#34;Send the payload to the server and return relevant elements from the result. Several things happen here:
          * The payload is wrapped in SOAP headers and sent to the server
          * The Exchange API version is negotiated and stored in the protocol object
          * Connection errors are handled and possibly reraised as ErrorServerBusy
          * SOAP errors are raised
          * EWS errors are raised, or passed on to the caller

        :param payload: The request payload, as an XML object
        :return: A generator of XML objects or None if the service does not return a result
        &#34;&#34;&#34;
        # Microsoft really doesn&#39;t want to make our lives easy. The server may report one version in our initial version
        # guessing tango, but then the server may decide that any arbitrary legacy backend server may actually process
        # the request for an account. Prepare to handle version-related errors and set the server version per-account.
        log.debug(&#39;Calling service %s&#39;, self.SERVICE_NAME)
        for api_version in self._api_versions_to_try:
            log.debug(&#39;Trying API version %s&#39;, api_version)
            r = self._get_response(payload=payload, api_version=api_version)
            if self.streaming:
                # Let &#39;requests&#39; decode raw data automatically
                r.raw.decode_content = True
            try:
                header, body = self._get_soap_parts(response=r, **parse_opts)
            except Exception:
                r.close()  # Release memory
                raise
            # The body may contain error messages from Exchange, but we still want to collect version info
            if header is not None:
                self._update_api_version(api_version=api_version, header=header, **parse_opts)
            try:
                return self._get_soap_messages(body=body, **parse_opts)
            except (ErrorInvalidServerVersion, ErrorIncorrectSchemaVersion, ErrorInvalidRequest,
                    ErrorInvalidSchemaVersionForMailboxVersion):
                # The guessed server version is wrong. Try the next version
                log.debug(&#39;API version %s was invalid&#39;, api_version)
                continue
            except ErrorExceededConnectionCount as e:
                # This indicates that the connecting user has too many open TCP connections to the server. Decrease
                # our session pool size.
                try:
                    self.protocol.decrease_poolsize()
                    continue
                except SessionPoolMinSizeReached:
                    # We&#39;re already as low as we can go. Let the user handle this.
                    raise e
            finally:
                if not self.streaming:
                    # In streaming mode, we may not have accessed the raw stream yet. Caller must handle this.
                    r.close()  # Release memory

        raise self.NO_VALID_SERVER_VERSIONS(&#39;Tried versions %s but all were invalid&#39; % self._api_versions_to_try)

    def _handle_backoff(self, e):
        &#34;&#34;&#34;Take a request from the server to back off and checks the retry policy for what to do. Re-raise the
        exception if conditions are not met.

        :param e: An ErrorServerBusy instance
        :return:
        &#34;&#34;&#34;
        log.debug(&#39;Got ErrorServerBusy (back off %s seconds)&#39;, e.back_off)
        # ErrorServerBusy is very often a symptom of sending too many requests. Scale back connections if possible.
        try:
            self.protocol.decrease_poolsize()
        except SessionPoolMinSizeReached:
            pass
        if self.protocol.retry_policy.fail_fast:
            raise e
        self.protocol.retry_policy.back_off(e.back_off)
        # We&#39;ll warn about this later if we actually need to sleep

    def _update_api_version(self, api_version, header, **parse_opts):
        &#34;&#34;&#34;Parse the server version contained in SOAP headers and update the version hint stored by the caller, if
        necessary.
        &#34;&#34;&#34;
        try:
            head_version = Version.from_soap_header(requested_api_version=api_version, header=header)
        except TransportError as te:
            log.debug(&#39;Failed to update version info (%s)&#39;, te)
            return
        if self._version_hint == head_version:
            # Nothing to do
            return
        log.debug(&#39;Found new version (%s -&gt; %s)&#39;, self._version_hint, head_version)
        # The api_version that worked was different than our hint, or we never got a build version. Store the working
        # version.
        self._version_hint = head_version

    @classmethod
    def _response_tag(cls):
        &#34;&#34;&#34;Return the name of the element containing the service response.&#34;&#34;&#34;
        return &#39;{%s}%sResponse&#39; % (MNS, cls.SERVICE_NAME)

    @staticmethod
    def _response_messages_tag():
        &#34;&#34;&#34;Return the name of the element containing service response messages.&#34;&#34;&#34;
        return &#39;{%s}ResponseMessages&#39; % MNS

    @classmethod
    def _response_message_tag(cls):
        &#34;&#34;&#34;Return the name of the element of a single response message.&#34;&#34;&#34;
        return &#39;{%s}%sResponseMessage&#39; % (MNS, cls.SERVICE_NAME)

    @classmethod
    def _get_soap_parts(cls, response, **parse_opts):
        &#34;&#34;&#34;Split the SOAP response into its headers an body elements.&#34;&#34;&#34;
        try:
            root = to_xml(response.iter_content())
        except ParseError as e:
            raise SOAPError(&#39;Bad SOAP response: %s&#39; % e)
        header = root.find(&#39;{%s}Header&#39; % SOAPNS)
        if header is None:
            # This is normal when the response contains SOAP-level errors
            log.debug(&#39;No header in XML response&#39;)
        body = root.find(&#39;{%s}Body&#39; % SOAPNS)
        if body is None:
            raise MalformedResponseError(&#39;No Body element in SOAP response&#39;)
        return header, body

    def _get_soap_messages(self, body, **parse_opts):
        &#34;&#34;&#34;Return the elements in the response containing the response messages. Raises any SOAP exceptions.&#34;&#34;&#34;
        response = body.find(self._response_tag())
        if response is None:
            fault = body.find(&#39;{%s}Fault&#39; % SOAPNS)
            if fault is None:
                raise SOAPError(
                    &#39;Unknown SOAP response (expected %s or Fault): %s&#39; % (self._response_tag(), xml_to_str(body))
                )
            self._raise_soap_errors(fault=fault)  # Will throw SOAPError or custom EWS error
        response_messages = response.find(self._response_messages_tag())
        if response_messages is None:
            # Result isn&#39;t delivered in a list of FooResponseMessages, but directly in the FooResponse. Consumers expect
            # a list, so return a list
            return [response]
        return response_messages.findall(self._response_message_tag())

    @classmethod
    def _raise_soap_errors(cls, fault):
        &#34;&#34;&#34;Parse error messages contained in SOAP headers and raise as exceptions defined in this package.&#34;&#34;&#34;
        # Fault: See http://www.w3.org/TR/2000/NOTE-SOAP-20000508/#_Toc478383507
        faultcode = get_xml_attr(fault, &#39;faultcode&#39;)
        faultstring = get_xml_attr(fault, &#39;faultstring&#39;)
        faultactor = get_xml_attr(fault, &#39;faultactor&#39;)
        detail = fault.find(&#39;detail&#39;)
        if detail is not None:
            code, msg = None, &#39;&#39;
            if detail.find(&#39;{%s}ResponseCode&#39; % ENS) is not None:
                code = get_xml_attr(detail, &#39;{%s}ResponseCode&#39; % ENS).strip()
            if detail.find(&#39;{%s}Message&#39; % ENS) is not None:
                msg = get_xml_attr(detail, &#39;{%s}Message&#39; % ENS).strip()
            msg_xml = detail.find(&#39;{%s}MessageXml&#39; % TNS)  # Crazy. Here, it&#39;s in the TNS namespace
            if code == &#39;ErrorServerBusy&#39;:
                back_off = None
                try:
                    value = msg_xml.find(&#39;{%s}Value&#39; % TNS)
                    if value.get(&#39;Name&#39;) == &#39;BackOffMilliseconds&#39;:
                        back_off = int(value.text) / 1000.0  # Convert to seconds
                except (TypeError, AttributeError):
                    pass
                raise ErrorServerBusy(msg, back_off=back_off)
            if code == &#39;ErrorSchemaValidation&#39; and msg_xml is not None:
                violation = get_xml_attr(msg_xml, &#39;{%s}Violation&#39; % TNS)
                if violation is not None:
                    msg = &#39;%s %s&#39; % (msg, violation)
            try:
                raise vars(errors)[code](msg)
            except KeyError:
                detail = &#39;%s: code: %s msg: %s (%s)&#39; % (cls.SERVICE_NAME, code, msg, xml_to_str(detail))
        try:
            raise vars(errors)[faultcode](faultstring)
        except KeyError:
            pass
        raise SOAPError(&#39;SOAP error code: %s string: %s actor: %s detail: %s&#39; % (
            faultcode, faultstring, faultactor, detail))

    def _get_element_container(self, message, name=None):
        &#34;&#34;&#34;Return the XML element in a response element that contains the elements we want the service to return. For
        example, in a GetFolder response, &#39;message&#39; is the GetFolderResponseMessage element, and we return the &#39;Folders&#39;
        element:

        &lt;m:GetFolderResponseMessage ResponseClass=&#34;Success&#34;&gt;
          &lt;m:ResponseCode&gt;NoError&lt;/m:ResponseCode&gt;
          &lt;m:Folders&gt;
            &lt;t:Folder&gt;
              &lt;t:FolderId Id=&#34;AQApA=&#34; ChangeKey=&#34;AQAAAB&#34; /&gt;
              [...]
            &lt;/t:Folder&gt;
          &lt;/m:Folders&gt;
        &lt;/m:GetFolderResponseMessage&gt;

        Some service responses don&#39;t have a containing element for the returned elements (&#39;name&#39; is None). In
        that case, we return the &#39;SomeServiceResponseMessage&#39; element.

        If the response contains a warning or an error message, we raise the relevant exception, unless the error class
        is contained in WARNINGS_TO_CATCH_IN_RESPONSE or ERRORS_TO_CATCH_IN_RESPONSE, in which case we return the
        exception instance.
        &#34;&#34;&#34;
        # ResponseClass is an XML attribute of various SomeServiceResponseMessage elements: Possible values are:
        # Success, Warning, Error. See e.g.
        # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/finditemresponsemessage
        response_class = message.get(&#39;ResponseClass&#39;)
        # ResponseCode, MessageText: See
        # https://docs.microsoft.com/en-us/exchange/client-developer/web-service-reference/responsecode
        response_code = get_xml_attr(message, &#39;{%s}ResponseCode&#39; % MNS)
        if response_class == &#39;Success&#39; and response_code == &#39;NoError&#39;:
            if not name:
                return message
            container = message.find(name)
            if container is None:
                raise MalformedResponseError(&#39;No %s elements in ResponseMessage (%s)&#39; % (name, xml_to_str(message)))
            return container
        if response_code == &#39;NoError&#39;:
            return True
        # Raise any non-acceptable errors in the container, or return the container or the acceptable exception instance
        msg_text = get_xml_attr(message, &#39;{%s}MessageText&#39; % MNS)
        msg_xml = message.find(&#39;{%s}MessageXml&#39; % MNS)
        if response_class == &#39;Warning&#39;:
            try:
                raise self._get_exception(code=response_code, text=msg_text, msg_xml=msg_xml)
            except self.WARNINGS_TO_CATCH_IN_RESPONSE as e:
                return e
            except self.WARNINGS_TO_IGNORE_IN_RESPONSE as e:
                log.warning(str(e))
                container = message.find(name)
                if container is None:
                    raise MalformedResponseError(&#39;No %s elements in ResponseMessage (%s)&#39; % (name, xml_to_str(message)))
                return container
        # rspclass == &#39;Error&#39;, or &#39;Success&#39; and not &#39;NoError&#39;
        try:
            raise self._get_exception(code=response_code, text=msg_text, msg_xml=msg_xml)
        except self.ERRORS_TO_CATCH_IN_RESPONSE as e:
            return e

    @staticmethod
    def _get_exception(code, text, msg_xml):
        &#34;&#34;&#34;Parse error messages contained in EWS responses and raise as exceptions defined in this package.&#34;&#34;&#34;
        if not code:
            return TransportError(&#39;Empty ResponseCode in ResponseMessage (MessageText: %s, MessageXml: %s)&#39; % (
                text, msg_xml))
        if msg_xml is not None:
            # If this is an ErrorInvalidPropertyRequest error, the xml may contain a specific FieldURI
            for elem_cls in (FieldURI, IndexedFieldURI, ExtendedFieldURI, ExceptionFieldURI):
                elem = msg_xml.find(elem_cls.response_tag())
                if elem is not None:
                    field_uri = elem_cls.from_xml(elem, account=None)
                    text += &#39; (field: %s)&#39; % field_uri
                    break

            # If this is an ErrorInvalidValueForProperty error, the xml may contain the name and value of the property
            if code == &#39;ErrorInvalidValueForProperty&#39;:
                msg_parts = {}
                for elem in msg_xml.findall(&#39;{%s}Value&#39; % TNS):
                    key, val = elem.get(&#39;Name&#39;), elem.text
                    if key:
                        msg_parts[key] = val
                if msg_parts:
                    text += &#39; (%s)&#39; % &#39;, &#39;.join(&#39;%s: %s&#39; % (k, v) for k, v in msg_parts.items())

            # If this is an ErrorInternalServerError error, the xml may contain a more specific error code
            inner_code, inner_text = None, None
            for value_elem in msg_xml.findall(&#39;{%s}Value&#39; % TNS):
                name = value_elem.get(&#39;Name&#39;)
                if name == &#39;InnerErrorResponseCode&#39;:
                    inner_code = value_elem.text
                elif name == &#39;InnerErrorMessageText&#39;:
                    inner_text = value_elem.text
            if inner_code:
                try:
                    # Raise the error as the inner error code
                    return vars(errors)[inner_code](&#39;%s (raised from: %s(%r))&#39; % (inner_text, code, text))
                except KeyError:
                    # Inner code is unknown to us. Just append to the original text
                    text += &#39; (inner error: %s(%r))&#39; % (inner_code, inner_text)
        try:
            # Raise the error corresponding to the ResponseCode
            return vars(errors)[code](text)
        except KeyError:
            # Should not happen
            return TransportError(&#39;Unknown ResponseCode in ResponseMessage: %s (MessageText: %s, MessageXml: %s)&#39; % (
                    code, text, msg_xml))

    def _get_elements_in_response(self, response):
        &#34;&#34;&#34;Take a list of &#39;SomeServiceResponseMessage&#39; elements and return the elements in each response message that
        we want the service to return. With e.g. &#39;CreateItem&#39;, we get a list of &#39;CreateItemResponseMessage&#39; elements
        and return the &#39;Message&#39; elements.

        &lt;m:CreateItemResponseMessage ResponseClass=&#34;Success&#34;&gt;
          &lt;m:ResponseCode&gt;NoError&lt;/m:ResponseCode&gt;
          &lt;m:Items&gt;
            &lt;t:Message&gt;
              &lt;t:ItemId Id=&#34;AQApA=&#34; ChangeKey=&#34;AQAAAB&#34;/&gt;
            &lt;/t:Message&gt;
          &lt;/m:Items&gt;
        &lt;/m:CreateItemResponseMessage&gt;
        &lt;m:CreateItemResponseMessage ResponseClass=&#34;Success&#34;&gt;
          &lt;m:ResponseCode&gt;NoError&lt;/m:ResponseCode&gt;
          &lt;m:Items&gt;
            &lt;t:Message&gt;
              &lt;t:ItemId Id=&#34;AQApB=&#34; ChangeKey=&#34;AQAAAC&#34;/&gt;
            &lt;/t:Message&gt;
          &lt;/m:Items&gt;
        &lt;/m:CreateItemResponseMessage&gt;

        :param response: a list of &#39;SomeServiceResponseMessage&#39; XML objects
        :return: a generator of items as returned by &#39;_get_elements_in_container()
        &#34;&#34;&#34;
        for msg in response:
            container_or_exc = self._get_element_container(message=msg, name=self.element_container_name)
            if isinstance(container_or_exc, (bool, Exception)):
                yield container_or_exc
            else:
                for c in self._get_elements_in_container(container=container_or_exc):
                    yield c

    @classmethod
    def _get_elements_in_container(cls, container):
        &#34;&#34;&#34;Return a list of response elements from an XML response element container. With e.g.
        &#39;CreateItem&#39;, &#39;Items&#39; is the container element and we return the &#39;Message&#39; child elements:

          &lt;m:Items&gt;
            &lt;t:Message&gt;
              &lt;t:ItemId Id=&#34;AQApA=&#34; ChangeKey=&#34;AQAAAB&#34;/&gt;
            &lt;/t:Message&gt;
          &lt;/m:Items&gt;

        If the service does not return response elements, return True to indicate the status. Errors have already been
        raised.
        &#34;&#34;&#34;
        if cls.returns_elements:
            return list(container)
        return [True]

    def _get_elems_from_page(self, elem, max_items, total_item_count):
        container = elem.find(self.element_container_name)
        if container is None:
            raise MalformedResponseError(&#39;No %s elements in ResponseMessage (%s)&#39; % (
                self.element_container_name, xml_to_str(elem)))
        for e in self._get_elements_in_container(container=container):
            if max_items and total_item_count &gt;= max_items:
                # No need to continue. Break out of elements loop
                log.debug(&#34;&#39;max_items&#39; count reached (elements)&#34;)
                break
            yield e

    def _get_pages(self, payload_func, kwargs, expected_message_count):
        &#34;&#34;&#34;Request a page, or a list of pages if multiple collections are pages in a single request. Return each
        page.
        &#34;&#34;&#34;
        payload = payload_func(**kwargs)
        page_elems = list(self._get_elements(payload=payload))
        if len(page_elems) != expected_message_count:
            raise MalformedResponseError(
                &#34;Expected %s items in &#39;response&#39;, got %s&#34; % (expected_message_count, len(page_elems))
            )
        return page_elems

    @staticmethod
    def _get_next_offset(paging_infos):
        next_offsets = {p[&#39;next_offset&#39;] for p in paging_infos if p[&#39;next_offset&#39;] is not None}
        if not next_offsets:
            # Paging is done for all messages
            return None
        # We cannot guarantee that all messages that have a next_offset also have the *same* next_offset. This is
        # because the collections that we are iterating may change while iterating. We&#39;ll do our best but we cannot
        # guarantee 100% consistency when large collections are simultaneously being changed on the server.
        #
        # It&#39;s not possible to supply a per-folder offset when iterating multiple folders, so we&#39;ll just have to
        # choose something that is most likely to work. Select the lowest of all the values to at least make sure
        # we don&#39;t miss any items, although we may then get duplicates ¯\_(ツ)_/¯
        if len(next_offsets) &gt; 1:
            log.warning(&#39;Inconsistent next_offset values: %r. Using lowest value&#39;, next_offsets)
        return min(next_offsets)

    def _paged_call(self, payload_func, max_items, expected_message_count, **kwargs):
        &#34;&#34;&#34;Call a service that supports paging requests. Return a generator over all response items. Keeps track of
        all paging-related counters.
        &#34;&#34;&#34;
        paging_infos = [dict(item_count=0, next_offset=None) for _ in range(expected_message_count)]
        common_next_offset = kwargs[&#39;offset&#39;]
        total_item_count = 0
        while True:
            log.debug(&#39;Getting page at offset %s (max_items %s)&#39;, common_next_offset, max_items)
            kwargs[&#39;offset&#39;] = common_next_offset
            pages = self._get_pages(payload_func, kwargs, expected_message_count)
            for (page, next_offset), paging_info in zip(pages, paging_infos):
                paging_info[&#39;next_offset&#39;] = next_offset
                if isinstance(page, Exception):
                    yield page
                    continue
                if page is not None:
                    for elem in self._get_elems_from_page(page, max_items, total_item_count):
                        paging_info[&#39;item_count&#39;] += 1
                        total_item_count += 1
                        yield elem
                    if max_items and total_item_count &gt;= max_items:
                        # No need to continue. Break out of inner loop
                        log.debug(&#34;&#39;max_items&#39; count reached (inner)&#34;)
                        break
                if not paging_info[&#39;next_offset&#39;]:
                    # Paging is done for this message
                    continue
                # Check sanity of paging offsets, but don&#39;t fail. When we are iterating huge collections that take a
                # long time to complete, the collection may change while we are iterating. This can affect the
                # &#39;next_offset&#39; value and make it inconsistent with the number of already collected items.
                # We may have a mismatch if we stopped early due to reaching &#39;max_items&#39;.
                if paging_info[&#39;next_offset&#39;] != paging_info[&#39;item_count&#39;] and (
                    not max_items or total_item_count &lt; max_items
                ):
                    log.warning(&#39;Unexpected next offset: %s -&gt; %s. Maybe the server-side collection has changed?&#39;,
                                paging_info[&#39;item_count&#39;], paging_info[&#39;next_offset&#39;])
            # Also break out of outer loop
            if max_items and total_item_count &gt;= max_items:
                log.debug(&#34;&#39;max_items&#39; count reached (outer)&#34;)
                break
            common_next_offset = self._get_next_offset(paging_infos)
            if common_next_offset is None:
                # Paging is done for all messages
                break

    @staticmethod
    def _get_paging_values(elem):
        &#34;&#34;&#34;Read paging information from the paging container element.&#34;&#34;&#34;
        is_last_page = elem.get(&#39;IncludesLastItemInRange&#39;).lower() in (&#39;true&#39;, &#39;0&#39;)
        offset = elem.get(&#39;IndexedPagingOffset&#39;)
        if offset is None and not is_last_page:
            log.debug(&#34;Not last page in range, but Exchange didn&#39;t send a page offset. Assuming first page&#34;)
            offset = &#39;1&#39;
        next_offset = None if is_last_page else int(offset)
        item_count = int(elem.get(&#39;TotalItemsInView&#39;))
        if not item_count and next_offset is not None:
            raise ValueError(&#34;Expected empty &#39;next_offset&#39; when &#39;item_count&#39; is 0&#34;)
        log.debug(&#39;Got page with next offset %s (last_page %s)&#39;, next_offset, is_last_page)
        return item_count, next_offset

    def _get_page(self, message):
        &#34;&#34;&#34;Get a single page from a request message, and return the container and next offset.&#34;&#34;&#34;
        paging_elem = self._get_element_container(message=message, name=self.paging_container_name)
        if isinstance(paging_elem, Exception):
            return paging_elem, None
        item_count, next_offset = self._get_paging_values(paging_elem)
        if not item_count:
            paging_elem = None
        return paging_elem, next_offset</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.services.common.EWSAccountService" href="#exchangelib.services.common.EWSAccountService">EWSAccountService</a></li>
<li><a title="exchangelib.services.convert_id.ConvertId" href="convert_id.html#exchangelib.services.convert_id.ConvertId">ConvertId</a></li>
<li><a title="exchangelib.services.expand_dl.ExpandDL" href="expand_dl.html#exchangelib.services.expand_dl.ExpandDL">ExpandDL</a></li>
<li><a title="exchangelib.services.get_mail_tips.GetMailTips" href="get_mail_tips.html#exchangelib.services.get_mail_tips.GetMailTips">GetMailTips</a></li>
<li><a title="exchangelib.services.get_room_lists.GetRoomLists" href="get_room_lists.html#exchangelib.services.get_room_lists.GetRoomLists">GetRoomLists</a></li>
<li><a title="exchangelib.services.get_rooms.GetRooms" href="get_rooms.html#exchangelib.services.get_rooms.GetRooms">GetRooms</a></li>
<li><a title="exchangelib.services.get_searchable_mailboxes.GetSearchableMailboxes" href="get_searchable_mailboxes.html#exchangelib.services.get_searchable_mailboxes.GetSearchableMailboxes">GetSearchableMailboxes</a></li>
<li><a title="exchangelib.services.get_server_time_zones.GetServerTimeZones" href="get_server_time_zones.html#exchangelib.services.get_server_time_zones.GetServerTimeZones">GetServerTimeZones</a></li>
<li><a title="exchangelib.services.get_user_availability.GetUserAvailability" href="get_user_availability.html#exchangelib.services.get_user_availability.GetUserAvailability">GetUserAvailability</a></li>
<li><a title="exchangelib.services.resolve_names.ResolveNames" href="resolve_names.html#exchangelib.services.resolve_names.ResolveNames">ResolveNames</a></li>
<li><a title="exchangelib.services.send_notification.SendNotification" href="send_notification.html#exchangelib.services.send_notification.SendNotification">SendNotification</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.services.common.EWSService.ERRORS_TO_CATCH_IN_RESPONSE"><code class="name">var <span class="ident">ERRORS_TO_CATCH_IN_RESPONSE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.common.EWSService.NO_VALID_SERVER_VERSIONS"><code class="name">var <span class="ident">NO_VALID_SERVER_VERSIONS</span></code></dt>
<dd>
<div class="desc"><p>Global error type within this module.</p></div>
</dd>
<dt id="exchangelib.services.common.EWSService.SERVICE_NAME"><code class="name">var <span class="ident">SERVICE_NAME</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE"><code class="name">var <span class="ident">WARNINGS_TO_CATCH_IN_RESPONSE</span></code></dt>
<dd>
<div class="desc"><p>Global error type within this module.</p></div>
</dd>
<dt id="exchangelib.services.common.EWSService.WARNINGS_TO_IGNORE_IN_RESPONSE"><code class="name">var <span class="ident">WARNINGS_TO_IGNORE_IN_RESPONSE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.common.EWSService.element_container_name"><code class="name">var <span class="ident">element_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.common.EWSService.paging_container_name"><code class="name">var <span class="ident">paging_container_name</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.common.EWSService.prefer_affinity"><code class="name">var <span class="ident">prefer_affinity</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.common.EWSService.returns_elements"><code class="name">var <span class="ident">returns_elements</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.common.EWSService.supported_from"><code class="name">var <span class="ident">supported_from</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="exchangelib.services.common.EWSService.supports_paging"><code class="name">var <span class="ident">supports_paging</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.services.common.EWSService.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, expect_result=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Like .call(), but expects exactly one result from the server, or zero when expect_result=False, or either
zero or one when expect_result=None. Returns either one object or None.</p>
<p>:param expect_result: None, True, or False
:param kwargs: Same as arguments for .call()
:return: Same as .call(), but returns either None or exactly one item</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(self, expect_result=True, **kwargs):
    &#34;&#34;&#34;Like .call(), but expects exactly one result from the server, or zero when expect_result=False, or either
    zero or one when expect_result=None. Returns either one object or None.

    :param expect_result: None, True, or False
    :param kwargs: Same as arguments for .call()
    :return: Same as .call(), but returns either None or exactly one item
    &#34;&#34;&#34;
    res = list(self.call(**kwargs))
    # Raise any errors
    for r in res:
        if isinstance(r, Exception):
            raise r
    if expect_result is None and not res:
        # Allow empty result
        return None
    if expect_result is False:
        if res:
            raise ValueError(&#39;Expected result length 0, but got %r&#39; % res)
        return None
    if len(res) != 1:
        raise ValueError(&#39;Expected result length 1, but got %r&#39; % res)
    return res[0]</code></pre>
</details>
</dd>
<dt id="exchangelib.services.common.EWSService.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>self, xml)</span>
</code></dt>
<dd>
<div class="desc"><p>Used mostly for testing, when we want to parse static XML data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def parse(self, xml):
    &#34;&#34;&#34;Used mostly for testing, when we want to parse static XML data.&#34;&#34;&#34;
    resp = DummyResponse(url=None, headers=None, request_headers=None, content=xml)
    _, body = self._get_soap_parts(response=resp)
    return self._elems_to_objs(self._get_elements_in_response(response=self._get_soap_messages(body=body)))</code></pre>
</details>
</dd>
<dt id="exchangelib.services.common.EWSService.stop_streaming"><code class="name flex">
<span>def <span class="ident">stop_streaming</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop_streaming(self):
    if self._streaming_response:
        self._streaming_response.close()  # Release memory
        self._streaming_response = None
    if self._streaming_session:
        self.protocol.release_session(self._streaming_session)
        self._streaming_session = None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="exchangelib.services" href="index.html">exchangelib.services</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="exchangelib.services.common.create_attachment_ids_element" href="#exchangelib.services.common.create_attachment_ids_element">create_attachment_ids_element</a></code></li>
<li><code><a title="exchangelib.services.common.create_folder_ids_element" href="#exchangelib.services.common.create_folder_ids_element">create_folder_ids_element</a></code></li>
<li><code><a title="exchangelib.services.common.create_item_ids_element" href="#exchangelib.services.common.create_item_ids_element">create_item_ids_element</a></code></li>
<li><code><a title="exchangelib.services.common.create_shape_element" href="#exchangelib.services.common.create_shape_element">create_shape_element</a></code></li>
<li><code><a title="exchangelib.services.common.parse_folder_elem" href="#exchangelib.services.common.parse_folder_elem">parse_folder_elem</a></code></li>
<li><code><a title="exchangelib.services.common.to_item_id" href="#exchangelib.services.common.to_item_id">to_item_id</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exchangelib.services.common.EWSAccountService" href="#exchangelib.services.common.EWSAccountService">EWSAccountService</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.services.common.EWSService" href="#exchangelib.services.common.EWSService">EWSService</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.services.common.EWSService.ERRORS_TO_CATCH_IN_RESPONSE" href="#exchangelib.services.common.EWSService.ERRORS_TO_CATCH_IN_RESPONSE">ERRORS_TO_CATCH_IN_RESPONSE</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.NO_VALID_SERVER_VERSIONS" href="#exchangelib.services.common.EWSService.NO_VALID_SERVER_VERSIONS">NO_VALID_SERVER_VERSIONS</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.SERVICE_NAME" href="#exchangelib.services.common.EWSService.SERVICE_NAME">SERVICE_NAME</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE" href="#exchangelib.services.common.EWSService.WARNINGS_TO_CATCH_IN_RESPONSE">WARNINGS_TO_CATCH_IN_RESPONSE</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.WARNINGS_TO_IGNORE_IN_RESPONSE" href="#exchangelib.services.common.EWSService.WARNINGS_TO_IGNORE_IN_RESPONSE">WARNINGS_TO_IGNORE_IN_RESPONSE</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.element_container_name" href="#exchangelib.services.common.EWSService.element_container_name">element_container_name</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.get" href="#exchangelib.services.common.EWSService.get">get</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.paging_container_name" href="#exchangelib.services.common.EWSService.paging_container_name">paging_container_name</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.parse" href="#exchangelib.services.common.EWSService.parse">parse</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.prefer_affinity" href="#exchangelib.services.common.EWSService.prefer_affinity">prefer_affinity</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.returns_elements" href="#exchangelib.services.common.EWSService.returns_elements">returns_elements</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.stop_streaming" href="#exchangelib.services.common.EWSService.stop_streaming">stop_streaming</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.supported_from" href="#exchangelib.services.common.EWSService.supported_from">supported_from</a></code></li>
<li><code><a title="exchangelib.services.common.EWSService.supports_paging" href="#exchangelib.services.common.EWSService.supports_paging">supports_paging</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>