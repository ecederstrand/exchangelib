<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>exchangelib.folders.collections API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>exchangelib.folders.collections</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import abc
import logging

from cached_property import threaded_cached_property

from ..errors import InvalidTypeError
from ..fields import FieldPath, InvalidField
from ..items import ID_ONLY, Persona
from ..properties import CalendarView
from ..queryset import Q, QuerySet, SearchableMixIn
from ..restriction import Restriction
from ..util import require_account

log = logging.getLogger(__name__)


class SyncCompleted(Exception):
    &#34;&#34;&#34;This is really misusing an exception to return the sync state.&#34;&#34;&#34;

    def __init__(self, sync_state):
        super().__init__(sync_state)
        self.sync_state = sync_state


class FolderCollection(SearchableMixIn):
    &#34;&#34;&#34;A class that implements an API for searching folders.&#34;&#34;&#34;

    # These fields are required in a FindFolder or GetFolder call to properly identify folder types
    REQUIRED_FOLDER_FIELDS = (&#34;name&#34;, &#34;folder_class&#34;)

    def __init__(self, account, folders):
        &#34;&#34;&#34;Implement a search API on a collection of folders.

        :param account: An Account object
        :param folders: An iterable of folders, e.g. Folder.walk(), Folder.glob(), or [a.calendar, a.inbox]
        &#34;&#34;&#34;
        self.account = account
        self._folders = folders

    @threaded_cached_property
    def folders(self):
        # Resolve the list of folders, in case it&#39;s a generator
        return tuple(self._folders)

    def __len__(self):
        return len(self.folders)

    def __iter__(self):
        yield from self.folders

    def get(self, *args, **kwargs):
        return QuerySet(self).get(*args, **kwargs)

    def all(self):
        return QuerySet(self).all()

    def none(self):
        return QuerySet(self).none()

    def filter(self, *args, **kwargs):
        &#34;&#34;&#34;Find items in the folder(s).

        Non-keyword args may be a list of Q instances.

        Optional extra keyword arguments follow a Django-like QuerySet filter syntax (see
           https://docs.djangoproject.com/en/1.10/ref/models/querysets/#field-lookups).

        We don&#39;t support &#39;__year&#39; and other date-related lookups. We also don&#39;t support &#39;__endswith&#39; or &#39;__iendswith&#39;.

        We support the additional &#39;__not&#39; lookup in place of Django&#39;s exclude() for simple cases. For more complicated
        cases you need to create a Q object and use ~Q().

        Examples:

            my_account.inbox.filter(datetime_received__gt=EWSDateTime(2016, 1, 1))
            my_account.calendar.filter(start__range=(EWSDateTime(2016, 1, 1), EWSDateTime(2017, 1, 1)))
            my_account.tasks.filter(subject=&#39;Hi mom&#39;)
            my_account.tasks.filter(subject__not=&#39;Hi mom&#39;)
            my_account.tasks.filter(subject__contains=&#39;Foo&#39;)
            my_account.tasks.filter(subject__icontains=&#39;foo&#39;)

        &#39;endswith&#39; and &#39;iendswith&#39; could be emulated by searching with &#39;contains&#39; or &#39;icontains&#39; and then
        post-processing items. Fetch the field in question with additional_fields and remove items where the search
        string is not a postfix.
        &#34;&#34;&#34;
        return QuerySet(self).filter(*args, **kwargs)

    def exclude(self, *args, **kwargs):
        return QuerySet(self).exclude(*args, **kwargs)

    def people(self):
        return QuerySet(self).people()

    def view(self, start, end, max_items=None, *args, **kwargs):
        &#34;&#34;&#34;Implement the CalendarView option to FindItem. The difference between &#39;filter&#39; and &#39;view&#39; is that &#39;filter&#39;
        only returns the master CalendarItem for recurring items, while &#39;view&#39; unfolds recurring items and returns all
        CalendarItem occurrences as one would normally expect when presenting a calendar.

        Supports the same semantics as filter, except for &#39;start&#39; and &#39;end&#39; keyword attributes which are both required
        and behave differently than filter. Here, they denote the start and end of the timespan of the view. All items
        the overlap the timespan are returned (items that end exactly on &#39;start&#39; are also returned, for some reason).

        EWS does not allow combining CalendarView with search restrictions (filter and exclude).

        &#39;max_items&#39; defines the maximum number of items returned in this view. Optional.

        :param start:
        :param end:
        :param max_items:  (Default value = None)
        :return:
        &#34;&#34;&#34;
        qs = QuerySet(self).filter(*args, **kwargs)
        qs.calendar_view = CalendarView(start=start, end=end, max_items=max_items)
        return qs

    def allowed_item_fields(self):
        # Return non-ID fields of all item classes allowed in this folder type
        fields = set()
        for item_model in self.supported_item_models:
            fields.update(set(item_model.supported_fields(version=self.account.version)))
        return fields

    @property
    def supported_item_models(self):
        return tuple(item_model for folder in self.folders for item_model in folder.supported_item_models)

    def validate_item_field(self, field, version):
        # Takes a fieldname, Field or FieldPath object pointing to an item field, and checks that it is valid
        # for the item types supported by this folder collection.
        for item_model in self.supported_item_models:
            try:
                item_model.validate_field(field=field, version=version)
                break
            except InvalidField:
                continue
        else:
            raise InvalidField(f&#34;{field!r} is not a valid field on {self.supported_item_models}&#34;)

    def _rinse_args(self, q, depth, additional_fields, field_validator):
        if depth is None:
            depth = self._get_default_item_traversal_depth()
        if additional_fields:
            for f in additional_fields:
                field_validator(field=f, version=self.account.version)
                if f.field.is_complex:
                    raise ValueError(f&#34;Field {f.field.name!r} not supported for this service&#34;)

        # Build up any restrictions
        if q.is_empty():
            restriction = None
            query_string = None
        elif q.query_string:
            restriction = None
            query_string = Restriction(q, folders=self.folders, applies_to=Restriction.ITEMS)
        else:
            restriction = Restriction(q, folders=self.folders, applies_to=Restriction.ITEMS)
            query_string = None
        return depth, restriction, query_string

    def find_items(
        self,
        q,
        shape=ID_ONLY,
        depth=None,
        additional_fields=None,
        order_fields=None,
        calendar_view=None,
        page_size=None,
        max_items=None,
        offset=0,
    ):
        &#34;&#34;&#34;Private method to call the FindItem service.

        :param q: a Q instance containing any restrictions
        :param shape: controls whether to return (id, changekey) tuples or Item objects. If additional_fields is
          non-null, we always return Item objects. (Default value = ID_ONLY)
        :param depth: controls the whether to return soft-deleted items or not. (Default value = None)
        :param additional_fields: the extra properties we want on the return objects. Default is no properties. Be aware
          that complex fields can only be fetched with fetch() (i.e. the GetItem service).
        :param order_fields: the SortOrder fields, if any (Default value = None)
        :param calendar_view: a CalendarView instance, if any (Default value = None)
        :param page_size: the requested number of items per page (Default value = None)
        :param max_items: the max number of items to return (Default value = None)
        :param offset: the offset relative to the first item in the item collection (Default value = 0)

        :return: a generator for the returned item IDs or items
        &#34;&#34;&#34;
        from ..services import FindItem

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return
        if q.is_never():
            log.debug(&#34;Query will never return results&#34;)
            return
        depth, restriction, query_string = self._rinse_args(
            q=q, depth=depth, additional_fields=additional_fields, field_validator=self.validate_item_field
        )
        if calendar_view is not None and not isinstance(calendar_view, CalendarView):
            raise InvalidTypeError(&#34;calendar_view&#34;, calendar_view, CalendarView)

        log.debug(
            &#34;Finding %s items in folders %s (shape: %s, depth: %s, additional_fields: %s, restriction: %s)&#34;,
            self.account,
            self.folders,
            shape,
            depth,
            additional_fields,
            restriction.q if restriction else None,
        )
        yield from FindItem(account=self.account, page_size=page_size).call(
            folders=self.folders,
            additional_fields=additional_fields,
            restriction=restriction,
            order_fields=order_fields,
            shape=shape,
            query_string=query_string,
            depth=depth,
            calendar_view=calendar_view,
            max_items=calendar_view.max_items if calendar_view else max_items,
            offset=offset,
        )

    def _get_single_folder(self):
        if len(self.folders) &gt; 1:
            raise ValueError(&#34;Syncing folder hierarchy can only be done on a single folder&#34;)
        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return None
        return self.folders[0]

    def find_people(
        self,
        q,
        shape=ID_ONLY,
        depth=None,
        additional_fields=None,
        order_fields=None,
        page_size=None,
        max_items=None,
        offset=0,
    ):
        &#34;&#34;&#34;Private method to call the FindPeople service.

        :param q: a Q instance containing any restrictions
        :param shape: controls whether to return (id, changekey) tuples or Persona objects. If additional_fields is
          non-null, we always return Persona objects. (Default value = ID_ONLY)
        :param depth: controls the whether to return soft-deleted items or not. (Default value = None)
        :param additional_fields: the extra properties we want on the return objects. Default is no properties.
        :param order_fields: the SortOrder fields, if any (Default value = None)
        :param page_size: the requested number of items per page (Default value = None)
        :param max_items: the max number of items to return (Default value = None)
        :param offset: the offset relative to the first item in the item collection (Default value = 0)

        :return: a generator for the returned personas
        &#34;&#34;&#34;
        from ..services import FindPeople

        folder = self._get_single_folder()
        if q.is_never():
            log.debug(&#34;Query will never return results&#34;)
            return
        depth, restriction, query_string = self._rinse_args(
            q=q, depth=depth, additional_fields=additional_fields, field_validator=Persona.validate_field
        )

        yield from FindPeople(account=self.account, page_size=page_size).call(
            folder=folder,
            additional_fields=additional_fields,
            restriction=restriction,
            order_fields=order_fields,
            shape=shape,
            query_string=query_string,
            depth=depth,
            max_items=max_items,
            offset=offset,
        )

    def get_folder_fields(self, target_cls, is_complex=None):
        return {
            FieldPath(field=f)
            for f in target_cls.supported_fields(version=self.account.version)
            if is_complex is None or f.is_complex is is_complex
        }

    def _get_target_cls(self):
        # We may have root folders that don&#39;t support the same set of fields as normal folders. If there is a mix of
        # both folder types in self.folders, raise an error, so we don&#39;t risk losing some fields in the query.
        from .base import Folder
        from .roots import RootOfHierarchy

        has_roots = False
        has_non_roots = False
        for f in self.folders:
            if isinstance(f, RootOfHierarchy):
                if has_non_roots:
                    raise ValueError(f&#34;Cannot call GetFolder on a mix of folder types: {self.folders}&#34;)
                has_roots = True
            else:
                if has_roots:
                    raise ValueError(f&#34;Cannot call GetFolder on a mix of folder types: {self.folders}&#34;)
                has_non_roots = True
        return RootOfHierarchy if has_roots else Folder

    def _get_default_traversal_depth(self, traversal_attr):
        unique_depths = {getattr(f, traversal_attr) for f in self.folders}
        if len(unique_depths) == 1:
            return unique_depths.pop()
        raise ValueError(
            f&#34;Folders in this collection do not have a common {traversal_attr} value. You need to define an explicit &#34;
            f&#34;traversal depth with QuerySet.depth() (values: {unique_depths})&#34;
        )

    def _get_default_item_traversal_depth(self):
        # When searching folders, some folders require &#39;Shallow&#39; and others &#39;Associated&#39; traversal depth.
        return self._get_default_traversal_depth(&#34;DEFAULT_ITEM_TRAVERSAL_DEPTH&#34;)

    def _get_default_folder_traversal_depth(self):
        # When searching folders, some folders require &#39;Shallow&#39; and others &#39;Deep&#39; traversal depth.
        return self._get_default_traversal_depth(&#34;DEFAULT_FOLDER_TRAVERSAL_DEPTH&#34;)

    def resolve(self):
        # Looks up the folders or folder IDs in the collection and returns full Folder instances with all fields set.
        from .base import BaseFolder

        resolveable_folders = []
        for f in self.folders:
            if isinstance(f, BaseFolder) and not f.get_folder_allowed:
                log.debug(&#34;GetFolder not allowed on folder %s. Non-complex fields must be fetched with FindFolder&#34;, f)
                yield f
            else:
                resolveable_folders.append(f)
        # Fetch all properties for the remaining folders of folder IDs
        additional_fields = self.get_folder_fields(target_cls=self._get_target_cls())
        yield from self.__class__(account=self.account, folders=resolveable_folders).get_folders(
            additional_fields=additional_fields
        )

    @require_account
    def find_folders(
        self, q=None, shape=ID_ONLY, depth=None, additional_fields=None, page_size=None, max_items=None, offset=0
    ):
        from ..services import FindFolder

        # &#39;depth&#39; controls whether to return direct children or recurse into sub-folders
        from .base import BaseFolder, Folder

        if q is None:
            q = Q()
        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return
        if q.is_never():
            log.debug(&#34;Query will never return results&#34;)
            return
        if q.is_empty():
            restriction = None
        else:
            restriction = Restriction(q, folders=self.folders, applies_to=Restriction.FOLDERS)
        if depth is None:
            depth = self._get_default_folder_traversal_depth()
        if additional_fields is None:
            # Default to all non-complex properties. Sub-folders will always be of class Folder
            additional_fields = self.get_folder_fields(target_cls=Folder, is_complex=False)
        else:
            for f in additional_fields:
                if f.field.is_complex:
                    raise ValueError(f&#34;find_folders() does not support field {f.field.name!r}. Use get_folders().&#34;)

        # Add required fields
        additional_fields.update(
            (FieldPath(field=BaseFolder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
        )

        yield from FindFolder(account=self.account, page_size=page_size).call(
            folders=self.folders,
            additional_fields=additional_fields,
            restriction=restriction,
            shape=shape,
            depth=depth,
            max_items=max_items,
            offset=offset,
        )

    def get_folders(self, additional_fields=None):
        from ..services import GetFolder

        # Expand folders with their full set of properties
        from .base import BaseFolder

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return
        if additional_fields is None:
            # Default to all complex properties
            additional_fields = self.get_folder_fields(target_cls=self._get_target_cls(), is_complex=True)

        # Add required fields
        additional_fields.update(
            (FieldPath(field=BaseFolder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
        )

        yield from GetFolder(account=self.account).call(
            folders=self.folders,
            additional_fields=additional_fields,
            shape=ID_ONLY,
        )

    def subscribe_to_pull(self, event_types=None, watermark=None, timeout=60):
        from ..services import SubscribeToPull

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return None
        if event_types is None:
            event_types = SubscribeToPull.EVENT_TYPES
        return SubscribeToPull(account=self.account).get(
            folders=self.folders,
            event_types=event_types,
            watermark=watermark,
            timeout=timeout,
        )

    def subscribe_to_push(self, callback_url, event_types=None, watermark=None, status_frequency=1):
        from ..services import SubscribeToPush

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return None
        if event_types is None:
            event_types = SubscribeToPush.EVENT_TYPES
        return SubscribeToPush(account=self.account).get(
            folders=self.folders,
            event_types=event_types,
            watermark=watermark,
            status_frequency=status_frequency,
            url=callback_url,
        )

    def subscribe_to_streaming(self, event_types=None):
        from ..services import SubscribeToStreaming

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return None
        if event_types is None:
            event_types = SubscribeToStreaming.EVENT_TYPES
        return SubscribeToStreaming(account=self.account).get(folders=self.folders, event_types=event_types)

    def pull_subscription(self, **kwargs):
        return PullSubscription(target=self, **kwargs)

    def push_subscription(self, **kwargs):
        return PushSubscription(target=self, **kwargs)

    def streaming_subscription(self, **kwargs):
        return StreamingSubscription(target=self, **kwargs)

    def unsubscribe(self, subscription_id):
        &#34;&#34;&#34;Unsubscribe. Only applies to pull and streaming notifications.

        :param subscription_id: A subscription ID as acquired by .subscribe_to_[pull|streaming]()
        :return: True

        This method doesn&#39;t need the current collection instance, but it makes sense to keep the method along the other
        sync methods.
        &#34;&#34;&#34;
        from ..services import Unsubscribe

        return Unsubscribe(account=self.account).get(subscription_id=subscription_id)

    def sync_items(self, sync_state=None, only_fields=None, ignore=None, max_changes_returned=None, sync_scope=None):
        from ..services import SyncFolderItems

        folder = self._get_single_folder()
        if only_fields is None:
            # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
            additional_fields = {FieldPath(field=f) for f in folder.allowed_item_fields(version=self.account.version)}
        else:
            for field in only_fields:
                folder.validate_item_field(field=field, version=self.account.version)
            # Remove ItemId and ChangeKey. We get them unconditionally
            additional_fields = {f for f in folder.normalize_fields(fields=only_fields) if not f.field.is_attribute}

        svc = SyncFolderItems(account=self.account)
        while True:
            yield from svc.call(
                folder=folder,
                shape=ID_ONLY,
                additional_fields=additional_fields,
                sync_state=sync_state,
                ignore=ignore,
                max_changes_returned=max_changes_returned,
                sync_scope=sync_scope,
            )
            if svc.sync_state == sync_state:
                # We sometimes get the same sync_state back, even though includes_last_item_in_range is False. Stop here
                break
            sync_state = svc.sync_state  # Set the new sync state in the next call
            if svc.includes_last_item_in_range:  # Try again if there are more items
                break
        raise SyncCompleted(sync_state=svc.sync_state)

    def sync_hierarchy(self, sync_state=None, only_fields=None):
        from ..services import SyncFolderHierarchy

        folder = self._get_single_folder()
        if only_fields is None:
            # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
            additional_fields = {FieldPath(field=f) for f in folder.supported_fields(version=self.account.version)}
        else:
            additional_fields = set()
            for field_name in only_fields:
                folder.validate_field(field=field_name, version=self.account.version)
                f = folder.get_field_by_fieldname(fieldname=field_name)
                if not f.is_attribute:
                    # Remove ItemId and ChangeKey. We get them unconditionally
                    additional_fields.add(FieldPath(field=f))

        # Add required fields
        additional_fields.update(
            (FieldPath(field=folder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
        )

        svc = SyncFolderHierarchy(account=self.account)
        while True:
            yield from svc.call(
                folder=folder,
                shape=ID_ONLY,
                additional_fields=additional_fields,
                sync_state=sync_state,
            )
            if svc.sync_state == sync_state:
                # We sometimes get the same sync_state back, even though includes_last_item_in_range is False. Stop here
                break
            sync_state = svc.sync_state  # Set the new sync state in the next call
            if svc.includes_last_item_in_range:  # Try again if there are more items
                break
        raise SyncCompleted(sync_state=svc.sync_state)


class BaseSubscription(metaclass=abc.ABCMeta):
    def __init__(self, target, **subscription_kwargs):
        self.target = target
        self.subscription_kwargs = subscription_kwargs
        self.subscription_id = None

    @abc.abstractmethod
    def __enter__(self):
        &#34;&#34;&#34;Create the subscription&#34;&#34;&#34;

    def __exit__(self, *args, **kwargs):
        self.target.unsubscribe(subscription_id=self.subscription_id)
        self.subscription_id = None


class PullSubscription(BaseSubscription):
    def __enter__(self):
        self.subscription_id, watermark = self.target.subscribe_to_pull(**self.subscription_kwargs)
        return self.subscription_id, watermark


class PushSubscription(BaseSubscription):
    def __enter__(self):
        self.subscription_id, watermark = self.target.subscribe_to_push(**self.subscription_kwargs)
        return self.subscription_id, watermark

    def __exit__(self, *args, **kwargs):
        # Cannot unsubscribe to push subscriptions
        pass


class StreamingSubscription(BaseSubscription):
    def __enter__(self):
        self.subscription_id = self.target.subscribe_to_streaming(**self.subscription_kwargs)
        return self.subscription_id</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="exchangelib.folders.collections.BaseSubscription"><code class="flex name class">
<span>class <span class="ident">BaseSubscription</span></span>
<span>(</span><span>target, **subscription_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseSubscription(metaclass=abc.ABCMeta):
    def __init__(self, target, **subscription_kwargs):
        self.target = target
        self.subscription_kwargs = subscription_kwargs
        self.subscription_id = None

    @abc.abstractmethod
    def __enter__(self):
        &#34;&#34;&#34;Create the subscription&#34;&#34;&#34;

    def __exit__(self, *args, **kwargs):
        self.target.unsubscribe(subscription_id=self.subscription_id)
        self.subscription_id = None</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="exchangelib.folders.collections.PullSubscription" href="#exchangelib.folders.collections.PullSubscription">PullSubscription</a></li>
<li><a title="exchangelib.folders.collections.PushSubscription" href="#exchangelib.folders.collections.PushSubscription">PushSubscription</a></li>
<li><a title="exchangelib.folders.collections.StreamingSubscription" href="#exchangelib.folders.collections.StreamingSubscription">StreamingSubscription</a></li>
</ul>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection"><code class="flex name class">
<span>class <span class="ident">FolderCollection</span></span>
<span>(</span><span>account, folders)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that implements an API for searching folders.</p>
<p>Implement a search API on a collection of folders.</p>
<p>:param account: An Account object
:param folders: An iterable of folders, e.g. Folder.walk(), Folder.glob(), or [a.calendar, a.inbox]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FolderCollection(SearchableMixIn):
    &#34;&#34;&#34;A class that implements an API for searching folders.&#34;&#34;&#34;

    # These fields are required in a FindFolder or GetFolder call to properly identify folder types
    REQUIRED_FOLDER_FIELDS = (&#34;name&#34;, &#34;folder_class&#34;)

    def __init__(self, account, folders):
        &#34;&#34;&#34;Implement a search API on a collection of folders.

        :param account: An Account object
        :param folders: An iterable of folders, e.g. Folder.walk(), Folder.glob(), or [a.calendar, a.inbox]
        &#34;&#34;&#34;
        self.account = account
        self._folders = folders

    @threaded_cached_property
    def folders(self):
        # Resolve the list of folders, in case it&#39;s a generator
        return tuple(self._folders)

    def __len__(self):
        return len(self.folders)

    def __iter__(self):
        yield from self.folders

    def get(self, *args, **kwargs):
        return QuerySet(self).get(*args, **kwargs)

    def all(self):
        return QuerySet(self).all()

    def none(self):
        return QuerySet(self).none()

    def filter(self, *args, **kwargs):
        &#34;&#34;&#34;Find items in the folder(s).

        Non-keyword args may be a list of Q instances.

        Optional extra keyword arguments follow a Django-like QuerySet filter syntax (see
           https://docs.djangoproject.com/en/1.10/ref/models/querysets/#field-lookups).

        We don&#39;t support &#39;__year&#39; and other date-related lookups. We also don&#39;t support &#39;__endswith&#39; or &#39;__iendswith&#39;.

        We support the additional &#39;__not&#39; lookup in place of Django&#39;s exclude() for simple cases. For more complicated
        cases you need to create a Q object and use ~Q().

        Examples:

            my_account.inbox.filter(datetime_received__gt=EWSDateTime(2016, 1, 1))
            my_account.calendar.filter(start__range=(EWSDateTime(2016, 1, 1), EWSDateTime(2017, 1, 1)))
            my_account.tasks.filter(subject=&#39;Hi mom&#39;)
            my_account.tasks.filter(subject__not=&#39;Hi mom&#39;)
            my_account.tasks.filter(subject__contains=&#39;Foo&#39;)
            my_account.tasks.filter(subject__icontains=&#39;foo&#39;)

        &#39;endswith&#39; and &#39;iendswith&#39; could be emulated by searching with &#39;contains&#39; or &#39;icontains&#39; and then
        post-processing items. Fetch the field in question with additional_fields and remove items where the search
        string is not a postfix.
        &#34;&#34;&#34;
        return QuerySet(self).filter(*args, **kwargs)

    def exclude(self, *args, **kwargs):
        return QuerySet(self).exclude(*args, **kwargs)

    def people(self):
        return QuerySet(self).people()

    def view(self, start, end, max_items=None, *args, **kwargs):
        &#34;&#34;&#34;Implement the CalendarView option to FindItem. The difference between &#39;filter&#39; and &#39;view&#39; is that &#39;filter&#39;
        only returns the master CalendarItem for recurring items, while &#39;view&#39; unfolds recurring items and returns all
        CalendarItem occurrences as one would normally expect when presenting a calendar.

        Supports the same semantics as filter, except for &#39;start&#39; and &#39;end&#39; keyword attributes which are both required
        and behave differently than filter. Here, they denote the start and end of the timespan of the view. All items
        the overlap the timespan are returned (items that end exactly on &#39;start&#39; are also returned, for some reason).

        EWS does not allow combining CalendarView with search restrictions (filter and exclude).

        &#39;max_items&#39; defines the maximum number of items returned in this view. Optional.

        :param start:
        :param end:
        :param max_items:  (Default value = None)
        :return:
        &#34;&#34;&#34;
        qs = QuerySet(self).filter(*args, **kwargs)
        qs.calendar_view = CalendarView(start=start, end=end, max_items=max_items)
        return qs

    def allowed_item_fields(self):
        # Return non-ID fields of all item classes allowed in this folder type
        fields = set()
        for item_model in self.supported_item_models:
            fields.update(set(item_model.supported_fields(version=self.account.version)))
        return fields

    @property
    def supported_item_models(self):
        return tuple(item_model for folder in self.folders for item_model in folder.supported_item_models)

    def validate_item_field(self, field, version):
        # Takes a fieldname, Field or FieldPath object pointing to an item field, and checks that it is valid
        # for the item types supported by this folder collection.
        for item_model in self.supported_item_models:
            try:
                item_model.validate_field(field=field, version=version)
                break
            except InvalidField:
                continue
        else:
            raise InvalidField(f&#34;{field!r} is not a valid field on {self.supported_item_models}&#34;)

    def _rinse_args(self, q, depth, additional_fields, field_validator):
        if depth is None:
            depth = self._get_default_item_traversal_depth()
        if additional_fields:
            for f in additional_fields:
                field_validator(field=f, version=self.account.version)
                if f.field.is_complex:
                    raise ValueError(f&#34;Field {f.field.name!r} not supported for this service&#34;)

        # Build up any restrictions
        if q.is_empty():
            restriction = None
            query_string = None
        elif q.query_string:
            restriction = None
            query_string = Restriction(q, folders=self.folders, applies_to=Restriction.ITEMS)
        else:
            restriction = Restriction(q, folders=self.folders, applies_to=Restriction.ITEMS)
            query_string = None
        return depth, restriction, query_string

    def find_items(
        self,
        q,
        shape=ID_ONLY,
        depth=None,
        additional_fields=None,
        order_fields=None,
        calendar_view=None,
        page_size=None,
        max_items=None,
        offset=0,
    ):
        &#34;&#34;&#34;Private method to call the FindItem service.

        :param q: a Q instance containing any restrictions
        :param shape: controls whether to return (id, changekey) tuples or Item objects. If additional_fields is
          non-null, we always return Item objects. (Default value = ID_ONLY)
        :param depth: controls the whether to return soft-deleted items or not. (Default value = None)
        :param additional_fields: the extra properties we want on the return objects. Default is no properties. Be aware
          that complex fields can only be fetched with fetch() (i.e. the GetItem service).
        :param order_fields: the SortOrder fields, if any (Default value = None)
        :param calendar_view: a CalendarView instance, if any (Default value = None)
        :param page_size: the requested number of items per page (Default value = None)
        :param max_items: the max number of items to return (Default value = None)
        :param offset: the offset relative to the first item in the item collection (Default value = 0)

        :return: a generator for the returned item IDs or items
        &#34;&#34;&#34;
        from ..services import FindItem

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return
        if q.is_never():
            log.debug(&#34;Query will never return results&#34;)
            return
        depth, restriction, query_string = self._rinse_args(
            q=q, depth=depth, additional_fields=additional_fields, field_validator=self.validate_item_field
        )
        if calendar_view is not None and not isinstance(calendar_view, CalendarView):
            raise InvalidTypeError(&#34;calendar_view&#34;, calendar_view, CalendarView)

        log.debug(
            &#34;Finding %s items in folders %s (shape: %s, depth: %s, additional_fields: %s, restriction: %s)&#34;,
            self.account,
            self.folders,
            shape,
            depth,
            additional_fields,
            restriction.q if restriction else None,
        )
        yield from FindItem(account=self.account, page_size=page_size).call(
            folders=self.folders,
            additional_fields=additional_fields,
            restriction=restriction,
            order_fields=order_fields,
            shape=shape,
            query_string=query_string,
            depth=depth,
            calendar_view=calendar_view,
            max_items=calendar_view.max_items if calendar_view else max_items,
            offset=offset,
        )

    def _get_single_folder(self):
        if len(self.folders) &gt; 1:
            raise ValueError(&#34;Syncing folder hierarchy can only be done on a single folder&#34;)
        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return None
        return self.folders[0]

    def find_people(
        self,
        q,
        shape=ID_ONLY,
        depth=None,
        additional_fields=None,
        order_fields=None,
        page_size=None,
        max_items=None,
        offset=0,
    ):
        &#34;&#34;&#34;Private method to call the FindPeople service.

        :param q: a Q instance containing any restrictions
        :param shape: controls whether to return (id, changekey) tuples or Persona objects. If additional_fields is
          non-null, we always return Persona objects. (Default value = ID_ONLY)
        :param depth: controls the whether to return soft-deleted items or not. (Default value = None)
        :param additional_fields: the extra properties we want on the return objects. Default is no properties.
        :param order_fields: the SortOrder fields, if any (Default value = None)
        :param page_size: the requested number of items per page (Default value = None)
        :param max_items: the max number of items to return (Default value = None)
        :param offset: the offset relative to the first item in the item collection (Default value = 0)

        :return: a generator for the returned personas
        &#34;&#34;&#34;
        from ..services import FindPeople

        folder = self._get_single_folder()
        if q.is_never():
            log.debug(&#34;Query will never return results&#34;)
            return
        depth, restriction, query_string = self._rinse_args(
            q=q, depth=depth, additional_fields=additional_fields, field_validator=Persona.validate_field
        )

        yield from FindPeople(account=self.account, page_size=page_size).call(
            folder=folder,
            additional_fields=additional_fields,
            restriction=restriction,
            order_fields=order_fields,
            shape=shape,
            query_string=query_string,
            depth=depth,
            max_items=max_items,
            offset=offset,
        )

    def get_folder_fields(self, target_cls, is_complex=None):
        return {
            FieldPath(field=f)
            for f in target_cls.supported_fields(version=self.account.version)
            if is_complex is None or f.is_complex is is_complex
        }

    def _get_target_cls(self):
        # We may have root folders that don&#39;t support the same set of fields as normal folders. If there is a mix of
        # both folder types in self.folders, raise an error, so we don&#39;t risk losing some fields in the query.
        from .base import Folder
        from .roots import RootOfHierarchy

        has_roots = False
        has_non_roots = False
        for f in self.folders:
            if isinstance(f, RootOfHierarchy):
                if has_non_roots:
                    raise ValueError(f&#34;Cannot call GetFolder on a mix of folder types: {self.folders}&#34;)
                has_roots = True
            else:
                if has_roots:
                    raise ValueError(f&#34;Cannot call GetFolder on a mix of folder types: {self.folders}&#34;)
                has_non_roots = True
        return RootOfHierarchy if has_roots else Folder

    def _get_default_traversal_depth(self, traversal_attr):
        unique_depths = {getattr(f, traversal_attr) for f in self.folders}
        if len(unique_depths) == 1:
            return unique_depths.pop()
        raise ValueError(
            f&#34;Folders in this collection do not have a common {traversal_attr} value. You need to define an explicit &#34;
            f&#34;traversal depth with QuerySet.depth() (values: {unique_depths})&#34;
        )

    def _get_default_item_traversal_depth(self):
        # When searching folders, some folders require &#39;Shallow&#39; and others &#39;Associated&#39; traversal depth.
        return self._get_default_traversal_depth(&#34;DEFAULT_ITEM_TRAVERSAL_DEPTH&#34;)

    def _get_default_folder_traversal_depth(self):
        # When searching folders, some folders require &#39;Shallow&#39; and others &#39;Deep&#39; traversal depth.
        return self._get_default_traversal_depth(&#34;DEFAULT_FOLDER_TRAVERSAL_DEPTH&#34;)

    def resolve(self):
        # Looks up the folders or folder IDs in the collection and returns full Folder instances with all fields set.
        from .base import BaseFolder

        resolveable_folders = []
        for f in self.folders:
            if isinstance(f, BaseFolder) and not f.get_folder_allowed:
                log.debug(&#34;GetFolder not allowed on folder %s. Non-complex fields must be fetched with FindFolder&#34;, f)
                yield f
            else:
                resolveable_folders.append(f)
        # Fetch all properties for the remaining folders of folder IDs
        additional_fields = self.get_folder_fields(target_cls=self._get_target_cls())
        yield from self.__class__(account=self.account, folders=resolveable_folders).get_folders(
            additional_fields=additional_fields
        )

    @require_account
    def find_folders(
        self, q=None, shape=ID_ONLY, depth=None, additional_fields=None, page_size=None, max_items=None, offset=0
    ):
        from ..services import FindFolder

        # &#39;depth&#39; controls whether to return direct children or recurse into sub-folders
        from .base import BaseFolder, Folder

        if q is None:
            q = Q()
        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return
        if q.is_never():
            log.debug(&#34;Query will never return results&#34;)
            return
        if q.is_empty():
            restriction = None
        else:
            restriction = Restriction(q, folders=self.folders, applies_to=Restriction.FOLDERS)
        if depth is None:
            depth = self._get_default_folder_traversal_depth()
        if additional_fields is None:
            # Default to all non-complex properties. Sub-folders will always be of class Folder
            additional_fields = self.get_folder_fields(target_cls=Folder, is_complex=False)
        else:
            for f in additional_fields:
                if f.field.is_complex:
                    raise ValueError(f&#34;find_folders() does not support field {f.field.name!r}. Use get_folders().&#34;)

        # Add required fields
        additional_fields.update(
            (FieldPath(field=BaseFolder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
        )

        yield from FindFolder(account=self.account, page_size=page_size).call(
            folders=self.folders,
            additional_fields=additional_fields,
            restriction=restriction,
            shape=shape,
            depth=depth,
            max_items=max_items,
            offset=offset,
        )

    def get_folders(self, additional_fields=None):
        from ..services import GetFolder

        # Expand folders with their full set of properties
        from .base import BaseFolder

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return
        if additional_fields is None:
            # Default to all complex properties
            additional_fields = self.get_folder_fields(target_cls=self._get_target_cls(), is_complex=True)

        # Add required fields
        additional_fields.update(
            (FieldPath(field=BaseFolder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
        )

        yield from GetFolder(account=self.account).call(
            folders=self.folders,
            additional_fields=additional_fields,
            shape=ID_ONLY,
        )

    def subscribe_to_pull(self, event_types=None, watermark=None, timeout=60):
        from ..services import SubscribeToPull

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return None
        if event_types is None:
            event_types = SubscribeToPull.EVENT_TYPES
        return SubscribeToPull(account=self.account).get(
            folders=self.folders,
            event_types=event_types,
            watermark=watermark,
            timeout=timeout,
        )

    def subscribe_to_push(self, callback_url, event_types=None, watermark=None, status_frequency=1):
        from ..services import SubscribeToPush

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return None
        if event_types is None:
            event_types = SubscribeToPush.EVENT_TYPES
        return SubscribeToPush(account=self.account).get(
            folders=self.folders,
            event_types=event_types,
            watermark=watermark,
            status_frequency=status_frequency,
            url=callback_url,
        )

    def subscribe_to_streaming(self, event_types=None):
        from ..services import SubscribeToStreaming

        if not self.folders:
            log.debug(&#34;Folder list is empty&#34;)
            return None
        if event_types is None:
            event_types = SubscribeToStreaming.EVENT_TYPES
        return SubscribeToStreaming(account=self.account).get(folders=self.folders, event_types=event_types)

    def pull_subscription(self, **kwargs):
        return PullSubscription(target=self, **kwargs)

    def push_subscription(self, **kwargs):
        return PushSubscription(target=self, **kwargs)

    def streaming_subscription(self, **kwargs):
        return StreamingSubscription(target=self, **kwargs)

    def unsubscribe(self, subscription_id):
        &#34;&#34;&#34;Unsubscribe. Only applies to pull and streaming notifications.

        :param subscription_id: A subscription ID as acquired by .subscribe_to_[pull|streaming]()
        :return: True

        This method doesn&#39;t need the current collection instance, but it makes sense to keep the method along the other
        sync methods.
        &#34;&#34;&#34;
        from ..services import Unsubscribe

        return Unsubscribe(account=self.account).get(subscription_id=subscription_id)

    def sync_items(self, sync_state=None, only_fields=None, ignore=None, max_changes_returned=None, sync_scope=None):
        from ..services import SyncFolderItems

        folder = self._get_single_folder()
        if only_fields is None:
            # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
            additional_fields = {FieldPath(field=f) for f in folder.allowed_item_fields(version=self.account.version)}
        else:
            for field in only_fields:
                folder.validate_item_field(field=field, version=self.account.version)
            # Remove ItemId and ChangeKey. We get them unconditionally
            additional_fields = {f for f in folder.normalize_fields(fields=only_fields) if not f.field.is_attribute}

        svc = SyncFolderItems(account=self.account)
        while True:
            yield from svc.call(
                folder=folder,
                shape=ID_ONLY,
                additional_fields=additional_fields,
                sync_state=sync_state,
                ignore=ignore,
                max_changes_returned=max_changes_returned,
                sync_scope=sync_scope,
            )
            if svc.sync_state == sync_state:
                # We sometimes get the same sync_state back, even though includes_last_item_in_range is False. Stop here
                break
            sync_state = svc.sync_state  # Set the new sync state in the next call
            if svc.includes_last_item_in_range:  # Try again if there are more items
                break
        raise SyncCompleted(sync_state=svc.sync_state)

    def sync_hierarchy(self, sync_state=None, only_fields=None):
        from ..services import SyncFolderHierarchy

        folder = self._get_single_folder()
        if only_fields is None:
            # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
            additional_fields = {FieldPath(field=f) for f in folder.supported_fields(version=self.account.version)}
        else:
            additional_fields = set()
            for field_name in only_fields:
                folder.validate_field(field=field_name, version=self.account.version)
                f = folder.get_field_by_fieldname(fieldname=field_name)
                if not f.is_attribute:
                    # Remove ItemId and ChangeKey. We get them unconditionally
                    additional_fields.add(FieldPath(field=f))

        # Add required fields
        additional_fields.update(
            (FieldPath(field=folder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
        )

        svc = SyncFolderHierarchy(account=self.account)
        while True:
            yield from svc.call(
                folder=folder,
                shape=ID_ONLY,
                additional_fields=additional_fields,
                sync_state=sync_state,
            )
            if svc.sync_state == sync_state:
                # We sometimes get the same sync_state back, even though includes_last_item_in_range is False. Stop here
                break
            sync_state = svc.sync_state  # Set the new sync state in the next call
            if svc.includes_last_item_in_range:  # Try again if there are more items
                break
        raise SyncCompleted(sync_state=svc.sync_state)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.queryset.SearchableMixIn" href="../queryset.html#exchangelib.queryset.SearchableMixIn">SearchableMixIn</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="exchangelib.folders.collections.FolderCollection.REQUIRED_FOLDER_FIELDS"><code class="name">var <span class="ident">REQUIRED_FOLDER_FIELDS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="exchangelib.folders.collections.FolderCollection.folders"><code class="name">var <span class="ident">folders</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def __get__(self, obj, cls):
    if obj is None:
        return self

    obj_dict = obj.__dict__
    name = self.func.__name__
    with self.lock:
        try:
            # check if the value was computed before the lock was acquired
            return obj_dict[name]

        except KeyError:
            # if not, do the calculation and release the lock
            return obj_dict.setdefault(name, self.func(obj))</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.supported_item_models"><code class="name">var <span class="ident">supported_item_models</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def supported_item_models(self):
    return tuple(item_model for folder in self.folders for item_model in folder.supported_item_models)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="exchangelib.folders.collections.FolderCollection.allowed_item_fields"><code class="name flex">
<span>def <span class="ident">allowed_item_fields</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allowed_item_fields(self):
    # Return non-ID fields of all item classes allowed in this folder type
    fields = set()
    for item_model in self.supported_item_models:
        fields.update(set(item_model.supported_fields(version=self.account.version)))
    return fields</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Find items in the folder(s).</p>
<p>Non-keyword args may be a list of Q instances.</p>
<p>Optional extra keyword arguments follow a Django-like QuerySet filter syntax (see
<a href="https://docs.djangoproject.com/en/1.10/ref/models/querysets/#field-lookups">https://docs.djangoproject.com/en/1.10/ref/models/querysets/#field-lookups</a>).</p>
<p>We don't support '__year' and other date-related lookups. We also don't support '__endswith' or '__iendswith'.</p>
<p>We support the additional '__not' lookup in place of Django's exclude() for simple cases. For more complicated
cases you need to create a Q object and use ~Q().</p>
<h2 id="examples">Examples</h2>
<p>my_account.inbox.filter(datetime_received__gt=EWSDateTime(2016, 1, 1))
my_account.calendar.filter(start__range=(EWSDateTime(2016, 1, 1), EWSDateTime(2017, 1, 1)))
my_account.tasks.filter(subject='Hi mom')
my_account.tasks.filter(subject__not='Hi mom')
my_account.tasks.filter(subject__contains='Foo')
my_account.tasks.filter(subject__icontains='foo')</p>
<p>'endswith' and 'iendswith' could be emulated by searching with 'contains' or 'icontains' and then
post-processing items. Fetch the field in question with additional_fields and remove items where the search
string is not a postfix.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(self, *args, **kwargs):
    &#34;&#34;&#34;Find items in the folder(s).

    Non-keyword args may be a list of Q instances.

    Optional extra keyword arguments follow a Django-like QuerySet filter syntax (see
       https://docs.djangoproject.com/en/1.10/ref/models/querysets/#field-lookups).

    We don&#39;t support &#39;__year&#39; and other date-related lookups. We also don&#39;t support &#39;__endswith&#39; or &#39;__iendswith&#39;.

    We support the additional &#39;__not&#39; lookup in place of Django&#39;s exclude() for simple cases. For more complicated
    cases you need to create a Q object and use ~Q().

    Examples:

        my_account.inbox.filter(datetime_received__gt=EWSDateTime(2016, 1, 1))
        my_account.calendar.filter(start__range=(EWSDateTime(2016, 1, 1), EWSDateTime(2017, 1, 1)))
        my_account.tasks.filter(subject=&#39;Hi mom&#39;)
        my_account.tasks.filter(subject__not=&#39;Hi mom&#39;)
        my_account.tasks.filter(subject__contains=&#39;Foo&#39;)
        my_account.tasks.filter(subject__icontains=&#39;foo&#39;)

    &#39;endswith&#39; and &#39;iendswith&#39; could be emulated by searching with &#39;contains&#39; or &#39;icontains&#39; and then
    post-processing items. Fetch the field in question with additional_fields and remove items where the search
    string is not a postfix.
    &#34;&#34;&#34;
    return QuerySet(self).filter(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.find_folders"><code class="name flex">
<span>def <span class="ident">find_folders</span></span>(<span>self, q=None, shape='IdOnly', depth=None, additional_fields=None, page_size=None, max_items=None, offset=0)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@require_account
def find_folders(
    self, q=None, shape=ID_ONLY, depth=None, additional_fields=None, page_size=None, max_items=None, offset=0
):
    from ..services import FindFolder

    # &#39;depth&#39; controls whether to return direct children or recurse into sub-folders
    from .base import BaseFolder, Folder

    if q is None:
        q = Q()
    if not self.folders:
        log.debug(&#34;Folder list is empty&#34;)
        return
    if q.is_never():
        log.debug(&#34;Query will never return results&#34;)
        return
    if q.is_empty():
        restriction = None
    else:
        restriction = Restriction(q, folders=self.folders, applies_to=Restriction.FOLDERS)
    if depth is None:
        depth = self._get_default_folder_traversal_depth()
    if additional_fields is None:
        # Default to all non-complex properties. Sub-folders will always be of class Folder
        additional_fields = self.get_folder_fields(target_cls=Folder, is_complex=False)
    else:
        for f in additional_fields:
            if f.field.is_complex:
                raise ValueError(f&#34;find_folders() does not support field {f.field.name!r}. Use get_folders().&#34;)

    # Add required fields
    additional_fields.update(
        (FieldPath(field=BaseFolder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
    )

    yield from FindFolder(account=self.account, page_size=page_size).call(
        folders=self.folders,
        additional_fields=additional_fields,
        restriction=restriction,
        shape=shape,
        depth=depth,
        max_items=max_items,
        offset=offset,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.find_items"><code class="name flex">
<span>def <span class="ident">find_items</span></span>(<span>self, q, shape='IdOnly', depth=None, additional_fields=None, order_fields=None, calendar_view=None, page_size=None, max_items=None, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Private method to call the FindItem service.</p>
<p>:param q: a Q instance containing any restrictions
:param shape: controls whether to return (id, changekey) tuples or Item objects. If additional_fields is
non-null, we always return Item objects. (Default value = ID_ONLY)
:param depth: controls the whether to return soft-deleted items or not. (Default value = None)
:param additional_fields: the extra properties we want on the return objects. Default is no properties. Be aware
that complex fields can only be fetched with fetch() (i.e. the GetItem service).
:param order_fields: the SortOrder fields, if any (Default value = None)
:param calendar_view: a CalendarView instance, if any (Default value = None)
:param page_size: the requested number of items per page (Default value = None)
:param max_items: the max number of items to return (Default value = None)
:param offset: the offset relative to the first item in the item collection (Default value = 0)</p>
<p>:return: a generator for the returned item IDs or items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_items(
    self,
    q,
    shape=ID_ONLY,
    depth=None,
    additional_fields=None,
    order_fields=None,
    calendar_view=None,
    page_size=None,
    max_items=None,
    offset=0,
):
    &#34;&#34;&#34;Private method to call the FindItem service.

    :param q: a Q instance containing any restrictions
    :param shape: controls whether to return (id, changekey) tuples or Item objects. If additional_fields is
      non-null, we always return Item objects. (Default value = ID_ONLY)
    :param depth: controls the whether to return soft-deleted items or not. (Default value = None)
    :param additional_fields: the extra properties we want on the return objects. Default is no properties. Be aware
      that complex fields can only be fetched with fetch() (i.e. the GetItem service).
    :param order_fields: the SortOrder fields, if any (Default value = None)
    :param calendar_view: a CalendarView instance, if any (Default value = None)
    :param page_size: the requested number of items per page (Default value = None)
    :param max_items: the max number of items to return (Default value = None)
    :param offset: the offset relative to the first item in the item collection (Default value = 0)

    :return: a generator for the returned item IDs or items
    &#34;&#34;&#34;
    from ..services import FindItem

    if not self.folders:
        log.debug(&#34;Folder list is empty&#34;)
        return
    if q.is_never():
        log.debug(&#34;Query will never return results&#34;)
        return
    depth, restriction, query_string = self._rinse_args(
        q=q, depth=depth, additional_fields=additional_fields, field_validator=self.validate_item_field
    )
    if calendar_view is not None and not isinstance(calendar_view, CalendarView):
        raise InvalidTypeError(&#34;calendar_view&#34;, calendar_view, CalendarView)

    log.debug(
        &#34;Finding %s items in folders %s (shape: %s, depth: %s, additional_fields: %s, restriction: %s)&#34;,
        self.account,
        self.folders,
        shape,
        depth,
        additional_fields,
        restriction.q if restriction else None,
    )
    yield from FindItem(account=self.account, page_size=page_size).call(
        folders=self.folders,
        additional_fields=additional_fields,
        restriction=restriction,
        order_fields=order_fields,
        shape=shape,
        query_string=query_string,
        depth=depth,
        calendar_view=calendar_view,
        max_items=calendar_view.max_items if calendar_view else max_items,
        offset=offset,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.find_people"><code class="name flex">
<span>def <span class="ident">find_people</span></span>(<span>self, q, shape='IdOnly', depth=None, additional_fields=None, order_fields=None, page_size=None, max_items=None, offset=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Private method to call the FindPeople service.</p>
<p>:param q: a Q instance containing any restrictions
:param shape: controls whether to return (id, changekey) tuples or Persona objects. If additional_fields is
non-null, we always return Persona objects. (Default value = ID_ONLY)
:param depth: controls the whether to return soft-deleted items or not. (Default value = None)
:param additional_fields: the extra properties we want on the return objects. Default is no properties.
:param order_fields: the SortOrder fields, if any (Default value = None)
:param page_size: the requested number of items per page (Default value = None)
:param max_items: the max number of items to return (Default value = None)
:param offset: the offset relative to the first item in the item collection (Default value = 0)</p>
<p>:return: a generator for the returned personas</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_people(
    self,
    q,
    shape=ID_ONLY,
    depth=None,
    additional_fields=None,
    order_fields=None,
    page_size=None,
    max_items=None,
    offset=0,
):
    &#34;&#34;&#34;Private method to call the FindPeople service.

    :param q: a Q instance containing any restrictions
    :param shape: controls whether to return (id, changekey) tuples or Persona objects. If additional_fields is
      non-null, we always return Persona objects. (Default value = ID_ONLY)
    :param depth: controls the whether to return soft-deleted items or not. (Default value = None)
    :param additional_fields: the extra properties we want on the return objects. Default is no properties.
    :param order_fields: the SortOrder fields, if any (Default value = None)
    :param page_size: the requested number of items per page (Default value = None)
    :param max_items: the max number of items to return (Default value = None)
    :param offset: the offset relative to the first item in the item collection (Default value = 0)

    :return: a generator for the returned personas
    &#34;&#34;&#34;
    from ..services import FindPeople

    folder = self._get_single_folder()
    if q.is_never():
        log.debug(&#34;Query will never return results&#34;)
        return
    depth, restriction, query_string = self._rinse_args(
        q=q, depth=depth, additional_fields=additional_fields, field_validator=Persona.validate_field
    )

    yield from FindPeople(account=self.account, page_size=page_size).call(
        folder=folder,
        additional_fields=additional_fields,
        restriction=restriction,
        order_fields=order_fields,
        shape=shape,
        query_string=query_string,
        depth=depth,
        max_items=max_items,
        offset=offset,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.get_folder_fields"><code class="name flex">
<span>def <span class="ident">get_folder_fields</span></span>(<span>self, target_cls, is_complex=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_folder_fields(self, target_cls, is_complex=None):
    return {
        FieldPath(field=f)
        for f in target_cls.supported_fields(version=self.account.version)
        if is_complex is None or f.is_complex is is_complex
    }</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.get_folders"><code class="name flex">
<span>def <span class="ident">get_folders</span></span>(<span>self, additional_fields=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_folders(self, additional_fields=None):
    from ..services import GetFolder

    # Expand folders with their full set of properties
    from .base import BaseFolder

    if not self.folders:
        log.debug(&#34;Folder list is empty&#34;)
        return
    if additional_fields is None:
        # Default to all complex properties
        additional_fields = self.get_folder_fields(target_cls=self._get_target_cls(), is_complex=True)

    # Add required fields
    additional_fields.update(
        (FieldPath(field=BaseFolder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
    )

    yield from GetFolder(account=self.account).call(
        folders=self.folders,
        additional_fields=additional_fields,
        shape=ID_ONLY,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.pull_subscription"><code class="name flex">
<span>def <span class="ident">pull_subscription</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pull_subscription(self, **kwargs):
    return PullSubscription(target=self, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.push_subscription"><code class="name flex">
<span>def <span class="ident">push_subscription</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_subscription(self, **kwargs):
    return PushSubscription(target=self, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.resolve"><code class="name flex">
<span>def <span class="ident">resolve</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve(self):
    # Looks up the folders or folder IDs in the collection and returns full Folder instances with all fields set.
    from .base import BaseFolder

    resolveable_folders = []
    for f in self.folders:
        if isinstance(f, BaseFolder) and not f.get_folder_allowed:
            log.debug(&#34;GetFolder not allowed on folder %s. Non-complex fields must be fetched with FindFolder&#34;, f)
            yield f
        else:
            resolveable_folders.append(f)
    # Fetch all properties for the remaining folders of folder IDs
    additional_fields = self.get_folder_fields(target_cls=self._get_target_cls())
    yield from self.__class__(account=self.account, folders=resolveable_folders).get_folders(
        additional_fields=additional_fields
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.streaming_subscription"><code class="name flex">
<span>def <span class="ident">streaming_subscription</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def streaming_subscription(self, **kwargs):
    return StreamingSubscription(target=self, **kwargs)</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.subscribe_to_pull"><code class="name flex">
<span>def <span class="ident">subscribe_to_pull</span></span>(<span>self, event_types=None, watermark=None, timeout=60)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe_to_pull(self, event_types=None, watermark=None, timeout=60):
    from ..services import SubscribeToPull

    if not self.folders:
        log.debug(&#34;Folder list is empty&#34;)
        return None
    if event_types is None:
        event_types = SubscribeToPull.EVENT_TYPES
    return SubscribeToPull(account=self.account).get(
        folders=self.folders,
        event_types=event_types,
        watermark=watermark,
        timeout=timeout,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.subscribe_to_push"><code class="name flex">
<span>def <span class="ident">subscribe_to_push</span></span>(<span>self, callback_url, event_types=None, watermark=None, status_frequency=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe_to_push(self, callback_url, event_types=None, watermark=None, status_frequency=1):
    from ..services import SubscribeToPush

    if not self.folders:
        log.debug(&#34;Folder list is empty&#34;)
        return None
    if event_types is None:
        event_types = SubscribeToPush.EVENT_TYPES
    return SubscribeToPush(account=self.account).get(
        folders=self.folders,
        event_types=event_types,
        watermark=watermark,
        status_frequency=status_frequency,
        url=callback_url,
    )</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.subscribe_to_streaming"><code class="name flex">
<span>def <span class="ident">subscribe_to_streaming</span></span>(<span>self, event_types=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subscribe_to_streaming(self, event_types=None):
    from ..services import SubscribeToStreaming

    if not self.folders:
        log.debug(&#34;Folder list is empty&#34;)
        return None
    if event_types is None:
        event_types = SubscribeToStreaming.EVENT_TYPES
    return SubscribeToStreaming(account=self.account).get(folders=self.folders, event_types=event_types)</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.sync_hierarchy"><code class="name flex">
<span>def <span class="ident">sync_hierarchy</span></span>(<span>self, sync_state=None, only_fields=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync_hierarchy(self, sync_state=None, only_fields=None):
    from ..services import SyncFolderHierarchy

    folder = self._get_single_folder()
    if only_fields is None:
        # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
        additional_fields = {FieldPath(field=f) for f in folder.supported_fields(version=self.account.version)}
    else:
        additional_fields = set()
        for field_name in only_fields:
            folder.validate_field(field=field_name, version=self.account.version)
            f = folder.get_field_by_fieldname(fieldname=field_name)
            if not f.is_attribute:
                # Remove ItemId and ChangeKey. We get them unconditionally
                additional_fields.add(FieldPath(field=f))

    # Add required fields
    additional_fields.update(
        (FieldPath(field=folder.get_field_by_fieldname(f)) for f in self.REQUIRED_FOLDER_FIELDS)
    )

    svc = SyncFolderHierarchy(account=self.account)
    while True:
        yield from svc.call(
            folder=folder,
            shape=ID_ONLY,
            additional_fields=additional_fields,
            sync_state=sync_state,
        )
        if svc.sync_state == sync_state:
            # We sometimes get the same sync_state back, even though includes_last_item_in_range is False. Stop here
            break
        sync_state = svc.sync_state  # Set the new sync state in the next call
        if svc.includes_last_item_in_range:  # Try again if there are more items
            break
    raise SyncCompleted(sync_state=svc.sync_state)</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.sync_items"><code class="name flex">
<span>def <span class="ident">sync_items</span></span>(<span>self, sync_state=None, only_fields=None, ignore=None, max_changes_returned=None, sync_scope=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync_items(self, sync_state=None, only_fields=None, ignore=None, max_changes_returned=None, sync_scope=None):
    from ..services import SyncFolderItems

    folder = self._get_single_folder()
    if only_fields is None:
        # We didn&#39;t restrict list of field paths. Get all fields from the server, including extended properties.
        additional_fields = {FieldPath(field=f) for f in folder.allowed_item_fields(version=self.account.version)}
    else:
        for field in only_fields:
            folder.validate_item_field(field=field, version=self.account.version)
        # Remove ItemId and ChangeKey. We get them unconditionally
        additional_fields = {f for f in folder.normalize_fields(fields=only_fields) if not f.field.is_attribute}

    svc = SyncFolderItems(account=self.account)
    while True:
        yield from svc.call(
            folder=folder,
            shape=ID_ONLY,
            additional_fields=additional_fields,
            sync_state=sync_state,
            ignore=ignore,
            max_changes_returned=max_changes_returned,
            sync_scope=sync_scope,
        )
        if svc.sync_state == sync_state:
            # We sometimes get the same sync_state back, even though includes_last_item_in_range is False. Stop here
            break
        sync_state = svc.sync_state  # Set the new sync state in the next call
        if svc.includes_last_item_in_range:  # Try again if there are more items
            break
    raise SyncCompleted(sync_state=svc.sync_state)</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.unsubscribe"><code class="name flex">
<span>def <span class="ident">unsubscribe</span></span>(<span>self, subscription_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Unsubscribe. Only applies to pull and streaming notifications.</p>
<p>:param subscription_id: A subscription ID as acquired by .subscribe_to_<a href="">pull|streaming</a>
:return: True</p>
<p>This method doesn't need the current collection instance, but it makes sense to keep the method along the other
sync methods.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unsubscribe(self, subscription_id):
    &#34;&#34;&#34;Unsubscribe. Only applies to pull and streaming notifications.

    :param subscription_id: A subscription ID as acquired by .subscribe_to_[pull|streaming]()
    :return: True

    This method doesn&#39;t need the current collection instance, but it makes sense to keep the method along the other
    sync methods.
    &#34;&#34;&#34;
    from ..services import Unsubscribe

    return Unsubscribe(account=self.account).get(subscription_id=subscription_id)</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.validate_item_field"><code class="name flex">
<span>def <span class="ident">validate_item_field</span></span>(<span>self, field, version)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_item_field(self, field, version):
    # Takes a fieldname, Field or FieldPath object pointing to an item field, and checks that it is valid
    # for the item types supported by this folder collection.
    for item_model in self.supported_item_models:
        try:
            item_model.validate_field(field=field, version=version)
            break
        except InvalidField:
            continue
    else:
        raise InvalidField(f&#34;{field!r} is not a valid field on {self.supported_item_models}&#34;)</code></pre>
</details>
</dd>
<dt id="exchangelib.folders.collections.FolderCollection.view"><code class="name flex">
<span>def <span class="ident">view</span></span>(<span>self, start, end, max_items=None, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement the CalendarView option to FindItem. The difference between 'filter' and 'view' is that 'filter'
only returns the master CalendarItem for recurring items, while 'view' unfolds recurring items and returns all
CalendarItem occurrences as one would normally expect when presenting a calendar.</p>
<p>Supports the same semantics as filter, except for 'start' and 'end' keyword attributes which are both required
and behave differently than filter. Here, they denote the start and end of the timespan of the view. All items
the overlap the timespan are returned (items that end exactly on 'start' are also returned, for some reason).</p>
<p>EWS does not allow combining CalendarView with search restrictions (filter and exclude).</p>
<p>'max_items' defines the maximum number of items returned in this view. Optional.</p>
<p>:param start:
:param end:
:param max_items:
(Default value = None)
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def view(self, start, end, max_items=None, *args, **kwargs):
    &#34;&#34;&#34;Implement the CalendarView option to FindItem. The difference between &#39;filter&#39; and &#39;view&#39; is that &#39;filter&#39;
    only returns the master CalendarItem for recurring items, while &#39;view&#39; unfolds recurring items and returns all
    CalendarItem occurrences as one would normally expect when presenting a calendar.

    Supports the same semantics as filter, except for &#39;start&#39; and &#39;end&#39; keyword attributes which are both required
    and behave differently than filter. Here, they denote the start and end of the timespan of the view. All items
    the overlap the timespan are returned (items that end exactly on &#39;start&#39; are also returned, for some reason).

    EWS does not allow combining CalendarView with search restrictions (filter and exclude).

    &#39;max_items&#39; defines the maximum number of items returned in this view. Optional.

    :param start:
    :param end:
    :param max_items:  (Default value = None)
    :return:
    &#34;&#34;&#34;
    qs = QuerySet(self).filter(*args, **kwargs)
    qs.calendar_view = CalendarView(start=start, end=end, max_items=max_items)
    return qs</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="exchangelib.queryset.SearchableMixIn" href="../queryset.html#exchangelib.queryset.SearchableMixIn">SearchableMixIn</a></b></code>:
<ul class="hlist">
<li><code><a title="exchangelib.queryset.SearchableMixIn.all" href="../queryset.html#exchangelib.queryset.SearchableMixIn.all">all</a></code></li>
<li><code><a title="exchangelib.queryset.SearchableMixIn.exclude" href="../queryset.html#exchangelib.queryset.SearchableMixIn.exclude">exclude</a></code></li>
<li><code><a title="exchangelib.queryset.SearchableMixIn.get" href="../queryset.html#exchangelib.queryset.SearchableMixIn.get">get</a></code></li>
<li><code><a title="exchangelib.queryset.SearchableMixIn.none" href="../queryset.html#exchangelib.queryset.SearchableMixIn.none">none</a></code></li>
<li><code><a title="exchangelib.queryset.SearchableMixIn.people" href="../queryset.html#exchangelib.queryset.SearchableMixIn.people">people</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="exchangelib.folders.collections.PullSubscription"><code class="flex name class">
<span>class <span class="ident">PullSubscription</span></span>
<span>(</span><span>target, **subscription_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PullSubscription(BaseSubscription):
    def __enter__(self):
        self.subscription_id, watermark = self.target.subscribe_to_pull(**self.subscription_kwargs)
        return self.subscription_id, watermark</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.folders.collections.BaseSubscription" href="#exchangelib.folders.collections.BaseSubscription">BaseSubscription</a></li>
</ul>
</dd>
<dt id="exchangelib.folders.collections.PushSubscription"><code class="flex name class">
<span>class <span class="ident">PushSubscription</span></span>
<span>(</span><span>target, **subscription_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PushSubscription(BaseSubscription):
    def __enter__(self):
        self.subscription_id, watermark = self.target.subscribe_to_push(**self.subscription_kwargs)
        return self.subscription_id, watermark

    def __exit__(self, *args, **kwargs):
        # Cannot unsubscribe to push subscriptions
        pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.folders.collections.BaseSubscription" href="#exchangelib.folders.collections.BaseSubscription">BaseSubscription</a></li>
</ul>
</dd>
<dt id="exchangelib.folders.collections.StreamingSubscription"><code class="flex name class">
<span>class <span class="ident">StreamingSubscription</span></span>
<span>(</span><span>target, **subscription_kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StreamingSubscription(BaseSubscription):
    def __enter__(self):
        self.subscription_id = self.target.subscribe_to_streaming(**self.subscription_kwargs)
        return self.subscription_id</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="exchangelib.folders.collections.BaseSubscription" href="#exchangelib.folders.collections.BaseSubscription">BaseSubscription</a></li>
</ul>
</dd>
<dt id="exchangelib.folders.collections.SyncCompleted"><code class="flex name class">
<span>class <span class="ident">SyncCompleted</span></span>
<span>(</span><span>sync_state)</span>
</code></dt>
<dd>
<div class="desc"><p>This is really misusing an exception to return the sync state.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SyncCompleted(Exception):
    &#34;&#34;&#34;This is really misusing an exception to return the sync state.&#34;&#34;&#34;

    def __init__(self, sync_state):
        super().__init__(sync_state)
        self.sync_state = sync_state</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="exchangelib.folders" href="index.html">exchangelib.folders</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="exchangelib.folders.collections.BaseSubscription" href="#exchangelib.folders.collections.BaseSubscription">BaseSubscription</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.folders.collections.FolderCollection" href="#exchangelib.folders.collections.FolderCollection">FolderCollection</a></code></h4>
<ul class="">
<li><code><a title="exchangelib.folders.collections.FolderCollection.REQUIRED_FOLDER_FIELDS" href="#exchangelib.folders.collections.FolderCollection.REQUIRED_FOLDER_FIELDS">REQUIRED_FOLDER_FIELDS</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.allowed_item_fields" href="#exchangelib.folders.collections.FolderCollection.allowed_item_fields">allowed_item_fields</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.filter" href="#exchangelib.folders.collections.FolderCollection.filter">filter</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.find_folders" href="#exchangelib.folders.collections.FolderCollection.find_folders">find_folders</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.find_items" href="#exchangelib.folders.collections.FolderCollection.find_items">find_items</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.find_people" href="#exchangelib.folders.collections.FolderCollection.find_people">find_people</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.folders" href="#exchangelib.folders.collections.FolderCollection.folders">folders</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.get_folder_fields" href="#exchangelib.folders.collections.FolderCollection.get_folder_fields">get_folder_fields</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.get_folders" href="#exchangelib.folders.collections.FolderCollection.get_folders">get_folders</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.pull_subscription" href="#exchangelib.folders.collections.FolderCollection.pull_subscription">pull_subscription</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.push_subscription" href="#exchangelib.folders.collections.FolderCollection.push_subscription">push_subscription</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.resolve" href="#exchangelib.folders.collections.FolderCollection.resolve">resolve</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.streaming_subscription" href="#exchangelib.folders.collections.FolderCollection.streaming_subscription">streaming_subscription</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.subscribe_to_pull" href="#exchangelib.folders.collections.FolderCollection.subscribe_to_pull">subscribe_to_pull</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.subscribe_to_push" href="#exchangelib.folders.collections.FolderCollection.subscribe_to_push">subscribe_to_push</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.subscribe_to_streaming" href="#exchangelib.folders.collections.FolderCollection.subscribe_to_streaming">subscribe_to_streaming</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.supported_item_models" href="#exchangelib.folders.collections.FolderCollection.supported_item_models">supported_item_models</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.sync_hierarchy" href="#exchangelib.folders.collections.FolderCollection.sync_hierarchy">sync_hierarchy</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.sync_items" href="#exchangelib.folders.collections.FolderCollection.sync_items">sync_items</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.unsubscribe" href="#exchangelib.folders.collections.FolderCollection.unsubscribe">unsubscribe</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.validate_item_field" href="#exchangelib.folders.collections.FolderCollection.validate_item_field">validate_item_field</a></code></li>
<li><code><a title="exchangelib.folders.collections.FolderCollection.view" href="#exchangelib.folders.collections.FolderCollection.view">view</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="exchangelib.folders.collections.PullSubscription" href="#exchangelib.folders.collections.PullSubscription">PullSubscription</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.folders.collections.PushSubscription" href="#exchangelib.folders.collections.PushSubscription">PushSubscription</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.folders.collections.StreamingSubscription" href="#exchangelib.folders.collections.StreamingSubscription">StreamingSubscription</a></code></h4>
</li>
<li>
<h4><code><a title="exchangelib.folders.collections.SyncCompleted" href="#exchangelib.folders.collections.SyncCompleted">SyncCompleted</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
